<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>读书笔记 on BoilTask's Blog</title><link>https://boiltask.com/categories/notes/</link><description>Recent content in 读书笔记 on BoilTask's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Mon, 01 Aug 2022 11:21:14 +0000</lastBuildDate><atom:link href="https://boiltask.com/categories/notes/index.xml" rel="self" type="application/rss+xml"/><item><title>Lua设计与实现</title><link>https://boiltask.com/notes/lua-design-implement-1/</link><pubDate>Mon, 01 Aug 2022 11:21:14 +0000</pubDate><guid>https://boiltask.com/notes/lua-design-implement-1/</guid><description>&lt;h2 id="string实现">&lt;a href="#string%e5%ae%9e%e7%8e%b0" class="header-anchor">&lt;/a>String实现
&lt;/h2>&lt;h3 id="思路">&lt;a href="#%e6%80%9d%e8%b7%af" class="header-anchor">&lt;/a>思路
&lt;/h3>&lt;p>使用&lt;code>Hash&lt;/code>方式分配字符串，根据&lt;code>Hash&lt;/code>值获取对应桶，与其存在的元素比对，若都不相同，则在桶中新增元素&lt;/p>
&lt;p>需要判断的时候根据&lt;code>Hash&lt;/code>值判断&lt;/p>
&lt;p>❓是否需要再判断桶中所有元素&lt;/p>
&lt;h3 id="源码">&lt;a href="#%e6%ba%90%e7%a0%81" class="header-anchor">&lt;/a>源码
&lt;/h3>&lt;p>比对桶中元素时，先对比字符串长度，不同的则认为肯定不相同。&lt;/p>
&lt;p>最新的实现根据&lt;code>LUAI_MAXSHORTLEN = 40&lt;/code>判断长短字符串，对于短字符串计算&lt;code>Hash&lt;/code>并使用桶机制进行对比，对于长字符串通过随机种子来分配&lt;code>Hash&lt;/code>。&lt;/p>
&lt;p>❓长字符串的&lt;code>Hash&lt;/code>冲突如何解决&lt;/p></description></item><item><title>游戏设计的100个原理笔记(2) – 第1篇 游戏创新的一般原理（下）</title><link>https://boiltask.com/notes/100principles-2/</link><pubDate>Thu, 14 Nov 2019 11:00:24 +0000</pubDate><guid>https://boiltask.com/notes/100principles-2/</guid><description>&lt;h2 id="原理15-记忆和技巧">&lt;a href="#%e5%8e%9f%e7%90%8615-%e8%ae%b0%e5%bf%86%e5%92%8c%e6%8a%80%e5%b7%a7" class="header-anchor">&lt;/a>原理15 记忆和技巧
&lt;/h2>&lt;p>在游戏设计领域有很多游戏种类，有更广义的游戏分类方法把游戏分为记忆游戏和技巧游戏。&lt;/p>
&lt;p>在记忆游戏中需要用到试错法、记忆识别、本能反应（平台跳跃游戏）以及对游戏本身的掌握。技巧游戏需要体能或精神上的实力和条件来完成。许多游戏在特定情况下对这两种类型都有涵盖。&lt;/p>
&lt;p>记忆游戏可能会在玩了一段时间之后让玩家感到无聊，解决这个问题的方法是在保持游戏机制、故事和结果不变的前提下为游戏加入一些随机性。&lt;/p>
&lt;h2 id="原理16-极小极大与极大极小">&lt;a href="#%e5%8e%9f%e7%90%8616-%e6%9e%81%e5%b0%8f%e6%9e%81%e5%a4%a7%e4%b8%8e%e6%9e%81%e5%a4%a7%e6%9e%81%e5%b0%8f" class="header-anchor">&lt;/a>原理16 “极小极大”与“极大极小”
&lt;/h2>&lt;p>与“最小/最大化”（Min/Maxing）不同，“极小极大”（Minimax）指出，在一个零和博弈中，每个博弈者会选择一个能最大化他们回报的混合策略，由此产生的策略和回报的组合是帕累托最优的。&lt;/p>
&lt;p>在经济博弈论中，极小极大原理常被用来减低机会成本（也就是后悔）。&lt;/p>
&lt;p>极大极小原理解决的问题是玩家致力于防止最差的后果，想要避免错误决定导致的最坏结果。&lt;/p>
&lt;p>在数学上，极小极大算法是一个递归算法，用来在参与人数确定（通常是两个）的博弈中做出下一步的决定。&lt;/p>
&lt;p>极小极大也被应用于没有其他对手，但结果取决于不可预知事件情形下的决策。在这样的情形下，可能出现的结果与有两个参与者的零和博弈类似。&lt;/p>
&lt;h2 id="原理17-纳什均衡">&lt;a href="#%e5%8e%9f%e7%90%8617-%e7%ba%b3%e4%bb%80%e5%9d%87%e8%a1%a1" class="header-anchor">&lt;/a>原理17 纳什均衡
&lt;/h2>&lt;p>纳什认为，在任意一个混合策略博弈中有这样一个策略组合，在该策略组合上，任何参与人都有有限的选择；而当所有其他人都不改变策略的时候，没有人会改变自己的策略，因为改变策略会导致该博弈者得到的得益降低，那么这个策略组合就是一个纳什均衡。&lt;/p>
&lt;p>纳什均衡原理可用于预测博弈者在他们最优策略的基础上互动的结果。&lt;/p>
&lt;p>纳什均衡可以通过数学方法，基于回报矩阵（payoff matrix）得出。&lt;/p>
&lt;p>囚徒困境博弈&lt;/p>
&lt;p>假设有两个小偷A和B联合犯事、私入民宅被警察抓住。警方将两人分别置于不同的两个房间内进行审讯，对每一个犯罪嫌疑人，警方给出的政策是：如果一个犯罪嫌疑人坦白了罪行，交出了赃物，于是证据确凿，两人都被判有罪。如果另一个犯罪嫌疑人也作了坦白，则两人各被判刑8年；如果另一个犯罪嫌人没有坦白而是抵赖，则以妨碍公务罪（因已有证据表明其有罪）再加刑2年，而坦白者有功被减刑8年，立即释放。如果两人都抵赖，则警方因证据不足不能判两人的偷窃罪，但可以私入民宅的罪名将两人各判入狱1年。&lt;/p>
&lt;p>收益矩阵&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>A╲B&lt;/th>
&lt;th>坦白&lt;/th>
&lt;th>抵赖&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>坦白&lt;/td>
&lt;td>-8，-8&lt;/td>
&lt;td>0，-10&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>抵赖&lt;/td>
&lt;td>-10，0&lt;/td>
&lt;td>-1，-1&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>可以看出对于个人而言，坦白的收益总比抵赖要高。&lt;/p>
&lt;p>关于案例，显然最好的策略是双方都抵赖，结果是大家都只被判1年。但是由于两人处于隔离的情况，首先应该是从心理学的角度来看，当事双方都会怀疑对方会出卖自己以求自保、其次才是亚当·斯密的理论，假设每个人都是“理性的经济人”，都会从利己的目的出发进行选择。这两个人都会有这样一个盘算过程：假如他坦白，如果我抵赖，得坐10年监狱，如果我坦白最多才8年；假如他要是抵赖，如果我也抵赖，我就会被判一年，如果我坦白就可以被释放，而他会坐10年牢。综合以上几种情况考虑，不管他坦白与否，对我而言都是坦白了划算。两个人都会动这样的脑筋，最终，两个人都选择了坦白，结果都被判8年刑期。&lt;/p>
&lt;p>囚徒困境中，在都选择背叛时，任何一个人单独改变策略都不会使自己的收益更高，所以都背叛就是纳什均衡点。相反在都合作的情况下，任何单独的改变状态都会增加自己的收益，所以合作不是纳什均衡点。&lt;/p>
&lt;h2 id="原理18-帕累托最优">&lt;a href="#%e5%8e%9f%e7%90%8618-%e5%b8%95%e7%b4%af%e6%89%98%e6%9c%80%e4%bc%98" class="header-anchor">&lt;/a>原理18 帕累托最优
&lt;/h2>&lt;p>许多博弈论的例子都是零和命题——其中参与一方的收益来自于另一方的损失。然而，也有一些情况下，玩家可以在不影响其他玩家地位的情况下让自己的地位上升。意大利经济学家维尔弗雷多·帕累托（Vilfredo Pareto）在财富和收入分配等领域研究了这样的关系。人们以他的名字命名了他的发现。&lt;/p>
&lt;p>当有人得到了一定数量的货物、金钱、土地等，而且是从一个人手上转移到了另一个人手上（比如通过销售），这就是“帕累托交换”（Pareto shift）。&lt;/p>
&lt;p>如果一个交换过程在改进了系统中一个人的状态的情况下没有直接损害系统中其他人的利益，这个变化就是一个“帕累托改进”（Pareto improvement）。&lt;/p>
&lt;p>当一个角色扮演游戏（roleplaying games，RPG）中的角色升级自己的能力和技能时，这就是一个帕累托改进。另一方面，如果一个玩家偷了另一个玩家的装备，这就不是一个帕累托改进，因为这会让被偷的一方能力削弱。&lt;/p>
&lt;p>当一个系统达到了没有帕累托改进的余地的状态，它就达到了“帕累托最优”（Pareto optimality），又称“帕累托效率”（Pareto efficiency）。这时，系统中的任何一个交换都是零和的。&lt;/p>
&lt;p>帕累托最优的一个重要特性是它不一定是一个公平合理的分配，它也并不意味着这个分配是可能的分配方案中最好的。它只是说明当前的选择已经被扩展到了没有任何人可以在不损害其他人利益的情况下进行改善的地步。&lt;/p>
&lt;p>“占优策略”（参见原理84“占优策略”）并不总是与帕累托最优一致。在囚徒困境中，占优策略（也就是背叛）就跟帕累托最优（双方合作）不一致。这是因为双方“保持沉默”相当于一系列同步的帕累托改进——每人都在不使对方状况变差的情况下让自己的状况变好了。没有人能在不让对方变差的情况下让自己的状况变好（要让自己的状况变好只能背叛对方，也就意味着对方的状况变差）。&lt;/p>
&lt;p>在合作的游戏或系统中，帕累托最优是一个理想的目标。&lt;/p>
&lt;p>在竞争的游戏中如果达到了帕累托最优，则往往意味着僵局或不可避免的冲突。&lt;/p>
&lt;p>帕累托改进（及其最终带来的帕累托最优）在资源平衡的游戏机制中也经常被使用。达到帕累托最优并不意味着这就是最佳组合，只是表示所有的资源都被有效地使用了。&lt;/p>
&lt;h2 id="原理19-得益">&lt;a href="#%e5%8e%9f%e7%90%8619-%e5%be%97%e7%9b%8a" class="header-anchor">&lt;/a>原理19 得益
&lt;/h2>&lt;p>得益（Payoff）是指在游戏中一个决定所带来的产出或结果，不管是正面的还是负面的，不管它如何被计量。&lt;/p>
&lt;p>不是所有的玩家玩游戏都是出于追求同样的回报（巴特尔的玩家分类理论）。&lt;/p>
&lt;p>假定游戏中的所有玩家都是理性自利的，也就是说每个人的行为都以获得自己的最佳回报，并且将其最大化为目的，根据玩家自己的价值体系，每个决定对玩家带来的影响都是合理的。&lt;/p>
&lt;p>在博弈论中，得益可被分为基数的和序数的。&lt;/p>
&lt;p>基数得益（Cardinal Payoffs）是固定量的值。&lt;/p>
&lt;p>序数得益（Ordinal Payoffs）采用得益产生的顺序而不在于其数值的大小来描述结果。就像竞赛一样，排序名次比时间和距离更重要。&lt;/p>
&lt;p>当游戏是同步进行的，也就是说，当一个玩家必须在不知道其他玩家会怎么做的情况下采取行动时，通常会有一个正则形式的表格来显示得益，这样我们就可以比较游戏双方所做选择的结果。&lt;/p>
&lt;p>在平衡一个游戏的得益时需要注意的一点是：在决策过程中的理性自利（没有与其他玩家之间的可信承诺）通常会给玩家带来最坏的结果。&lt;/p>
&lt;p>在“囚徒困境”中，我们要注意尽管这个游戏看起来是基数得益的，它实质上却是序数得益的。因为唯一重要的一点是它们的顺序保持不变。&lt;/p>
&lt;h2 id="原理20-囚徒困境">&lt;a href="#%e5%8e%9f%e7%90%8620-%e5%9b%9a%e5%be%92%e5%9b%b0%e5%a2%83" class="header-anchor">&lt;/a>原理20 囚徒困境
&lt;/h2>&lt;p>囚徒困境（Prisoner’s Dilemma）是一个简单的博弈，它解释的是为什么两个博弈者在博弈时会分别作出不是对自己最有利的，却能通过合作达成一个更好结果的选择。&lt;/p>
&lt;p>博弈可以按照传统方式进行，如单一决策，或重复决策，产生基于过去结果的行为模式。&lt;/p>
&lt;blockquote>
&lt;p>如果两个博弈者连续完成了多次囚徒困境的情景，并基于对方之前的行为各自形成了一个对对方的看法，这两人都将开始基于对方的行为来规划自己的策略。连续玩N（N已知）次游戏时，最合理的决定是每一次都背叛对方。然而在实践中，大多数人都不会超理性到能够意识到对他们来说能得到最大利益的做法是：每一次都与对方合作，然后在最后一次背叛对方。假定他们会这么做，这也会让他们推断对方也与他们一样理性，也会做出同样的事情。于是他们在倒数第二轮选择背叛，如此循环往复，回到开头。而如果N是未知的，这个做法就不再是游戏的“占优策略”，而是一个“纳什均衡”。&lt;/p>&lt;/blockquote>
&lt;p>罗伯特·阿克塞尔罗德（Robert Axelrod）提出了博弈者的策略要获得成功的4 个必要条件。&lt;/p>
&lt;ul>
&lt;li>要友好（Nice）。不要首先背叛（尽可能的合作）。&lt;/li>
&lt;li>不嫉妒（Non-Envious）。不要试图比对方得到更多（优化平衡积分）。&lt;/li>
&lt;li>要报复（Retaliating）。当对方背叛你时一定要报复（不要永远合作）。&lt;/li>
&lt;li>要宽容（Forgiving）。报复之后要改回合作（如果对方不背叛你的话）。&lt;/li>
&lt;/ul>
&lt;p>威廉姆斯·普雷斯（William Press）和弗里曼·戴森（Freeman Dyson）提出了一个被称为“零行列式策略”（Zero-Determinant Strategy）的新方法，该方法认为一个博弈者可以通过让对方相信他们会做出某个特定选择的方式来控制博弈，该博弈者通过利用假信息来从对方那里获得好处。&lt;/p>
&lt;h2 id="原理21-解谜游戏的设计">&lt;a href="#%e5%8e%9f%e7%90%8621-%e8%a7%a3%e8%b0%9c%e6%b8%b8%e6%88%8f%e7%9a%84%e8%ae%be%e8%ae%a1" class="header-anchor">&lt;/a>原理21 解谜游戏的设计
&lt;/h2>&lt;p>设计师斯科特·金（Scott Kim）这样定义“谜题”（puzzle）：“有趣的东西，并且有一个正确的解答”。这个定义尽管模糊，却至少提出了一个定义谜题的有用元素：它是有解的。&lt;/p>
&lt;p>一个好的谜题对它的受众而言既不能太容易也不能太难。要让一个谜题游戏做到这一点，一个好的方式就是面包屑式（breadcrumbs）的引导。例如在数独（Sodoku）或纵横填字（crossword）游戏中，随着一个一个空格被填上，玩家也就得到了对剩下的空格更多的提示，那些剩下的空格也就变得越来越好填了。&lt;/p>
&lt;p>一个好的谜题应该需要一个聪明、智慧的解决方法，而不是通过简单的蛮力就能解决。&lt;/p>
&lt;p>一个谜题的产生可以是随机的，但当玩家开始解答它时，它必须是确定的。&lt;/p>
&lt;p>最后，一个好的谜题必须让玩家知道目标是什么，他们需要进行怎样的操作来达成这个目标。谜题”的设计师通过模糊化规则来增加解谜的难度，但是这样的谜题是不公平的。&lt;/p>
&lt;p>当我们设计一个谜题时，要确保：&lt;/p>
&lt;ul>
&lt;li>在难度上要让玩家保持在一个“心流”的状态&lt;/li>
&lt;li>需要一个聪明、智慧的解决方法&lt;/li>
&lt;li>是确定的&lt;/li>
&lt;li>从其目标和机制上来说是明确而公平的&lt;/li>
&lt;/ul>
&lt;h2 id="原理22-石头剪刀布">&lt;a href="#%e5%8e%9f%e7%90%8622-%e7%9f%b3%e5%a4%b4%e5%89%aa%e5%88%80%e5%b8%83" class="header-anchor">&lt;/a>原理22 石头剪刀布
&lt;/h2>&lt;p>石头剪刀布（Roshambo），是一种只需要通过手势参与的、同步的、半随机的，零和博弈。&lt;/p>
&lt;p>石头剪刀布可以通过算法对对手的行为模式及其发展趋势进行分析，基于马尔科夫链（Markov Chains）、战略预测和随机数的算法来选择应对的手势。&lt;/p>
&lt;p>这种循环的制约关系已被应用于其他游戏中，以防止占优策略的演进，保证游戏过程中各种类型的元素保持同等的价值。&lt;/p>
&lt;p>石头剪刀布有时也被一些不愿意去探索更有趣的、创新或独特的方法来平衡游戏机制的设计师当作偷懒的依托。如果石头剪刀布方式是我们针对功能设计的唯一策略，我们要小心了。&lt;/p>
&lt;h2 id="原理23-7种通用情感">&lt;a href="#%e5%8e%9f%e7%90%8623-7%e7%a7%8d%e9%80%9a%e7%94%a8%e6%83%85%e6%84%9f" class="header-anchor">&lt;/a>原理23 7种通用情感
&lt;/h2>&lt;p>游戏设计师往往致力于唤起玩家的情感，他们花费很大的精力去研究“兴趣曲线”，以及设法保持玩家对游戏的注意力。&lt;/p>
&lt;p>有7种通用的情感表达是世界的每一种文化公认的。&lt;/p>
&lt;ul>
&lt;li>惊讶（Surprise）&lt;/li>
&lt;li>轻蔑（Contempt）&lt;/li>
&lt;li>愤怒（Anger）&lt;/li>
&lt;li>喜悦（Joy）&lt;/li>
&lt;li>恐惧（Fear）&lt;/li>
&lt;li>悲伤（Sadness）&lt;/li>
&lt;li>厌恶（Disgust）&lt;/li>
&lt;/ul>
&lt;p>情感总是无意识的、稍纵即逝，但可以很容易地通过人们面部的变化看出来。这是情感和情绪的一个显著区别，后者持续的时间更长，并且可以被隐藏和掩饰。&lt;/p>
&lt;h2 id="原理24-斯金纳箱">&lt;a href="#%e5%8e%9f%e7%90%8624-%e6%96%af%e9%87%91%e7%ba%b3%e7%ae%b1" class="header-anchor">&lt;/a>原理24 斯金纳箱
&lt;/h2>&lt;p>预测玩家的行为是游戏设计师最基本的需求。其中一个被过分广泛使用的理论流派——行为主义。&lt;/p>
&lt;blockquote>
&lt;p>斯金纳做了如下尝试：&lt;/p>
&lt;p>老鼠每次按下杠杆，就给它食物作为奖励；&lt;/p>
&lt;p>老鼠每X次按下杠杆，就给它食物作为奖励；&lt;/p>
&lt;p>在老鼠每隔N分钟后第一次按下杠杆时给它奖励；&lt;/p>
&lt;p>当老鼠每第X（X是随机的）次按下杠杆时给它奖励；&lt;/p>
&lt;p>在老鼠每隔N（N是随机的）分钟后第一次按下杠杆时给它奖励。&lt;/p>
&lt;p>实验结果表明老鼠对几种不同的奖励周期有十分明确的回应方式。有一些奖励周期引起老鼠狂热地一次又一次按下杠杆，以期得到更多食物；有一些则相对温和，造成老鼠按杆的机会相对较少。&lt;/p>
&lt;p>如果要让老鼠尽可能多按杆，最好的奖励周期是以变化比率的形式，也就是使用随机变化的参数。在给老鼠加强“多按就会多得”印象的同时，又让它们摸不清楚到底按多少下才能得到食物。&lt;/p>&lt;/blockquote>
&lt;p>玩家与游戏的交互等同于价值，因此，最能引导玩家与游戏产生更多交互的方式就是以随机的周期给用户奖励。采访这些游戏的玩家会发现他们对这个游戏是否“好玩”抱有矛盾的意见，但却承认自己被吸引不停地玩。&lt;/p>
&lt;p>行为主义理论是可以被当作一个推动玩家参与的妙招的。&lt;/p>
&lt;blockquote>
&lt;p>有些孩子被要求每周末修剪草坪。对孩子来说有些院子太大了，而且他们从开头就害怕这个苦差事。在盛夏的日头下推割草机可不是他们爱干的事儿。但是他们随后就发现，这个工作越接近完成就变得越轻松，他们割完一行草的速度更快，他们也越来越为即将到手的5美元兴奋。&lt;/p>&lt;/blockquote>
&lt;p>这种现象被称为目标的梯度效应（goal-gradient effect）。&lt;/p>
&lt;p>如果玩家知道他将马上能得到奖励，他们会更有动力去完成能让他们得到这个奖励的任务。如果你发现你的玩家在游戏中的某一点逐渐失去他们的兴趣，或许这就是向他们展示他们如果继续下去将得到的奖励的最佳时机。&lt;/p>
&lt;h2 id="原理25-社会关系">&lt;a href="#%e5%8e%9f%e7%90%8625-%e7%a4%be%e4%bc%9a%e5%85%b3%e7%b3%bb" class="header-anchor">&lt;/a>原理25 社会关系
&lt;/h2>&lt;p>对大部分的玩家来说，游戏是一项群体活动，不管是棋盘游戏、卡牌游戏，还是视频游戏。&lt;/p>
&lt;p>这些社交性、合作性的游戏的发展证明在游戏设计中社会关系对增加玩家的兴趣、参与和满意度是非常有效的。&lt;/p>
&lt;p>大多数现代游戏要求设计师至少要考虑激活玩家的社会关系网络。&lt;/p>
&lt;p>邓巴数理论认为，任何一个人的社交网络大概由150个连接，也就是社会关系构成。它是指你能从你的社交网络中的每一个个体中得到的好处，包括互相帮助、互相访问，或通过其他手段帮助彼此。&lt;/p>
&lt;p>社交机制可以是主动的、被动的，也可以介于两者之间。&lt;/p>
&lt;p>有一个心理现象叫“害怕错过”，这是个体寻求能帮助他们被纳入团体的经验的一个很有说服力的理由。&lt;/p>
&lt;p>目标受众的偏好和他们的舒适区都会影响与社会关系相关的设计的一般方法。&lt;/p>
&lt;p>研究受众的喜好并巧妙地使用社交设计方法能够将游戏的复杂性和娱乐性提高一个层次，并最终帮助游戏从市场竞争中脱颖而出。&lt;/p>
&lt;h2 id="原理26-公地悲剧">&lt;a href="#%e5%8e%9f%e7%90%8626-%e5%85%ac%e5%9c%b0%e6%82%b2%e5%89%a7" class="header-anchor">&lt;/a>原理26 公地悲剧
&lt;/h2>&lt;p>公地悲剧（Tragedy of the Commons）的含义是，如果一项资源是可供所有人使用的，那么该资源最终一定会被耗尽，而这对所有人都是有害的，长期的损失远大于短期内获取该资源得到的好处。&lt;/p>
&lt;p>公地悲剧的假定条件是在有限的系统内对资源的使用是增长的。&lt;/p>
&lt;blockquote>
&lt;p>广义而言，公地悲剧表达了一个人艰难的选择：努力争取物质利益，并由此导致自己和他人的长期损失——寄希望于短期的物质利益能弥补长期损失——或者为了所有人的利益与大家合作来节约资源，但是这样做的风险是，如果有其他人有更好的个人资源，或者有其他人谎称合作实则过度使用公共资源，这个人就吃亏了。&lt;/p>&lt;/blockquote>
&lt;p>在游戏中，玩家的策略或游戏的机制都有可能导致公地悲剧。应该有某种协议（或一些特殊的规则来奖励使用资源较少的玩家）来预防玩家们用完所有可用资源。&lt;/p>
&lt;p>对于公地悲剧有两种常见的，并且是相反的解决方案，但是它们都不能理想地解决这个问题。&lt;/p>
&lt;p>资源平等的再分配（共产主义）意味着无法有效利用资源的人依然能得到它，这样有很大一部分被浪费掉或很快被用完。&lt;/p>
&lt;p>另一方面，垄断资源（政府控制）则意味着资源的利用效率远低于腐败、法律法规和特殊利益集团对资源的征用。&lt;/p>
&lt;p>向人们提供足够的资源被过度使用的信息来让他们意识到保护资源的重要，确保对社区的强烈归属感以减少自私的囤积行为和滥用集体财产，建立值得信赖的机构来管理关键资源的分配，以及对负责任的资源利用行为提供激励机制，并惩罚那些不负责任的过度使用行为。&lt;/p>
&lt;h2 id="原理27-信息透明">&lt;a href="#%e5%8e%9f%e7%90%8627-%e4%bf%a1%e6%81%af%e9%80%8f%e6%98%8e" class="header-anchor">&lt;/a>原理27 信息透明
&lt;/h2>&lt;p>许多游戏都是围绕着发现隐藏信息的过程而展开的。&lt;/p>
&lt;p>游戏理论将这些信息不透明的游戏归类为“不完全信息（imperfect information）游戏”。&lt;/p>
&lt;p>另一种信息——游戏状态，则在不完全信息游戏的分类下还有所细分。&lt;/p>
&lt;p>在不完全信息游戏中有一个子分类，这类游戏中玩家能够接触到关于游戏环境和规则的所有信息，但不能看到其他玩家的行动状态，这就是完整信息（complete information）的游戏。&lt;/p>
&lt;p>在不完全信息游戏中，那些玩家没有依据对未知进行假设的游戏就是不完整信息（incomplete information）的游戏。&lt;/p>
&lt;p>理解信息透明的概念对于游戏设计师（国内公司通常称为游戏策划）而言有多强大的最后一个关键是，记住信息透明可以是自愿的或非自愿的。&lt;/p>
&lt;p>游戏中有规则规定玩家有时必须向另一名玩家展示手中的一张牌，这张牌本来应该是保密的，这就是非自愿的信息透明。&lt;/p>
&lt;p>自愿信息透明，设立这样的规则通常是为了鼓励玩家虚张声势、双重间谍的行为，并且建立一个互相不信任的氛围。&lt;/p>
&lt;h2 id="原理28-范登伯格的大五人格游戏理论">&lt;a href="#%e5%8e%9f%e7%90%8628-%e8%8c%83%e7%99%bb%e4%bc%af%e6%a0%bc%e7%9a%84%e5%a4%a7%e4%ba%94%e4%ba%ba%e6%a0%bc%e6%b8%b8%e6%88%8f%e7%90%86%e8%ae%ba" class="header-anchor">&lt;/a>原理28 范登伯格的大五人格游戏理论
&lt;/h2>&lt;p>理解人们的心理是游戏设计的基础。在许多方面，游戏的功能性目标就是激发起玩家采取行动的意愿。&lt;/p>
&lt;p>大五理论认为人类的行为主要是由5类动机驱动的：&lt;/p>
&lt;ul>
&lt;li>对体验的开放性（Openness to Experience），这一点将那些有创造力、有想象力的人和那些更务实、更循规蹈矩的人区分开来&lt;/li>
&lt;li>尽责性（Conscientiousness），人如何控制和缓和自己的冲动情绪&lt;/li>
&lt;li>外倾性（Extraversion），这一点将那些追求刺激以及在他人面前的存在感的人，与那些不这么做的人区分开来&lt;/li>
&lt;li>随和性（Agreeableness），反应人如何处理与社会和谐的规则相关的问题&lt;/li>
&lt;li>神经质或情绪稳定性（Neuroticism），这反应了一个人是否选择经历（或不经历）负面情绪的倾向&lt;/li>
&lt;/ul>
&lt;p>每一类人格特质都能被细分为6个子维度，这描述了更加具体的内在驱动。&lt;/p>
&lt;p>“对体验的开放性”就包括以下几个子维度：&lt;/p>
&lt;ul>
&lt;li>想象力（Imagination），这将那些认为自己的内在精神世界比外部世界更有趣的人跟与他们相反的人区别开来&lt;/li>
&lt;li>艺术趣味（Artistic Interest），这关系到一个人如何体验美&lt;/li>
&lt;li>情绪性（Emotionality），这指示了一个人意识到自己内心情感状态的程度&lt;/li>
&lt;li>冒险性（Adventurousness），区分那些喜欢探索、寻求新事物的人和那些更喜欢已知和常规事物的人&lt;/li>
&lt;li>求知欲（Intellect），关于一个人从用他们自己的脑子解决谜题，或者参与进复杂的心理游戏这样的活动中能得到多少满足感&lt;/li>
&lt;li>自由主义（Liberalism），衡量一个人希望社会如何发展，是向未来推进、保持稳定不动、还是回到过去。&lt;/li>
&lt;/ul>
&lt;p>与想象力相关联的是玩家对幻想和写实的偏好。&lt;/p>
&lt;p>与冒险性相关联的是玩家是更喜欢将探索作为游戏机制的一部分。&lt;/p>
&lt;p>我们抱着同样的目的生活和游戏。&lt;/p>
&lt;p>我们希望在游戏中扮演别人的看法很普遍，但这是错误的。&lt;/p>
&lt;p>注：补充阅读《大五人格心理学》&lt;/p>
&lt;h2 id="原理29-志愿者困境">&lt;a href="#%e5%8e%9f%e7%90%8629-%e5%bf%97%e6%84%bf%e8%80%85%e5%9b%b0%e5%a2%83" class="header-anchor">&lt;/a>原理29 志愿者困境
&lt;/h2>&lt;p>“志愿者困境”（Volunteer’s dilemma）是群体博弈理论中的一个特殊例子，类似于“公地悲剧”。&lt;/p>
&lt;blockquote>
&lt;p>在志愿者困境中，一个人面临的选择是，是否牺牲自己的一小部分利益来让群体中的所有人受益，同时这个人自己不能得到任何额外的好处。而如果这个人不牺牲，并且也没有任何一个其他人这么做，则所有人都要面临严重的利益损害。当然，这个选择是，自己牺牲一小部分时间、经历、钱等等，或是承担等着其他人来做的风险。&lt;/p>&lt;/blockquote>
&lt;p>这些情况在互联网合作游戏中屡见不鲜。&lt;/p>
&lt;p>玩家可能会选择不参与一些危险的、但是对团队来说是必须的任务，而是去做更多对自己有好处的任务。他们会假设为了团队的生存和胜利，团队会去承担完成那些危险任务的责任。&lt;/p>
&lt;p>如果这个策略成功，他们会受到鼓励而继续这样的行为——并且可能会有更多的玩家选择这种对自己来说没有风险的做法——这样也就把越来越多的责任转嫁到了仍然愿意执行危险任务的团队成员身上。显然，如果这个趋势继续下去，整个团队（包括那些搭便车者）都会完蛋。&lt;/p>
&lt;h2 id="心得">&lt;a href="#%e5%bf%83%e5%be%97" class="header-anchor">&lt;/a>心得
&lt;/h2>&lt;p>书中所介绍游戏原理其实很多在目前主流游戏中都有所体现，而学习游戏原理的意义，在于自己不仅限于“感觉这个模块挺有意思，可以拿来借鉴一下”，而是能够根据原理去设计一个模块。&lt;/p>
&lt;p>成品是游戏原理的实际运用，游戏设计的“抄作业”也至少应该明白这道题的答案为何，这样才能在以后的设计中交出一个满意的答卷。&lt;/p></description></item><item><title>代码之髓：编程语言核心概念笔记</title><link>https://boiltask.com/notes/coreconcept/</link><pubDate>Mon, 11 Nov 2019 13:43:08 +0000</pubDate><guid>https://boiltask.com/notes/coreconcept/</guid><description>&lt;h2 id="第1章-如何深入高效地学习语言">&lt;a href="#%e7%ac%ac1%e7%ab%a0-%e5%a6%82%e4%bd%95%e6%b7%b1%e5%85%a5%e9%ab%98%e6%95%88%e5%9c%b0%e5%ad%a6%e4%b9%a0%e8%af%ad%e8%a8%80" class="header-anchor">&lt;/a>第1章 如何深入高效地学习语言
&lt;/h2>&lt;p>在比较中学习多种语言时，一些知识能理解得更深刻。所谓语言不同，规则不同。&lt;/p>
&lt;p>知道了语言设计者为解决何种问题而创造了这种语言，以及这种语言经历过怎么样的历史变迁后，慢慢地就能理解为什么需要有这种功能了。&lt;/p>
&lt;p>了解了语言的历史，我们往往更能加深所学。&lt;/p>
&lt;h2 id="第2章-程序设计语言诞生史">&lt;a href="#%e7%ac%ac2%e7%ab%a0-%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%e8%af%ad%e8%a8%80%e8%af%9e%e7%94%9f%e5%8f%b2" class="header-anchor">&lt;/a>第2章 程序设计语言诞生史
&lt;/h2>&lt;p>优秀的程序员具有三大美德： 懒惰、急躁和傲慢（Laziness, Impatience and Hubris）。&lt;/p>
&lt;p>“急躁”的意思是，程序员忍受不了程序执行的低效。&lt;/p>
&lt;p>“傲慢”的意思是，程序员容不得对错误不管不顾。&lt;/p>
&lt;p>“懒惰”的意思是，一项为了减少总能量支出，而不遗余力地努力的素质。&lt;/p>
&lt;p>程序设计语言是为了给人们带来便捷，但是何为便捷，语言不同，便捷的含义也各不相同。&lt;/p>
&lt;p>语言只是工具，要看通过使用它自己能做出多大成果，应当根据自己的实际情况选择好的工具。&lt;/p>
&lt;h2 id="第3章-语法的诞生">&lt;a href="#%e7%ac%ac3%e7%ab%a0-%e8%af%ad%e6%b3%95%e7%9a%84%e8%af%9e%e7%94%9f" class="header-anchor">&lt;/a>第3章 语法的诞生
&lt;/h2>&lt;p>语言设计者制定的规则就是语法。&lt;/p>
&lt;h2 id="第4章-程序的流程控制">&lt;a href="#%e7%ac%ac4%e7%ab%a0-%e7%a8%8b%e5%ba%8f%e7%9a%84%e6%b5%81%e7%a8%8b%e6%8e%a7%e5%88%b6" class="header-anchor">&lt;/a>第4章 程序的流程控制
&lt;/h2>&lt;p>在提倡规则让读写程序更轻松的时代潮流中，结构化程序设计应运而生。&lt;/p>
&lt;h2 id="第5章-函数">&lt;a href="#%e7%ac%ac5%e7%ab%a0-%e5%87%bd%e6%95%b0" class="header-anchor">&lt;/a>第5章 函数
&lt;/h2>&lt;p>函数，即把代码的一部分视作有机整体，然后切分出来并为之命名的程序设计机制。&lt;/p>
&lt;p>把相同的操作封装在一起的好处不仅仅在于使程序更简短，也在于能使阅读程序的人无需反复读取相同内容的源代码。从冗长的程序中切分出反复使用的代码将其封装成一个整体，程序就更容易理解了。&lt;/p>
&lt;h2 id="第6章-错误处理">&lt;a href="#%e7%ac%ac6%e7%ab%a0-%e9%94%99%e8%af%af%e5%a4%84%e7%90%86" class="header-anchor">&lt;/a>第6章 错误处理
&lt;/h2>&lt;p>程序在执行过程中也有可能出错，出错时如何处理（错误处理）很重要。错误处理的方法大体可分为两种：使用返回值和使用异常（异常处理）。&lt;/p>
&lt;p>为了提高软件的品质通过检查代码来确认程序员期待的程序行为，这一测评方法也是基于同样的想法。&lt;/p>
&lt;p>发生错误应该停止操作立刻报告，这一设计思想被称为错误优先（fail first）。&lt;/p>
&lt;h2 id="第7章-名字和作用域">&lt;a href="#%e7%ac%ac7%e7%ab%a0-%e5%90%8d%e5%ad%97%e5%92%8c%e4%bd%9c%e7%94%a8%e5%9f%9f" class="header-anchor">&lt;/a>第7章 名字和作用域
&lt;/h2>&lt;p>给内容或位置取个易于理解的名字，并用该名字来指示它们会更加方便。&lt;/p>
&lt;p>作用域是编写易于理解的代码的有力工具，很多地方都应用了这一概念。&lt;/p>
&lt;h2 id="第8章-类型">&lt;a href="#%e7%ac%ac8%e7%ab%a0-%e7%b1%bb%e5%9e%8b" class="header-anchor">&lt;/a>第8章 类型
&lt;/h2>&lt;p>类型是人们给数据附加的一种追加数据。&lt;/p>
&lt;p>需要有表示这个值为何种类型的额外的信息，这就是类型。&lt;/p>
&lt;h2 id="第9章-容器和字符串">&lt;a href="#%e7%ac%ac9%e7%ab%a0-%e5%ae%b9%e5%99%a8%e5%92%8c%e5%ad%97%e7%ac%a6%e4%b8%b2" class="header-anchor">&lt;/a>第9章 容器和字符串
&lt;/h2>&lt;p>在不同的语言中，容器的名称不同，性质各异。&lt;/p>
&lt;p>根据容器的使用目的、使用方式和操作类型的不同，最适宜的容器类型也会相应地变化。&lt;/p>
&lt;p>这个地球不是单靠程序员运转的，现实中还有很多不依赖于程序实现方式的解决方案。&lt;/p>
&lt;h2 id="第10章-并发处理">&lt;a href="#%e7%ac%ac10%e7%ab%a0-%e5%b9%b6%e5%8f%91%e5%a4%84%e7%90%86" class="header-anchor">&lt;/a>第10章 并发处理
&lt;/h2>&lt;p>为了实现便利的并发处理，出现了进程和线程的概念。&lt;/p>
&lt;p>执行处理用的线路（CPU）只有一个，在人们察觉不到的极短间隔内交替进行多项处理，尽管在某一瞬间实际只进行一项处理，但人们会觉得似乎有多项处理在同时进行。&lt;/p>
&lt;p>在合适的节点自发进行交替，利用这种方法实现的多任务（并发处理）称为协作式多任务模式。有一个问题，有可能某个处理一直找不到合适的节点进行任务切换从而持续地进行，导致其他处理无法等到执行的机会。&lt;/p>
&lt;p>隔一定时间就进行交替，任务管理器在一定时间后强制中断现在正在进行的处理，以便允许其他程序执行。&lt;/p>
&lt;p>并行执行的两个处理之间出现竞态条件必须同时满足以下三个条件。&lt;/p>
&lt;ul>
&lt;li>两个处理共享变量&lt;/li>
&lt;li>至少一个处理会对变量进行修改&lt;/li>
&lt;li>一个处理未完成之前另一个处理有可能介入进来&lt;/li>
&lt;/ul>
&lt;p>人们在共享→非共享→共享、协调→非协调→协调、硬件→软件→硬件这样两种对立观念中左右摇摆，不单看片面而是兼顾两面，在平衡中灵活运用或许才是最为重要的。&lt;/p>
&lt;h2 id="第11章-对象与类">&lt;a href="#%e7%ac%ac11%e7%ab%a0-%e5%af%b9%e8%b1%a1%e4%b8%8e%e7%b1%bb" class="header-anchor">&lt;/a>第11章 对象与类
&lt;/h2>&lt;p>在不同语言中，同一个用语的含义可能会有很大差别。&lt;/p>
&lt;p>在 C++ 语言里，类被定义为是“用户可自定义的类型”。&lt;/p>
&lt;p>类的存在只不过是因为人们觉得有了它编写程序会更方便些，而约定的一种事项。&lt;/p>
&lt;p>C++ 语言和 Java 语言的类具有以下几个作用：&lt;/p>
&lt;ul>
&lt;li>整合体的生成器&lt;/li>
&lt;li>可行操作的功能说明&lt;/li>
&lt;li>代码再利用的单位&lt;/li>
&lt;/ul>
&lt;h2 id="第12章-继承与代码再利用">&lt;a href="#%e7%ac%ac12%e7%ab%a0-%e7%bb%a7%e6%89%bf%e4%b8%8e%e4%bb%a3%e7%a0%81%e5%86%8d%e5%88%a9%e7%94%a8" class="header-anchor">&lt;/a>第12章 继承与代码再利用
&lt;/h2>&lt;p>继承的实现策略大体可以分为三种。&lt;/p>
&lt;ul>
&lt;li>一般化与专门化&lt;/li>
&lt;li>共享部分的提取&lt;/li>
&lt;li>差异实现&lt;/li>
&lt;/ul>
&lt;p>一般化与专门化，在父类中实现那些一般化的功能，在子类中实现那些专门的个性化的功能&lt;/p>
&lt;p>共享部分的提取，从多个类中提取出共享部分作为父类，子类并否为父类的一种。&lt;/p>
&lt;p>差异实现，继承之后仅实现有变更的那些属性会带来效率的提高。它把继承作为实现方式再利用的途径，旨在使编程实现更加轻松。这些情况下通常子类都不是父类的一种。&lt;/p>
&lt;p>使用方法多意味着继承这种机制有很高的自由度。&lt;/p>
&lt;p>影响范围越广，就越难确定这种修改会不会带来什么问题。这个问题不是单靠在程序设计上下工夫就能解决的，同时也可以把大量的检查工作交给计算机去完成来帮助解决，这叫回归测试。&lt;/p>
&lt;p>里氏置换原则可以表述为：假设对于 T 类型的对象 x，属性 q(x) 恒为真。如果 S 为 T 的派生类，那么 S 类型的对象 y 的属性 q(y) 也必须恒为真。&lt;/p>
&lt;p>对于类 T 的对象一定成立的条件，对于类 T 的子类 S 的对象也必须成立。&lt;/p>
&lt;p>&lt;img src="https://boiltask.com/notes/coreconcept/image-1.webp"
width="566"
height="229"
srcset="https://boiltask.com/notes/coreconcept/image-1_hu_1feb44ceb5c4e49a.webp 480w, https://boiltask.com/notes/coreconcept/image-1_hu_4244ff74daff1169.webp 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="247"
data-flex-basis="593px"
>&lt;/p>
&lt;p>当要继承某种类时，需要考虑该类是否可以被继承。&lt;/p>
&lt;p>多重继承对于实现方式再利用是一种非常便利的方法。&lt;/p>
&lt;p>&lt;img src="https://boiltask.com/notes/coreconcept/image-2.webp"
width="566"
height="343"
srcset="https://boiltask.com/notes/coreconcept/image-2_hu_40d6a8e9f688f656.webp 480w, https://boiltask.com/notes/coreconcept/image-2_hu_878722e7d54cf340.webp 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="165"
data-flex-basis="396px"
>&lt;/p>
&lt;p>类具有两种截然相反的作用。一种是用于创建实例的作用，它要求类是全面的、包含所有必需的内容的、大的类。另一种是作为再利用单元的作用，它要求类是按功能分的、没有多余内容的、小的类。&lt;/p>
&lt;h2 id="后记">&lt;a href="#%e5%90%8e%e8%ae%b0" class="header-anchor">&lt;/a>后记
&lt;/h2>&lt;p>只要是编程，大概都不可避免要产生一些错误（bug）。为了使程序准确运行，就需要调试（debug）。&lt;/p>
&lt;p>我们很容易更加关注 How 的问题（即如何去实现），实际上，What（要实现什么）和 Why（为什么要实现）的问题也是不可忽略的。&lt;/p>
&lt;h2 id="专栏">&lt;a href="#%e4%b8%93%e6%a0%8f" class="header-anchor">&lt;/a>专栏
&lt;/h2>&lt;h3 id="要确认理解是否正确首先得表达出来">&lt;a href="#%e8%a6%81%e7%a1%ae%e8%ae%a4%e7%90%86%e8%a7%a3%e6%98%af%e5%90%a6%e6%ad%a3%e7%a1%ae%e9%a6%96%e5%85%88%e5%be%97%e8%a1%a8%e8%be%be%e5%87%ba%e6%9d%a5" class="header-anchor">&lt;/a>要确认理解是否正确，首先得表达出来
&lt;/h3>&lt;p>为了验证理解正确与否，需要表达出来。只能基于自己的理解说出自己的观点，然后让第三方来判断和检验。&lt;/p>
&lt;p>程序员一直受益于这一点。只有理解了这一点，才能和语言处理器打交道。&lt;/p>
&lt;h3 id="当你不知道该学习什么时">&lt;a href="#%e5%bd%93%e4%bd%a0%e4%b8%8d%e7%9f%a5%e9%81%93%e8%af%a5%e5%ad%a6%e4%b9%a0%e4%bb%80%e4%b9%88%e6%97%b6" class="header-anchor">&lt;/a>当你不知道该学习什么时
&lt;/h3>&lt;p>自己到底想做什么，然后再去学习能够达成这一目标的知识。&lt;/p>
&lt;h3 id="具体的知识和抽象的知识">&lt;a href="#%e5%85%b7%e4%bd%93%e7%9a%84%e7%9f%a5%e8%af%86%e5%92%8c%e6%8a%bd%e8%b1%a1%e7%9a%84%e7%9f%a5%e8%af%86" class="header-anchor">&lt;/a>具体的知识和抽象的知识
&lt;/h3>&lt;p>我们不仅要学习具体的知识，更要有意识地去学习那些应用范围广泛的抽象的概念。&lt;/p>
&lt;h3 id="学习讲求细嚼慢咽">&lt;a href="#%e5%ad%a6%e4%b9%a0%e8%ae%b2%e6%b1%82%e7%bb%86%e5%9a%bc%e6%85%a2%e5%92%bd" class="header-anchor">&lt;/a>学习讲求细嚼慢咽
&lt;/h3>&lt;p>在庞大信息量面前心力交瘁的时候有三种战略可供参考：从需要的地方开始阅读，先掌握概要再阅读细节，从头开始逐章手抄。&lt;/p>
&lt;h4 id="从需要的地方开始阅读">&lt;a href="#%e4%bb%8e%e9%9c%80%e8%a6%81%e7%9a%84%e5%9c%b0%e6%96%b9%e5%bc%80%e5%a7%8b%e9%98%85%e8%af%bb" class="header-anchor">&lt;/a>从需要的地方开始阅读
&lt;/h4>&lt;p>明确阅读的目的并弄清楚为达成这一目的需要阅读哪些地方，就可以有针对性地阅读，无需在其他无关的地方花费大量精力。&lt;/p>
&lt;h4 id="先掌握概要再阅读细节">&lt;a href="#%e5%85%88%e6%8e%8c%e6%8f%a1%e6%a6%82%e8%a6%81%e5%86%8d%e9%98%85%e8%af%bb%e7%bb%86%e8%8a%82" class="header-anchor">&lt;/a>先掌握概要再阅读细节
&lt;/h4>&lt;p>要先掌握概要再渐进式地追求细节，这是大的原则。&lt;/p>
&lt;h4 id="从头开始逐章手抄">&lt;a href="#%e4%bb%8e%e5%a4%b4%e5%bc%80%e5%a7%8b%e9%80%90%e7%ab%a0%e6%89%8b%e6%8a%84" class="header-anchor">&lt;/a>从头开始逐章手抄
&lt;/h4>&lt;p>当没有明确要做的事情或者想要了解的东西时，当简单浏览的内容过目即忘时，以这种学习状态，不管怎么学也无法获得真知。&lt;/p></description></item><item><title>游戏设计的100个原理笔记(1) – 第1篇 游戏创新的一般原理（上）</title><link>https://boiltask.com/notes/100principles-1/</link><pubDate>Sat, 09 Nov 2019 15:50:57 +0000</pubDate><guid>https://boiltask.com/notes/100principles-1/</guid><description>&lt;h2 id="原理1-游戏的对称性非对称性和同步性">&lt;a href="#%e5%8e%9f%e7%90%861-%e6%b8%b8%e6%88%8f%e7%9a%84%e5%af%b9%e7%a7%b0%e6%80%a7%e9%9d%9e%e5%af%b9%e7%a7%b0%e6%80%a7%e5%92%8c%e5%90%8c%e6%ad%a5%e6%80%a7" class="header-anchor">&lt;/a>原理1 游戏的对称性/非对称性和同步性
&lt;/h2>&lt;p>在对称性游戏（Symmetric gameplay）中，参与游戏的玩家的体验完全一样。&lt;/p>
&lt;p>在非对称性游戏（Asymmetric gameplay）中，参与游戏的玩家的体验并不完全一样。&lt;/p>
&lt;p>游戏中的延迟也会导致玩家看到的画面有不同，这种意外产生的信息不对称可能会产生这样的后果，这便涉及到同步性（synchronicity）问题 。同步的游戏是指在游戏过程中参与的双方同时发动自己的动作。&lt;/p>
&lt;h2 id="原理2-a最大鬼万能">&lt;a href="#%e5%8e%9f%e7%90%862-a%e6%9c%80%e5%a4%a7%e9%ac%bc%e4%b8%87%e8%83%bd" class="header-anchor">&lt;/a>原理2 A最大，鬼万能
&lt;/h2>&lt;p>通过在游戏中途改变定义的大小顺序，或是要求玩家根据自己或团队的目标来重新定义一张最大的牌。这样无需重新洗牌（重新分配资源），便可以改变特定结果。这就给游戏引入了多样性和惊喜，避免了过多的重复。&lt;/p>
&lt;p>改变某张牌的价值，总而组成一个更强力的牌组则为游戏增添了更多的复杂性。（赖子机制）&lt;/p>
&lt;h2 id="原理3-巴特尔的玩家分类理论">&lt;a href="#%e5%8e%9f%e7%90%863-%e5%b7%b4%e7%89%b9%e5%b0%94%e7%9a%84%e7%8e%a9%e5%ae%b6%e5%88%86%e7%b1%bb%e7%90%86%e8%ae%ba" class="header-anchor">&lt;/a>原理3 巴特尔的玩家分类理论
&lt;/h2>&lt;p>理查德·巴特尔 将MUD（ Multi-User Dimension）玩家分为四个基本类型： 成就型玩家 、 探险型玩家 、 社交型玩家 、 杀手型玩家 。&lt;/p>
&lt;p>&lt;img src="https://boiltask.com/notes/100principles-1/image-1.webp"
width="672"
height="305"
srcset="https://boiltask.com/notes/100principles-1/image-1_hu_add1b1bc4c2bda85.webp 480w, https://boiltask.com/notes/100principles-1/image-1_hu_8888d8db33341dc4.webp 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="220"
data-flex-basis="528px"
>&lt;/p>
&lt;p>其用两条轴线分出的4个象限来分析这4种不同的玩家。&lt;/p>
&lt;p>&lt;img src="https://boiltask.com/notes/100principles-1/image-2.webp"
width="357"
height="274"
srcset="https://boiltask.com/notes/100principles-1/image-2_hu_30ae277eff782fcd.webp 480w, https://boiltask.com/notes/100principles-1/image-2_hu_5e4648105efe9b43.webp 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="130"
data-flex-basis="312px"
>&lt;/p>
&lt;h2 id="原理4-合作与对抗">&lt;a href="#%e5%8e%9f%e7%90%864-%e5%90%88%e4%bd%9c%e4%b8%8e%e5%af%b9%e6%8a%97" class="header-anchor">&lt;/a>原理4 合作与对抗
&lt;/h2>&lt;p>当与超过一个玩家一起玩游戏时，有两种可能的玩家类型：合作型和对抗型。&lt;/p>
&lt;p>在合作型的游戏中（co-op play），两个或多个玩家共享一个目标，并且通过共同努力去实现这个目标。 合作游戏通常是两个或两个以上玩家与人工智能选手的对抗。玩家可以交易物品，相互治疗，使用互补的游戏战略（如主战坦克与远程武器的联手使用），或更为动态的方式（如相互给予身体上的增强互补）以通过单个玩家靠自身能力无法通过的障碍物。&lt;/p>
&lt;p>对抗型游戏的概念很简单：一个或一组玩家与另一个（或一组）对抗去取得胜利。通常对抗的玩家中只有一个（或一组）能获胜，除非这个游戏能以平局结束。对抗性的竞争是很多多人游戏的核心，而也有很多单人游戏以之前的最高分为对抗对象。&lt;/p>
&lt;p>个别游戏机制和功能可能会起到鼓励或阻止玩家之间的合作或对抗的作用，有时候会是以意想不到的方式产生作用。&lt;/p>
&lt;h2 id="原理5-公平">&lt;a href="#%e5%8e%9f%e7%90%865-%e5%85%ac%e5%b9%b3" class="header-anchor">&lt;/a>原理5 公平
&lt;/h2>&lt;p>当游戏设计中的公平性也是一样——游戏对于玩家必须是公平的。换句话说，游戏必须不偏不倚，不对玩家作弊。（注：与人工智能相关理论中的思路辩证地去看待，换句话说，作弊也必须是为了使玩家获得更佳的反馈。）&lt;/p>
&lt;p>当玩家觉得游戏给了他们不公平的对待时，他们有可能会退出游戏。当玩家觉得其他玩家给了他们不公平的对待时，他们有可能会去惩罚其他玩家。在创建一个玩家会对公平性有要求的系统时记得考虑这个问题。&lt;/p>
&lt;p>在俄罗斯方块游戏中，玩家经常会将游戏中的随机行为看作是不随机的，他们认为游戏是故意给他们不想要的方块。事实上俄罗斯方块中方块的掉落确实是完全随机的，但是玩家会感觉有背后的行为模式，并把这些归咎于想象中的不公平。&lt;/p>
&lt;p>类似地，如果一个游戏的难度在逐步提高的过程中突然出现一个大的飞跃，会被玩家认为不公平——事实上这也确实不公平。游戏的难度应该平稳地逐渐上升，这样玩家才不会觉得被欺骗或受到不公正的待遇。&lt;/p>
&lt;p>第一，对于那些友好的人们，其他人愿意牺牲他们自己的物质利益。也就是说，如果在一个游戏中玩家们表现友好，那么一个独立的玩家会更容易表现出利他行为或是愿意为友好的玩家们牺牲一些自己的物质利益。&lt;/p>
&lt;p>第二，基本上可以认为是第一条的反面——玩家将会愿意损失自己的物质利益去惩罚那些不友好的玩家。如果一个玩家有意对其他玩家不友好，另一位玩家为了让他受到惩罚，将宁愿在一定程度上损失自己的物质利益。&lt;/p>
&lt;p>最后，第三条规则是，第一和第二条规则在物质损失越小的情况下越容易发生。换句话说，玩家需要放弃的物质利益越小，他们越容易参与到前面提到的那些利他或是惩罚行为中去。&lt;/p>
&lt;h2 id="原理6-反馈循环">&lt;a href="#%e5%8e%9f%e7%90%866-%e5%8f%8d%e9%a6%88%e5%be%aa%e7%8e%af" class="header-anchor">&lt;/a>原理6 反馈循环
&lt;/h2>&lt;p>反馈循环有两种不同的类型。&lt;/p>
&lt;p>在一个正反馈循环中，达成一个目标能够获得奖励，而这让继续达成目标变得更容易。反馈循环的另一种形式是负反馈循环。其中达成一个目标会让下一个目标更难达成。 解决负反馈循环的难题其实很容易：为玩家完成游戏的目标提供奖励 。 我们可以考虑将正反馈和负反馈配合起来，或者是找到一个对玩家的实力不造成真正影响的奖励方式，比如新的皮肤或者动画效果之类装饰性的奖励。&lt;/p>
&lt;h2 id="原理7-加德纳的多元智能理论">&lt;a href="#%e5%8e%9f%e7%90%867-%e5%8a%a0%e5%be%b7%e7%ba%b3%e7%9a%84%e5%a4%9a%e5%85%83%e6%99%ba%e8%83%bd%e7%90%86%e8%ae%ba" class="header-anchor">&lt;/a>原理7 加德纳的多元智能理论
&lt;/h2>&lt;p>霍华德·加德纳（Howard Gardner）提出了多元智能理论，该理论认为，作为个体，我们每一个人在认知方式上都各有长处和短处。&lt;/p>
&lt;p>数理逻辑认知：通过批判性思维和逻辑来认知的过程，有时也被含糊地称为左脑学习。&lt;/p>
&lt;p>空间认知：通过想象将物体在空间中的情形视觉化来认知的过程。&lt;/p>
&lt;p>语言认知：以听觉或书面的方式，通过文字来认知的过程。&lt;/p>
&lt;p>身体-运动认知：通过身体或者周围的物理世界的移动来认知的过程。&lt;/p>
&lt;p>通过身体或者周围的物理世界的移动来认知的过程。这些人如果能站起来，走动走动，或者与他们正在学习的东西有身体上的接触，就能学得更好。&lt;/p>
&lt;p>音乐认知：通过各种和音乐有关的东西，包括音调、旋律、节奏和音色来认知的过程。&lt;/p>
&lt;p>通过各种和音乐有关的东西，包括音调、旋律、节奏和音色来认知的过程。这种类型的人能从童谣或任何以音乐形式呈现的东西中学习。&lt;/p>
&lt;p>人际交往认知：在与其他人的互动中来认知的过程。&lt;/p>
&lt;p>在与其他人的互动中来认知的过程。这类人可能非常有爱心或者是一位交际花。&lt;/p>
&lt;p>内省认知：自我反省和认知的过程。&lt;/p>
&lt;p>自我反省和认知的过程。这类人通常都很安静，一直从自己的内心寻找答案。&lt;/p>
&lt;p>自然探索认知：从周围相关的自然环境中认知的过程。&lt;/p>
&lt;p>如果设计师在设计游戏时考虑到这些不同的智能，他们可以让游戏适应无限多的玩家。&lt;/p>
&lt;h2 id="原理8-霍华德的隐匿性游戏设计法则">&lt;a href="#%e5%8e%9f%e7%90%868-%e9%9c%8d%e5%8d%8e%e5%be%b7%e7%9a%84%e9%9a%90%e5%8c%bf%e6%80%a7%e6%b8%b8%e6%88%8f%e8%ae%be%e8%ae%a1%e6%b3%95%e5%88%99" class="header-anchor">&lt;/a>原理8 霍华德的隐匿性游戏设计法则
&lt;/h2>&lt;p>霍华德的隐匿性游戏设计法则（Howard’s Law of Occult Game Design，隐匿性游戏设计法则，或称霍华德法则）可以用以下公式来表示：秘密的重要性其表面看来的无辜性完整度&lt;/p>
$$
秘密的重要性 \propto 其表面看来的无辜性 \times 完整度
$$$$
Secret Significance \propto Seeming Innocence \times Completeness
$$&lt;p>秘密的重要性，是与其表面上看起来无辜的程度及其完整度直接成比例的。&lt;/p>
&lt;h2 id="原理9-信息">&lt;a href="#%e5%8e%9f%e7%90%869-%e4%bf%a1%e6%81%af" class="header-anchor">&lt;/a>原理9 信息
&lt;/h2>&lt;p>在一个游戏中的任何一个点上，玩家能接触到的信息数量和性质可以极大地改变其决定。&lt;/p>
&lt;p>和游戏相关的信息可以采取不同的形式以及分类呈现。&lt;/p>
&lt;h3 id="游戏的结构">&lt;a href="#%e6%b8%b8%e6%88%8f%e7%9a%84%e7%bb%93%e6%9e%84" class="header-anchor">&lt;/a>游戏的结构
&lt;/h3>&lt;p>所有信息的类别中最首要的一个是游戏的结构，包括游戏的设定和规则。游戏环境本身也应该被视为信息。 如果一个游戏中的随机元素被作为参数而不是一个固定值来考虑，它也是一条明确的信息。&lt;/p>
&lt;h3 id="游戏的状态">&lt;a href="#%e6%b8%b8%e6%88%8f%e7%9a%84%e7%8a%b6%e6%80%81" class="header-anchor">&lt;/a>游戏的状态
&lt;/h3>&lt;p>这类信息包括单位元素所处的位置、分数、资源的情况等。而它的含义比单个元素在地理上被放置在哪里这一点要更广泛一些。&lt;/p>
&lt;h3 id="信息的利用">&lt;a href="#%e4%bf%a1%e6%81%af%e7%9a%84%e5%88%a9%e7%94%a8" class="header-anchor">&lt;/a>信息的利用
&lt;/h3>&lt;p>每个游戏利用这些原则的方式都不一样，但是一般的分类和分级对描述游戏设计师是如何处理这些信息是有帮助的。&lt;/p>
&lt;p>“完全信息”是游戏中一种最基本和限制最少的信息传达方式。在“完全信息”的环境下，所有的玩家都知道关于游戏的每一件事——环境，规则，当前位置，所有物品的状态，以及当前的游戏阶段。&lt;/p>
&lt;p>与“完全信息游戏”相对的，如果在游戏中一部分信息对某一个或更多的玩家是隐藏的，那么这个游戏是“不完全信息游戏”。&lt;/p>
&lt;h2 id="原理10-科斯特的游戏理论">&lt;a href="#%e5%8e%9f%e7%90%8610-%e7%a7%91%e6%96%af%e7%89%b9%e7%9a%84%e6%b8%b8%e6%88%8f%e7%90%86%e8%ae%ba" class="header-anchor">&lt;/a>原理10 科斯特的游戏理论
&lt;/h2>&lt;p>《游戏设计快乐之道》：所有游戏其实是低风险的学习工具，要让每一个游戏在某种程度上都是寓教于乐的。 这种“快乐”来源于“超游戏思维” 。&lt;/p>
&lt;p>如何在游戏设计中用到“组块化”，“组块化”是一个将复杂的任务分解成我们能够下意识地完成事情的过程。&lt;/p>
&lt;p>在我们的体验中，我们在一个不断变化的过程中参与并接受挑战就是“快乐”，特别是在学习中。&lt;/p>
&lt;h2 id="原理11-拉扎罗的4种关键趣味元素">&lt;a href="#%e5%8e%9f%e7%90%8611-%e6%8b%89%e6%89%8e%e7%bd%97%e7%9a%844%e7%a7%8d%e5%85%b3%e9%94%ae%e8%b6%a3%e5%91%b3%e5%85%83%e7%b4%a0" class="header-anchor">&lt;/a>原理11 拉扎罗的4种关键趣味元素
&lt;/h2>&lt;p>拉扎罗（Lazzaro）的4种关键趣味元素是一个设计工具，它能在游戏设计师设计新的游戏机制时激发其灵感，研究人员也能利用它来检验这些游戏机制的效果。&lt;/p>
&lt;p>简单趣味：玩家对一种新的体验感到好奇，他被带入到这种体验中去并且开始上瘾。&lt;/p>
&lt;p>困难趣味：游戏提供了一个可供追求的目标，并将其分解成一个一个可以达成的步骤。&lt;/p>
&lt;p>他人趣味：竞争、合作、沟通和领导结合在一起，增加参与度。“他人趣味”带来的情绪上的感受比其他3种加起来还要多。&lt;/p>
&lt;p>严肃趣味：玩家通过游戏来改变他们自己和他们的世界。游戏是一种对他们价值观的表达，而不是在浪费时间。&lt;/p>
&lt;p>最畅销的游戏通常能同时满足这4种趣味元素中的至少3个。游戏玩家对这4种趣味元素都喜欢，尽管在这其中他们有自己偏好。&lt;/p>
&lt;p>“简单趣味”是一个吸引好奇的玩家的并且促使他们加入游戏的诱饵。&lt;/p>
&lt;p>在某个时候，当这些新奇的感觉不再能持续获取玩家的关注时，他们会去寻找一些具体的事情来完成。“困难趣味”就是通过游戏困难度和玩家技巧间的平衡来做到让他们在经历挫折之后从史诗般的胜利中感受到“自豪” 。&lt;/p>
&lt;p>当与朋友在一起时，胜利的快感会让人感觉更好。围绕着游戏展开的社交互动能创造娱乐效果和社交纽带。&lt;/p>
&lt;h2 id="原理12-魔法圈">&lt;a href="#%e5%8e%9f%e7%90%8612-%e9%ad%94%e6%b3%95%e5%9c%88" class="header-anchor">&lt;/a>原理12 魔法圈
&lt;/h2>&lt;p>游戏的一大特点是它是一种幻想（这是关于游戏的定义中一个主要的部分）。我们固有的假设是，游戏是一种独立于真实世界的存在。&lt;/p>
&lt;p>当“这只是一个游戏”不再只是一个游戏，魔法圈的界限就被丢诸脑后了。&lt;/p>
&lt;h2 id="原理13-采取行动">&lt;a href="#%e5%8e%9f%e7%90%8613-%e9%87%87%e5%8f%96%e8%a1%8c%e5%8a%a8" class="header-anchor">&lt;/a>原理13 采取行动
&lt;/h2>&lt;p>游戏中的博弈，依据博弈各方做决定或采取行动的先后关系，可以被区分为“同步博弈”（Simultaneous game）或“序贯博弈”（Sequential game）。&lt;/p>
&lt;p>在同步博弈中，每个玩家同时也知道博弈中的每个人都面临着同样的问题。关键的信息对于博弈者在做自己每一步的决策时并不可见 （自己行动的时候不知道对方此刻的行动）。在序贯博弈中，每个博弈者能得到更多的信息。他们能通过其他人刚刚采取的行动，对其下一步行动进行可靠的预测（体现在自己行动的时候可以知道对方已有的行动）。&lt;/p>
&lt;p>同步博弈有可能是在时间上真正同步进行的，比如“石头剪刀布”；也有可能不是，博弈者各自在不同的时间进行自己的行动，只是他们在采取自己的行动时不知道其他博弈者的决策。&lt;/p>
&lt;p>序贯博弈要求博弈各方每一步都要轮流做出决策，同时他们对于其他人之前做出的决定至少是部分知情的。&lt;/p>
&lt;h2 id="原理14-mda游戏的机制运行和体验">&lt;a href="#%e5%8e%9f%e7%90%8614-mda%e6%b8%b8%e6%88%8f%e7%9a%84%e6%9c%ba%e5%88%b6%e8%bf%90%e8%a1%8c%e5%92%8c%e4%bd%93%e9%aa%8c" class="header-anchor">&lt;/a>原理14 MDA：游戏的机制、运行和体验
&lt;/h2>&lt;p>游戏的机制、运行和体验（Mechanics，Dynamics，and Aesthetics，MDA）是一个系统化的分析和理解游戏的方法。&lt;/p>
&lt;p>游戏机制是整个系统的规则。它定义了这个系统如何处理玩家的输入，以及玩家能看到什么和做什么。&lt;/p>
&lt;p>游戏的运行讲的是在玩游戏的过程中整个系统的各个参与者的行为。游戏的运行是对游戏机制在真正运行时效果的展现。&lt;/p>
&lt;p>游戏的体验是在游戏运行的影响下玩家的情感输出。&lt;/p>
&lt;p>我们有两种不同的方式来实践MDA。&lt;/p>
&lt;p>第一种方式，游戏设计师以定义在游戏中想要达到的体验效果作为设计流程的开始，然后确定要达到这样的体验效果玩家需要参与什么样的游戏运行过程，最终再为这样的运行过程设置游戏的机制。&lt;/p>
&lt;p>第二种方式，玩家反向体验MDA的3个要素并且首先与游戏机制进行互动，这些机制会带来特定的游戏运行，而这又将让玩家产生特定的体验。&lt;/p>
&lt;p>MDA只是在游戏中达到创造特定情绪反应效果的一个方法，它有它的局限性。&lt;/p></description></item><item><title>算法竞赛入门经典(8) – 关于for循环中定义变量的后续讨论</title><link>https://boiltask.com/notes/competitive-programming/8/</link><pubDate>Tue, 12 Jan 2016 14:32:38 +0800</pubDate><guid>https://boiltask.com/notes/competitive-programming/8/</guid><description>&lt;p>想想除了看书时之外&lt;br>
有时也会幸运地有点想法&lt;br>
所以再开一个类别来记录吧~&lt;br>
在下希望这个分类下的博文越多越好 -.-&lt;/p>
&lt;div class="dida-hr">
&lt;div>中午记录&lt;/div>
&lt;/div>
&lt;p>晚上有场个人赛&lt;br>
感觉略紧张啊……&lt;br>
万一爆零肿么办 -_-&lt;br>
感觉晚上还会来编辑一次&lt;br>
先立个flag&lt;/p>
&lt;h2 id="关于for循环中定义变量的后续讨论">&lt;a href="#%e5%85%b3%e4%ba%8efor%e5%be%aa%e7%8e%af%e4%b8%ad%e5%ae%9a%e4%b9%89%e5%8f%98%e9%87%8f%e7%9a%84%e5%90%8e%e7%bb%ad%e8%ae%a8%e8%ae%ba" class="header-anchor">&lt;/a>【关于for循环中定义变量的后续讨论】
&lt;/h2>&lt;p>上次在书中看到了关于for循环中定义的变量问题&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>
&lt;a class="link" href="https://boiltask.com/notes/competitive-programming/6" >【看书】for循环中的定义变量&lt;/a>&lt;/p>
&lt;p>结合最近的实际体验和一些测试
在这里再补充说明一些地方&lt;/p>
&lt;h3 id="forint-i0--in--i的局限性">&lt;a href="#forint-i0--in--i%e7%9a%84%e5%b1%80%e9%99%90%e6%80%a7" class="header-anchor">&lt;/a>&lt;code>for(int i=0 ; i&amp;lt;n ; i++)&lt;/code>的局限性
&lt;/h3>&lt;p>我之前提到过&lt;/p>
&lt;blockquote>
&lt;p>提示2-4 建议尽量缩短变量的定义范围。例如，在for循环的初始化部分定义循环变量。&lt;/p>&lt;/blockquote>
&lt;p>加上自己的习惯 所以这些日子都是
尽量对于循环变量随用随定义&lt;/p>
&lt;blockquote>
&lt;p>PS:易语言 记次循环首(次数,n) 也是这种直接写出来的模式 (不过其实也需要先定义 不过个人养成了让它报错然后再直接定义的坏习惯)&lt;/p>&lt;/blockquote>
&lt;p>但是有时出现了一些问题
比如印象最深的关于涉及到 循环中 break;
例如当时有种素数判定方法:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl"> for(i=2;i&amp;lt;=sqrt(m);i++)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if(m%i==0)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> break;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if(i&amp;gt;k)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> printf(&amp;#34;%d 是素数。\n&amp;#34;,m);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> else
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> printf(&amp;#34;%d 不是素数。\n&amp;#34;,m);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>循环for便不能写成&lt;br>
&lt;code>for(int i=2;i&amp;lt;=sqrt(m);i++)&lt;/code>&lt;br>
否则跳出循环后是没有 i 这个变量的&lt;br>
所以如果在for前没有对于 i 定义&lt;br>
&lt;code>if(i&amp;gt;k)&lt;/code>&lt;br>
会报错&lt;br>
而如果定义了&lt;br>
又相当于没有对 i 赋值&lt;br>
所以会得到错误结果&lt;/p>
&lt;p>可见&lt;code>for(int i=0 ; i&amp;lt;n ; i++)&lt;/code>也是不可以滥用的&lt;/p>
&lt;p>现在对于这种情况我一般是采取&lt;/p>
&lt;p>对于这种需要 break 然后判断循环变量的&lt;br>
还是使用在for之前就定义 然后&lt;br>
for还写成 &lt;code>for(i=0 ; i&amp;lt;n ; i++)&lt;/code>&lt;/p>
&lt;p>或者使用一个 flag 标记&lt;br>
比如对于上述判定素数&lt;br>
可写成:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">int flag;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">for(int i=flag=2; i&amp;lt;=sqrt(m); i++) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if(m%i==0) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> flag=0;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> break;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> if(flag)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> printf(&amp;#34;%d 是素数。\n&amp;#34;,m);
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> else
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> printf(&amp;#34;%d 不是素数。\n&amp;#34;,m);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这样会相对麻烦&lt;br>
但对于一些情况还是挺方便理解的&lt;br>
毕竟还是只需要对循环变量随用随定义&lt;br>
循环前只需要 int flag&lt;br>
需要注意的是&lt;br>
flag必须要在循环前定义&lt;br>
在循环里定义同样是无法在循环结束调用的&lt;br>
这引出了下一部分的讨论&lt;br>
也就是对循环体中的定义变量适用范围问题&lt;/p>
&lt;h3 id="while等花括号中int-i-的使用范围">&lt;a href="#while%e7%ad%89%e8%8a%b1%e6%8b%ac%e5%8f%b7%e4%b8%adint-i-%e7%9a%84%e4%bd%bf%e7%94%a8%e8%8c%83%e5%9b%b4" class="header-anchor">&lt;/a>while等{}花括号中int i 的使用范围
&lt;/h3>&lt;p>已经知道&lt;br>
对于自定义函数&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">int sum(int a,int b) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> int c=a+b;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return c;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>(只是为了说明函数中定义变量的问题)&lt;br>
(这个函数可以直接写成)&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-fallback" data-lang="fallback">&lt;span class="line">&lt;span class="cl">int sum(int a,int b) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> return a+b;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>为了避免强迫症 还是再提一下&lt;/p>
&lt;p>在其中定义的 变量c&lt;br>
是无法被其他函数调用的&lt;br>
(包括 main 函数)&lt;/p>
&lt;p>而 函数语句被 { } 括起来&lt;/p>
&lt;p>结合上面的讨论&lt;br>
有种猜测:&lt;br>
{ } 花括号中定义的变量只能适用于花括号里面&lt;/p>
&lt;p>函数的 { } 是这样&lt;br>
那么再讨论另一个使用花括号 { } 的地方&lt;br>
while(){&lt;br>
}&lt;/p>
&lt;p>&lt;img src="https://boiltask.com/notes/competitive-programming/8/image-1.png"
width="627"
height="516"
srcset="https://boiltask.com/notes/competitive-programming/8/image-1_hu_a534196d9b8c5a7.png 480w, https://boiltask.com/notes/competitive-programming/8/image-1_hu_69d43885a6fa7262.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="121"
data-flex-basis="291px"
>&lt;/p>
&lt;p>事实上发现的确会报错
可见上述猜测对 while 是成立的&lt;/p>
&lt;p>想想
其实还有其它有花括号
比如
if(){
}
所以再进行一下测试&lt;/p>
&lt;p>&lt;img src="https://boiltask.com/notes/competitive-programming/8/image-2.png"
width="624"
height="497"
srcset="https://boiltask.com/notes/competitive-programming/8/image-2_hu_bd002c86fa0d601d.png 480w, https://boiltask.com/notes/competitive-programming/8/image-2_hu_f4950aedfb8225d9.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="125"
data-flex-basis="301px"
>&lt;/p>
&lt;p>结果证明同样符合猜测&lt;/p>
&lt;p>所以可以暂且得出结论&lt;/p>
&lt;blockquote>
&lt;p>{ } 花括号中定义的变量只能适用于花括号里面&lt;/p>&lt;/blockquote>
&lt;h2 id="算法是一种思维">&lt;a href="#%e7%ae%97%e6%b3%95%e6%98%af%e4%b8%80%e7%a7%8d%e6%80%9d%e7%bb%b4" class="header-anchor">&lt;/a>算法是一种思维
&lt;/h2>&lt;p>还有关于算法的一些思考……不过关于这一点
想想
“===程序设计灵魂==算法===”
分类下还没有文章
所以这一部分写到那里吧~
哈哈哈哈哈&lt;/p>
&lt;div class="dida-hr">
&lt;div>晚上记录&lt;/div>
&lt;/div>
&lt;p>&lt;del>所以顺带这一部分如果有的话也新开一篇文章吧-.-&lt;/del>&lt;br>
这一篇写的有点长了哦&lt;/p>
&lt;p>算了 还是直接写在这里吧&lt;/p>
&lt;p>比赛链接:&lt;a class="link" href="https://vjudge.net/contest/103724" target="_blank" rel="noopener"
>HPU15级个人赛 - Virtual Judge&lt;/a>&lt;/p>
&lt;p>呃……对于结果不想说话啦&lt;br>
在下只是还要坚定自己的想法&lt;br>
以及完善自己的想法&lt;br>
另外……认真执行自己的想法&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>上次的文章:&lt;a class="link" href="https://boiltask.com/notes/competitive-programming/6" >【看书】for循环中的定义变量&lt;/a>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>算法竞赛入门经典(7) – 二维字符数组</title><link>https://boiltask.com/notes/competitive-programming/7/</link><pubDate>Mon, 11 Jan 2016 20:00:01 +0800</pubDate><guid>https://boiltask.com/notes/competitive-programming/7/</guid><description>&lt;p>在做【UVa】[227]Puzzle&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>这一题的时候&lt;br>
对于 char map[5][5] ; 这种形式的变量又做了讨论&lt;br>
(文章地址:&lt;a class="link" href="https://boiltask.com/oj/uva/227" >【UVa】[227]Puzzle&lt;/a>)&lt;/p>
&lt;p>也就是对于map[5][5]的理解问题&lt;/p>
&lt;p>s[5] 可以理解为字符串(字符数组)&lt;br>
那么 map[5][5]也可以理解为 多行字符串(二维字符数组)&lt;/p>
&lt;blockquote>
&lt;p>abc (0)&lt;br>
def (1)&lt;br>
ghi (2)&lt;/p>&lt;/blockquote>
&lt;p>map[0]便代表”abc”&lt;br>
map[1]便代表”def”&lt;br>
map[2]便代表”ghi”&lt;/p>
&lt;p>也就是map[n][m]&lt;br>
n是行号 m是列号&lt;/p>
&lt;p>map[0][0]==’a’&lt;br>
map[0][1]==’b’&lt;br>
map[1][1]==’e’&lt;br>
map[2][0]==’g’&lt;/p>
&lt;p>所以对 map[5][5] 赋值可以用&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">char&lt;/span> &lt;span class="n">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">scanf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%s&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;del>同理可用于&lt;code>printf(&amp;quot;%s&amp;quot;,map[i]);&lt;/code>&lt;/del>&lt;br>
经测试不可以！！&lt;br>
应该是因为printf是遇到’\0’才结束吧&lt;br>
而且除了第一行之后 后面还跟了乱码符&lt;br>
使用之后输出结果如下&lt;br>
&lt;img src="https://boiltask.com/notes/competitive-programming/7/image.png"
width="773"
height="376"
srcset="https://boiltask.com/notes/competitive-programming/7/image_hu_366c13b53be4a8b8.png 480w, https://boiltask.com/notes/competitive-programming/7/image_hu_1faf5d5f1bb5a97e.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="205"
data-flex-basis="493px"
>&lt;/p>
&lt;p>而使用二重循环配合 &lt;code>putchar(map[i][j]);&lt;/code> &lt;br>
或者&lt;code>printf(&amp;quot;%c&amp;quot;,map[i][j]);&lt;/code>&lt;br>
便可以正常输出 代码如下&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&amp;lt;stdio.h&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&amp;lt;string.h&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">char&lt;/span> &lt;span class="n">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">memset&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">map&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="k">sizeof&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">map&lt;/span>&lt;span class="p">));&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">scanf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%s&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">j&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// putchar(map[i][j]);
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%c&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">]);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>由此可见&lt;br>
C语言的魅力还远不止于此啊-.-&lt;br>
另外再次感叹一下这书习题是给的真好&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>&lt;a class="link" href="https://vjudge.net/problem/uva-227" target="_blank" rel="noopener"
>Puzzle - UVA 227 - Virtual Judge&lt;/a>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>算法竞赛入门经典(6) – for循环中的定义变量</title><link>https://boiltask.com/notes/competitive-programming/6/</link><pubDate>Mon, 04 Jan 2016 17:11:21 +0800</pubDate><guid>https://boiltask.com/notes/competitive-programming/6/</guid><description>&lt;p>想起了以前的一个知识点&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="err">起始语句&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">判断语句&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="err">修正语句&lt;/span>&lt;span class="p">){&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="err">循环语句&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>对于for循环我以前的理解是这样的&lt;br>
执行到for循环时&lt;br>
先执行一次 起始语句&lt;br>
然后开始执行循环体(循环语句)&lt;br>
执行后执行 修正语句&lt;br>
然后判断 判断语句&lt;br>
成立则继续执行 循环语句→修正语句→判断语句……&lt;/p>
&lt;p>但通过P19中的介绍以及实验&lt;br>
发现似乎还有一些需要注意的地方&lt;/p>
&lt;p>也就是这种写法:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>也就是循环变量i是在for语句时才建立的&lt;br>
按照之前&lt;/p>
&lt;blockquote>
&lt;p>执行到for循环时&lt;br>
先执行一次 起始语句&lt;/p>&lt;/blockquote>
&lt;p>理解 这个i应该和这种用法:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">100&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>是一样的&lt;br>
但探究之后发现并不一样&lt;/p>
&lt;p>参考如下语句&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&amp;lt;stdio.h&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// int i;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">20&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%d &amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">%d&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>当编译时会报错&lt;br>
&lt;img src="https://boiltask.com/notes/competitive-programming/6/image-1.png"
width="735"
height="45"
srcset="https://boiltask.com/notes/competitive-programming/6/image-1_hu_3a23bf5f5d2e4047.png 480w, https://boiltask.com/notes/competitive-programming/6/image-1_hu_78baaf5a0fef4601.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="1633"
data-flex-basis="3920px"
>&lt;/p>
&lt;p>也就是for循环结束之后&lt;br>
i变得无法调用了&lt;/p>
&lt;p>而for之前的那条注释语句加上的话&lt;br>
发现执行结果如下:&lt;br>
&lt;img src="https://boiltask.com/notes/competitive-programming/6/image-2.png"
width="419"
height="34"
srcset="https://boiltask.com/notes/competitive-programming/6/image-2_hu_6c8b6e0062447f15.png 480w, https://boiltask.com/notes/competitive-programming/6/image-2_hu_1db5e3aaaeaf7c8e.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="1232"
data-flex-basis="2957px"
>&lt;/p>
&lt;p>可见循环中的 int i 并没有影响循环外的 int i&lt;br>
所以可见这个for循环中的i是独立的&lt;/p>
&lt;p>这样的话 既然独立 那么随用随定义应该是好过直接先定义的&lt;/p>
&lt;p>以前我在这种的时候是习惯把正常的变量与循环变量分开区分的&lt;br>
如&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="kt">int&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">m&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//储存数值的变量
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">j&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">k&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//记录循环次数的变量
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>而了解到这一特性之后&lt;br>
可以轻松地在运用for时再定义这些变量 而不影响其它部分&lt;/p>
&lt;p>在P19有这样一句话&lt;/p>
&lt;blockquote>
&lt;p>提示2-4 建议尽量缩短变量的定义范围。例如，在for循环的初始化部分定义循环变量。&lt;/p>&lt;/blockquote>
&lt;p>我也是深感很有道理啊~&lt;br>
话说这就是共鸣哎~毕竟每个人的习惯还是不一样的 能和大神的观点一致 还是有点小激动的呢&lt;/p>
&lt;p>《算法竞赛入门经典(第2版)》P19&lt;/p>
&lt;p>以上发表于:&lt;br>
【看书】for循环中的定义变量（2016-01-04 17:11） 11 0&lt;/p>
&lt;p>20160112 附:
后续文章:&lt;a class="link" href="https://boiltask.com/notes/competitive-programming/8/" >【看书】关于for循环中定义变量的后续讨论&lt;/a>&lt;/p></description></item><item><title>算法竞赛入门经典(5) – 竖式问题</title><link>https://boiltask.com/notes/competitive-programming/5/</link><pubDate>Mon, 28 Dec 2015 18:04:49 +0800</pubDate><guid>https://boiltask.com/notes/competitive-programming/5/</guid><description>&lt;p>问题描述：&lt;br>
找出所有形如abc*de（三位数乘以两位数）的算式，使得在完整的竖式中，所有数字都属于一个特定的数字集合。输入数字集合（相邻数字之间没有空格），输出所有竖式。每个竖式前应有编号，之后应有一个空行。最后输出解的总数。具体格式见样例输出（为了便于观察，竖式中的空格改用小数点显示，但你的程序应该输出空格，而非小数点）。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//样例输入
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="mi">2357&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">//样例输出
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">.&lt;/span>&lt;span class="mf">.775&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">X&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="mf">.33&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">-----&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mf">.2325&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mf">2325.&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">-----&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="mi">25575&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">The&lt;/span> &lt;span class="n">number&lt;/span> &lt;span class="n">of&lt;/span> &lt;span class="n">solutions&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>写上补充一下这个题目所要表达的意思&lt;br>
同时还是继续考虑用MarkDown编辑器&lt;br>
怎么来写这种文章&lt;/p>
&lt;p>这个题目是要求出所有满足&lt;br>
形如 abc*de 三位数乘以两位数&lt;br>
并且竖式过程中用到的数&lt;br>
都在集合”s”中&lt;/p>
&lt;p>输出这样的竖式及总共有多少&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&amp;lt;stdio.h&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&amp;lt;string.h&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">count&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">char&lt;/span> &lt;span class="n">s&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">20&lt;/span>&lt;span class="p">],&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">99&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">scanf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%s&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">abc&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">111&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">abc&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="mi">999&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">abc&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">de&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">11&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">de&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span>&lt;span class="mi">99&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">de&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">abc&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">de&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">abc&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">de&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="n">z&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">abc&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">de&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">sprintf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="s">&amp;#34;%d%d%d%d%d&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">abc&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">de&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">z&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">ok&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">strlen&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">strchr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">buf&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">])&lt;/span>&lt;span class="o">==&lt;/span>&lt;span class="nb">NULL&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">ok&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">ok&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;&amp;lt;%d&amp;gt;&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%5d&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">X%4d&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">-----&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">%5d&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">%4d&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">-----&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">%5d&lt;/span>&lt;span class="se">\n\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">abc&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">de&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">z&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;The number of solutions = %d&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">count&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>《算法竞赛入门经典(第2版)》P41&lt;/p></description></item><item><title>算法竞赛入门经典(4) – 浮点数陷阱</title><link>https://boiltask.com/notes/competitive-programming/4/</link><pubDate>Mon, 28 Dec 2015 17:32:23 +0800</pubDate><guid>https://boiltask.com/notes/competitive-programming/4/</guid><description>&lt;p>《算法竞赛入门经典(第2版)》&lt;br>
P36 题目2 下面的程序运行结果是什么？“!=”运算符表示“不相等”。提示：请上机实验，不要凭主观感觉回答。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&amp;lt;stdio.h&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">double&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">!=&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">+=&lt;/span>&lt;span class="mf">0.1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%.lf&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>运行结果:&lt;br>
&lt;img src="https://boiltask.com/notes/competitive-programming/4/image-1.png"
width="669"
height="466"
srcset="https://boiltask.com/notes/competitive-programming/4/image-1_hu_754206b6114b8548.png 480w, https://boiltask.com/notes/competitive-programming/4/image-1_hu_cff1e097ac796bc8.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="143"
data-flex-basis="344px"
>&lt;/p>
&lt;p>可以发现程序会一直循环下去&lt;br>
把代码改成如下&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&amp;lt;stdio.h&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">double&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">!=&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="o">&amp;amp;&amp;amp;&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="mi">20&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">+=&lt;/span>&lt;span class="mf">0.1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%.lf&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>可以发现&lt;br>
&lt;img src="https://boiltask.com/notes/competitive-programming/4/image-2.png"
width="93"
height="344"
srcset="https://boiltask.com/notes/competitive-programming/4/image-2_hu_69ab63cd63842035.png 480w, https://boiltask.com/notes/competitive-programming/4/image-2_hu_eb4596e756d23b03.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="27"
data-flex-basis="64px"
>&lt;/p>
&lt;p>c语言中double类型数据计算是有误差的&lt;br>
也就是说每次加0.1&lt;br>
可能永远得不到整10&lt;/p>
&lt;p>所以上述程序会永远循环&lt;/p></description></item><item><title>算法竞赛入门经典(3) – 输出不确定位数的小数</title><link>https://boiltask.com/notes/competitive-programming/3/</link><pubDate>Mon, 28 Dec 2015 16:53:23 +0800</pubDate><guid>https://boiltask.com/notes/competitive-programming/3/</guid><description>&lt;p>《算法竞赛入门经典》P35 习题2-5&lt;/p>
&lt;p>分数化小数 (decimal)&lt;/p>
&lt;p>问题描述：&lt;/p>
&lt;blockquote>
&lt;p>输入正整数a，b，c，输出a/b的小数形式，精确到小数点后c位。a,b≤106(10的6次方) ，c≤100。输入包含多组数据，结束标记为a=b=c=0。&lt;/p>
&lt;p>样例输入：&lt;/p>
&lt;p>1 6 4&lt;/p>
&lt;p>0 0 0&lt;/p>
&lt;p>样例输出：&lt;/p>
&lt;p>Case 1 : 0.1667&lt;/p>&lt;/blockquote>
&lt;p>又是一种没见过的题&lt;br>
而且顺便使用一下 HTML版的博文编辑器~&lt;/p>
&lt;p>当小数的位数定的时候可以写成&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%.4lf&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这次要输出一个位数不定的小数&lt;/p>
&lt;p>所以不能这么写&lt;br>
百度一下发现可以这么写&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%.*lf&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>所以整个程序可以写成:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&amp;lt;stdio.h&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="cp">&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">double&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">c&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">kase&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">while&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">scanf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;%lf %lf %d&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">),&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="o">!=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="o">||&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="o">!=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="o">||&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="o">!=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Case %d : %.*lf&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="n">kase&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">b&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如此应该可以符合题意~&lt;br>
话说……&lt;br>
有没有这些题的OJ啊……&lt;br>
一会再去找一找……&lt;/p></description></item><item><title>算法竞赛入门经典(2) – 程序计时器</title><link>https://boiltask.com/notes/competitive-programming/2/</link><pubDate>Sun, 27 Dec 2015 12:33:36 +0800</pubDate><guid>https://boiltask.com/notes/competitive-programming/2/</guid><description>&lt;p>当感到程序计算过慢时&lt;br>
可使用“计时器”来查看到底有多慢&lt;/p>
&lt;p>具体的是一个 time.h 头文件&lt;br>
从而调用计时函数 clock()&lt;br>
这个获得的数值除以常数 CLOCK_PER_SEC&lt;br>
可以得到以秒为单位的数值&lt;/p>
&lt;p>代码写法&lt;br>
先调用头文件&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="cp">#include&amp;lt;time.h&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然后在程序结尾写上&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-cpp" data-lang="cpp">&lt;span class="line">&lt;span class="cl">&lt;span class="n">printf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;程序用时 = %.2f&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,(&lt;/span>&lt;span class="kt">double&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="n">clock&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">CLOCKS_PER_SEC&lt;/span>&lt;span class="p">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>但通过这种方式发现程序用时过大&lt;br>
因为这个计时的起点是以打开程序开始的&lt;br>
所以会导致用键盘输入的时间也会包括在内&lt;br>
所以可以用命令行来解决&lt;/p>
&lt;p>打开 CMD(命令提示符)&lt;/p>
&lt;p>输入&lt;br>
cd 文件目录&lt;br>
来把当前目录转到指定目录&lt;br>
如：&lt;br>
&lt;img src="https://boiltask.com/notes/competitive-programming/2/image-1.png"
width="384"
height="27"
srcset="https://boiltask.com/notes/competitive-programming/2/image-1_hu_a4cf9ebffb2231d4.png 480w, https://boiltask.com/notes/competitive-programming/2/image-1_hu_a4bf54ff6e8e0fc1.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="1422"
data-flex-basis="3413px"
>&lt;/p>
&lt;p>然后输入 echo 输入数据 | 程序名&lt;br>
如:&lt;br>
&lt;img src="https://boiltask.com/notes/competitive-programming/2/image-2.png"
width="383"
height="419"
srcset="https://boiltask.com/notes/competitive-programming/2/image-2_hu_574993fa2ed22ea4.png 480w, https://boiltask.com/notes/competitive-programming/2/image-2_hu_8cdb9400d243457a.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="91"
data-flex-basis="219px"
>&lt;/p>
&lt;p>abc便是我创建程序的文件名&lt;/p>
&lt;p>可以得到一些关于输入输出的数据&lt;br>
从而可以进行分析&lt;/p>
&lt;p>&lt;img src="https://boiltask.com/notes/competitive-programming/2/image-3.png"
width="4208"
height="885"
srcset="https://boiltask.com/notes/competitive-programming/2/image-3_hu_587c27bb9ed0a803.png 480w, https://boiltask.com/notes/competitive-programming/2/image-3_hu_5cba210d1087ece5.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="475"
data-flex-basis="1141px"
>&lt;/p>
&lt;p>与书中给的数据还是有不少差别的&lt;br>
可见我的小电脑计算能力还是可以哒~&lt;br>
哈哈哈&lt;/p>
&lt;p>《算法竞赛入门经典》——刘佳汝 P26&lt;/p></description></item><item><title>算法竞赛入门经典(1) – int的范围</title><link>https://boiltask.com/notes/competitive-programming/1/</link><pubDate>Sun, 27 Dec 2015 11:42:51 +0800</pubDate><guid>https://boiltask.com/notes/competitive-programming/1/</guid><description>&lt;p>越发的感觉刘汝佳的《算法竞赛入门经典》写的很好&lt;br>
然后勾起了心中的共鸣~&lt;br>
然后没事就发点读后感吧&lt;br>
也算是在看书过程中的调节调节&lt;/p>
&lt;p>哈哈哈~&lt;br>
先把P16的指出的int范围测出来~&lt;br>
&lt;img src="https://boiltask.com/notes/competitive-programming/1/image-1.png"
width="677"
height="493"
srcset="https://boiltask.com/notes/competitive-programming/1/image-1_hu_53c108ea1df6f8b4.png 480w, https://boiltask.com/notes/competitive-programming/1/image-1_hu_db47aeb0a05d4bbc.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="137"
data-flex-basis="329px"
>&lt;br>
&lt;img src="https://boiltask.com/notes/competitive-programming/1/image-2.png"
width="677"
height="493"
srcset="https://boiltask.com/notes/competitive-programming/1/image-2_hu_191fb8eda34debb9.png 480w, https://boiltask.com/notes/competitive-programming/1/image-2_hu_cc6e453d76f2f96c.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="137"
data-flex-basis="329px"
>&lt;br>
&lt;img src="https://boiltask.com/notes/competitive-programming/1/image-3.png"
width="677"
height="493"
srcset="https://boiltask.com/notes/competitive-programming/1/image-3_hu_37a60f144d5abece.png 480w, https://boiltask.com/notes/competitive-programming/1/image-3_hu_8f904879115b9f2d.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="137"
data-flex-basis="329px"
>&lt;br>
&lt;img src="https://boiltask.com/notes/competitive-programming/1/image-4.png"
width="677"
height="493"
srcset="https://boiltask.com/notes/competitive-programming/1/image-4_hu_23bd3b9c2a1ccb8d.png 480w, https://boiltask.com/notes/competitive-programming/1/image-4_hu_835aa833697d21c3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="137"
data-flex-basis="329px"
>&lt;/p>
&lt;p>int ： -2147483647~2147483647&lt;br>
话说我以前怎么没想到还有必要进行一下这种测试嘞~&lt;/p></description></item></channel></rss>