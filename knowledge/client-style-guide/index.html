<!doctype html><html lang=zh-CN dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content=' 整理一下总结的客户端向的编程规范，尽可能做到有理有据，后续可能还会不定期修订。\n头文件 Include 头文件 通过宏防止重复包含 #pragma once，所用的所有编译器均支持 包含时尽量细粒化。例如，勿包含Core.h，而在核心中包含需要定义的特定头文件。 尽量直接包含所需的头文件，以便进行细粒化包含。 在 #include 中插入空行以分割相关头文件, C 库, C++ 库, 其他库的 .h 和本项目内的 .h 是个好习惯。 尽可能在cpp中引用其他头文件，避免头文件中直接引用某一类。 可以考虑优先使用声明类的形式来在头文件中使用另一类而在cpp中再真正include，可以有效梳理结构避免循环引用。 尽可能先根据：cpp对应头文件、C++标准库文件、框架头文件、第三方头文件、项目通用头文件、具体功能头文件的顺序来引用文件，方便理清文件引用结构。 引用头文件时尽可能避免使用相对位置，比如....\\NetDef.h，不利于文件梳理以及理解文件结构。 避免使用反斜线\\来标记路径，在一些编译器会存在异常，应使用斜线/来标记路径。 前置声明 所谓「前置声明」（forward declaration）是类、函数和模板的纯粹声明，没伴随着其定义 前置声明能够节省编译时间，多余的 #include 会迫使编译器展开更多的文件，处理更多的输入。 前置声明能够节省不必要的重新编译的时间。 #include 使代码因为头文件中无关的改动而被重新编译多次。 尽可能的使用前置声明，而非头文件，在CPP中包含对应的头文件 减少编译的时间 内联函数 内联函数的合理使用可提高代码执行效率 当函数只有10行甚至更少时才将其定义为内联函数 谨慎对待析构函数，析构函数往往比其表面看起来要更长，因为有隐含的成员和基类析构函数被调用 包含循环和switch语句的函数内联通常得不偿失 声明了内联也不一定会被编译器内联，虚函数和递归函数不会被正常内联 类内部的函数一般会自动内联。所以某函数一旦不需要内联，其定义就不要再放在头文件里，而是放到对应的 cpp 文件里。这样可以保持头文件的类相当精炼，也很好地贯彻了声明与定义分离的原则。 范例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #pragma once // 头文件区 #include "CoreMinimal.h" #include "UObject/ObjectMacros.h" #include "UObject/UObjectBaseUtility.h" #include "UObject/Object.h" #include "TestObject.generated.h" // 前置声明区 class AActor; class AController; class UPrimitiveComponent; struct FAttachedActorInfo; // 结构体定义 USTRUCT() struct FTestStruct { GENERATED_BODY() public: UPROPERTY() int TestValue = 0; ... }; // 委托定义 // 类体定义 UCLASS(BlueprintType, Blueprintable) class ATestObject : public AActor { GENERATED_BODY() public: ATestObject(); .... }; // 内联函数定义 ... 作用域 命名空间 命名空间将全局作用域细分为独立的, 具名的作用域, 可有效防止全局作用域的命名冲突。 禁止使用using namespace xxx; 禁止使用内联命名空间 1 2 3 4 5 namespace X { inline namespace Y { void foo(); } } X::Y::foo与X::foo是等价的 内联命名空间主要用来保持跨版本的 ABI 兼容性。（一般用不到） 在头文件中使用匿名空间违背了C++的唯一定义原则（One Definition Rule（ODR）） 匿名命名空间和静态变量 内部链接性 意味着你在这个文件中声明的这些标识符都不能在另一个文件中被访问。即使两个文件声明了完全一样名字的标识符，它们所指向的实体实际上是完全不同的。 在 .cpp 文件中定义一个不需要被外部引用的变量时，可以将它们放在匿名命名空间或声明为 static 。 不需要被外部引用的变量 不要在头文件中使用 1 2 3 4 5 6 7 xxx.cpp namespace { int xxx = 0; } static int xxx = 0; 局部变量 函数变量尽可能置于最小作用域，并在变量声明时进行初始化\n'><title>客户端编程规范 - BoilTask's Blog</title>
<link rel=canonical href=https://boiltask.com/knowledge/client-style-guide/><link rel=stylesheet href=/scss/style.min.c48666a9bed7a90461589c11f316181f3cdd1fabaedaabc770d00b1c7a1d5d7e.css><meta property='og:title' content="客户端编程规范 - BoilTask's Blog"><meta property='og:description' content=' 整理一下总结的客户端向的编程规范，尽可能做到有理有据，后续可能还会不定期修订。\n头文件 Include 头文件 通过宏防止重复包含 #pragma once，所用的所有编译器均支持 包含时尽量细粒化。例如，勿包含Core.h，而在核心中包含需要定义的特定头文件。 尽量直接包含所需的头文件，以便进行细粒化包含。 在 #include 中插入空行以分割相关头文件, C 库, C++ 库, 其他库的 .h 和本项目内的 .h 是个好习惯。 尽可能在cpp中引用其他头文件，避免头文件中直接引用某一类。 可以考虑优先使用声明类的形式来在头文件中使用另一类而在cpp中再真正include，可以有效梳理结构避免循环引用。 尽可能先根据：cpp对应头文件、C++标准库文件、框架头文件、第三方头文件、项目通用头文件、具体功能头文件的顺序来引用文件，方便理清文件引用结构。 引用头文件时尽可能避免使用相对位置，比如....\\NetDef.h，不利于文件梳理以及理解文件结构。 避免使用反斜线\\来标记路径，在一些编译器会存在异常，应使用斜线/来标记路径。 前置声明 所谓「前置声明」（forward declaration）是类、函数和模板的纯粹声明，没伴随着其定义 前置声明能够节省编译时间，多余的 #include 会迫使编译器展开更多的文件，处理更多的输入。 前置声明能够节省不必要的重新编译的时间。 #include 使代码因为头文件中无关的改动而被重新编译多次。 尽可能的使用前置声明，而非头文件，在CPP中包含对应的头文件 减少编译的时间 内联函数 内联函数的合理使用可提高代码执行效率 当函数只有10行甚至更少时才将其定义为内联函数 谨慎对待析构函数，析构函数往往比其表面看起来要更长，因为有隐含的成员和基类析构函数被调用 包含循环和switch语句的函数内联通常得不偿失 声明了内联也不一定会被编译器内联，虚函数和递归函数不会被正常内联 类内部的函数一般会自动内联。所以某函数一旦不需要内联，其定义就不要再放在头文件里，而是放到对应的 cpp 文件里。这样可以保持头文件的类相当精炼，也很好地贯彻了声明与定义分离的原则。 范例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #pragma once // 头文件区 #include "CoreMinimal.h" #include "UObject/ObjectMacros.h" #include "UObject/UObjectBaseUtility.h" #include "UObject/Object.h" #include "TestObject.generated.h" // 前置声明区 class AActor; class AController; class UPrimitiveComponent; struct FAttachedActorInfo; // 结构体定义 USTRUCT() struct FTestStruct { GENERATED_BODY() public: UPROPERTY() int TestValue = 0; ... }; // 委托定义 // 类体定义 UCLASS(BlueprintType, Blueprintable) class ATestObject : public AActor { GENERATED_BODY() public: ATestObject(); .... }; // 内联函数定义 ... 作用域 命名空间 命名空间将全局作用域细分为独立的, 具名的作用域, 可有效防止全局作用域的命名冲突。 禁止使用using namespace xxx; 禁止使用内联命名空间 1 2 3 4 5 namespace X { inline namespace Y { void foo(); } } X::Y::foo与X::foo是等价的 内联命名空间主要用来保持跨版本的 ABI 兼容性。（一般用不到） 在头文件中使用匿名空间违背了C++的唯一定义原则（One Definition Rule（ODR）） 匿名命名空间和静态变量 内部链接性 意味着你在这个文件中声明的这些标识符都不能在另一个文件中被访问。即使两个文件声明了完全一样名字的标识符，它们所指向的实体实际上是完全不同的。 在 .cpp 文件中定义一个不需要被外部引用的变量时，可以将它们放在匿名命名空间或声明为 static 。 不需要被外部引用的变量 不要在头文件中使用 1 2 3 4 5 6 7 xxx.cpp namespace { int xxx = 0; } static int xxx = 0; 局部变量 函数变量尽可能置于最小作用域，并在变量声明时进行初始化\n'><meta property='og:url' content='https://boiltask.com/knowledge/client-style-guide/'><meta property='og:site_name' content="BoilTask's Blog"><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='cpp'><meta property='article:published_time' content='2021-05-10T21:34:36+08:00'><meta property='article:modified_time' content='2021-05-10T21:34:36+08:00'><meta name=twitter:title content="客户端编程规范 - BoilTask's Blog"><meta name=twitter:description content=' 整理一下总结的客户端向的编程规范，尽可能做到有理有据，后续可能还会不定期修订。\n头文件 Include 头文件 通过宏防止重复包含 #pragma once，所用的所有编译器均支持 包含时尽量细粒化。例如，勿包含Core.h，而在核心中包含需要定义的特定头文件。 尽量直接包含所需的头文件，以便进行细粒化包含。 在 #include 中插入空行以分割相关头文件, C 库, C++ 库, 其他库的 .h 和本项目内的 .h 是个好习惯。 尽可能在cpp中引用其他头文件，避免头文件中直接引用某一类。 可以考虑优先使用声明类的形式来在头文件中使用另一类而在cpp中再真正include，可以有效梳理结构避免循环引用。 尽可能先根据：cpp对应头文件、C++标准库文件、框架头文件、第三方头文件、项目通用头文件、具体功能头文件的顺序来引用文件，方便理清文件引用结构。 引用头文件时尽可能避免使用相对位置，比如....\\NetDef.h，不利于文件梳理以及理解文件结构。 避免使用反斜线\\来标记路径，在一些编译器会存在异常，应使用斜线/来标记路径。 前置声明 所谓「前置声明」（forward declaration）是类、函数和模板的纯粹声明，没伴随着其定义 前置声明能够节省编译时间，多余的 #include 会迫使编译器展开更多的文件，处理更多的输入。 前置声明能够节省不必要的重新编译的时间。 #include 使代码因为头文件中无关的改动而被重新编译多次。 尽可能的使用前置声明，而非头文件，在CPP中包含对应的头文件 减少编译的时间 内联函数 内联函数的合理使用可提高代码执行效率 当函数只有10行甚至更少时才将其定义为内联函数 谨慎对待析构函数，析构函数往往比其表面看起来要更长，因为有隐含的成员和基类析构函数被调用 包含循环和switch语句的函数内联通常得不偿失 声明了内联也不一定会被编译器内联，虚函数和递归函数不会被正常内联 类内部的函数一般会自动内联。所以某函数一旦不需要内联，其定义就不要再放在头文件里，而是放到对应的 cpp 文件里。这样可以保持头文件的类相当精炼，也很好地贯彻了声明与定义分离的原则。 范例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #pragma once // 头文件区 #include "CoreMinimal.h" #include "UObject/ObjectMacros.h" #include "UObject/UObjectBaseUtility.h" #include "UObject/Object.h" #include "TestObject.generated.h" // 前置声明区 class AActor; class AController; class UPrimitiveComponent; struct FAttachedActorInfo; // 结构体定义 USTRUCT() struct FTestStruct { GENERATED_BODY() public: UPROPERTY() int TestValue = 0; ... }; // 委托定义 // 类体定义 UCLASS(BlueprintType, Blueprintable) class ATestObject : public AActor { GENERATED_BODY() public: ATestObject(); .... }; // 内联函数定义 ... 作用域 命名空间 命名空间将全局作用域细分为独立的, 具名的作用域, 可有效防止全局作用域的命名冲突。 禁止使用using namespace xxx; 禁止使用内联命名空间 1 2 3 4 5 namespace X { inline namespace Y { void foo(); } } X::Y::foo与X::foo是等价的 内联命名空间主要用来保持跨版本的 ABI 兼容性。（一般用不到） 在头文件中使用匿名空间违背了C++的唯一定义原则（One Definition Rule（ODR）） 匿名命名空间和静态变量 内部链接性 意味着你在这个文件中声明的这些标识符都不能在另一个文件中被访问。即使两个文件声明了完全一样名字的标识符，它们所指向的实体实际上是完全不同的。 在 .cpp 文件中定义一个不需要被外部引用的变量时，可以将它们放在匿名命名空间或声明为 static 。 不需要被外部引用的变量 不要在头文件中使用 1 2 3 4 5 6 7 xxx.cpp namespace { int xxx = 0; } static int xxx = 0; 局部变量 函数变量尽可能置于最小作用域，并在变量声明时进行初始化\n'><link rel="shortcut icon" href=/favicon.ico><style>.main-container{display:none}</style><script>let isShouldLoad=!0;setTimeout(()=>{if(isShouldLoad){const e=document.getElementById("loadingOverlay");e&&(e.style.display="flex")}},200)</script><script src=https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js></script><script>document.addEventListener("DOMContentLoaded",()=>{isShouldLoad=!1,pangu.spacingPage();const e=document.getElementsByClassName("main-container");for(let t=0;t<e.length;t++)e[t].style.display="flex";const t=document.getElementById("loadingOverlay");t&&(t.style.display="none")})</script></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/images/avatar_hu15227866149128747816.jpg width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>BoilTask's Blog</a></h1><h2 class=site-description>Game developer and designer, C/C++ | Golang | UE | Web</h2></div></header><ol class=menu-social><li><a href=https://github.com/BoilTask target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>主页</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>文章归档</span></a></li><li><a href=/categories/><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
<span>分类</span></a></li><li><a href=/tags/><svg class="icon icon-tabler icon-tabler-tag" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11 3l9 9a1.5 1.5.0 010 2l-6 6a1.5 1.5.0 01-2 0L3 11V7a4 4 0 014-4h4"/><circle cx="9" cy="9" r="2"/></svg>
<span>标签云</span></a></li><li><a href=/links/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>友情链接</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>搜索</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#头文件>头文件</a><ol><li><a href=#include>Include</a></li><li><a href=#前置声明>前置声明</a></li><li><a href=#内联函数>内联函数</a></li><li><a href=#范例>范例</a></li></ol></li><li><a href=#作用域>作用域</a><ol><li><a href=#命名空间>命名空间</a></li><li><a href=#匿名命名空间和静态变量>匿名命名空间和静态变量</a></li><li><a href=#局部变量>局部变量</a></li><li><a href=#静态和全局变量>静态和全局变量</a></li></ol></li><li><a href=#类>类</a><ol><li><a href=#构造函数>构造函数</a></li><li><a href=#隐式类型变换>隐式类型变换</a></li><li><a href=#可拷贝类型和可移动类型>可拷贝类型和可移动类型</a></li><li><a href=#继承>继承</a></li><li><a href=#多重继承>多重继承</a></li><li><a href=#接口>接口</a></li><li><a href=#运算符重载>运算符重载</a></li><li><a href=#成员变量>成员变量</a></li></ol></li><li><a href=#结构体>结构体</a><ol><li><a href=#成员变量初始化>成员变量初始化</a></li></ol></li><li><a href=#枚举>枚举</a><ol><li><a href=#枚举值类型>枚举值类型</a><ol><li><a href=#枚举值类型理由>枚举值类型理由</a></li></ol></li><li><a href=#枚举值命名>枚举值命名</a></li><li><a href=#枚举值顺序>枚举值顺序</a></li><li><a href=#枚举值举例>枚举值举例</a></li></ol></li><li><a href=#异常>异常</a><ol><li><a href=#错误码>错误码</a></li></ol></li><li><a href=#函数>函数</a><ol><li><a href=#输入和输出>输入和输出</a></li><li><a href=#编写简短函数>编写简短函数</a></li><li><a href=#常量正确性>常量正确性</a></li><li><a href=#函数重载>函数重载</a></li><li><a href=#缺省参数>缺省参数</a></li><li><a href=#lambda表达式>Lambda表达式</a></li></ol></li><li><a href=#配置>配置</a></li><li><a href=#回调>回调</a></li><li><a href=#标准库>标准库</a></li><li><a href=#排版与格式>排版与格式</a><ol><li><a href=#命名相关>命名相关</a></li><li><a href=#代码格式>代码格式</a></li></ol></li><li><a href=#注释>注释</a><ol><li><a href=#规范>规范</a></li><li><a href=#原则>原则</a></li><li><a href=#todo>TODO</a></li></ol></li><li><a href=#其他相关>其他相关</a><ol><li><a href=#sizeof>Sizeof</a></li><li><a href=#迭代器>迭代器</a></li><li><a href=#死循环>死循环</a></li><li><a href=#浮点数>浮点数</a></li><li><a href=#stdvectorbool>std::vector&lt;bool></a></li><li><a href=#空指针>空指针</a></li></ol></li><li><a href=#数值溢出>数值溢出</a></li><li><a href=#内存>内存</a><ol><li><a href=#常见问题>常见问题</a></li><li><a href=#智能指针>智能指针</a></li><li><a href=#容器>容器</a></li><li><a href=#ue的内存管理>UE的内存管理</a><ol><li><a href=#gc机制>GC机制</a></li><li><a href=#弱指针>弱指针</a></li></ol></li><li><a href=#网络>网络</a></li><li><a href=#proto>Proto</a></li></ol></li><li><a href=#日志>日志</a><ol><li><a href=#日志规范>日志规范</a></li></ol></li><li><a href=#checklist>CheckList</a></li><li><a href=#参考文献>参考文献</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/knowledge/>知识汇总</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/knowledge/client-style-guide/>客户端编程规范</a></h2></div><footer class=article-time><div class=article-time-item><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
文章字数：12200</div><div class=article-time-item><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 25 分钟</time></div><div class=article-time-item><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>2021-05-10 21:34:36</time></div></footer></div><style>.article-time{display:flex;flex-wrap:wrap;gap:32px;justify-content:flex-start}</style></header><section class=article-content><blockquote><p>整理一下总结的客户端向的编程规范，尽可能做到有理有据，后续可能还会不定期修订。</p></blockquote><h2 id=头文件><a href=#%e5%a4%b4%e6%96%87%e4%bb%b6 class=header-anchor></a>头文件</h2><h3 id=include><a href=#include class=header-anchor></a>Include</h3><ul><li>头文件<ul><li>通过宏防止重复包含</li><li><code>#pragma once</code>，所用的所有编译器均支持</li><li>包含时尽量细粒化。例如，勿包含Core.h，而在核心中包含需要定义的特定头文件。</li><li>尽量直接包含所需的头文件，以便进行细粒化包含。</li><li>在 <code>#include</code> 中插入空行以分割相关头文件, C 库, C++ 库, 其他库的 <code>.h</code> 和本项目内的 <code>.h</code> 是个好习惯。</li><li>尽可能在cpp中引用其他头文件，避免头文件中直接引用某一类。<ul><li>可以考虑优先使用声明类的形式来在头文件中使用另一类而在cpp中再真正include，可以有效梳理结构避免循环引用。</li></ul></li><li>尽可能先根据：cpp对应头文件、C++标准库文件、框架头文件、第三方头文件、项目通用头文件、具体功能头文件的顺序来引用文件，方便理清文件引用结构。</li><li>引用头文件时尽可能避免使用相对位置，比如....\NetDef.h，不利于文件梳理以及理解文件结构。</li><li>避免使用反斜线<code>\</code>来标记路径，在一些编译器会存在异常，应使用斜线<code>/</code>来标记路径。</li></ul></li></ul><h3 id=前置声明><a href=#%e5%89%8d%e7%bd%ae%e5%a3%b0%e6%98%8e class=header-anchor></a>前置声明</h3><ul><li>所谓「前置声明」（forward declaration）是类、函数和模板的纯粹声明，没伴随着其定义<ul><li>前置声明能够节省编译时间，多余的 <code>#include</code> 会迫使编译器展开更多的文件，处理更多的输入。</li><li>前置声明能够节省不必要的重新编译的时间。 <code>#include</code> 使代码因为头文件中无关的改动而被重新编译多次。</li><li>尽可能的使用前置声明，而非头文件，在CPP中包含对应的头文件</li><li>减少编译的时间</li></ul></li></ul><h3 id=内联函数><a href=#%e5%86%85%e8%81%94%e5%87%bd%e6%95%b0 class=header-anchor></a>内联函数</h3><ul><li>内联函数的合理使用可提高代码执行效率</li><li>当函数只有10行甚至更少时才将其定义为内联函数</li><li>谨慎对待析构函数，析构函数往往比其表面看起来要更长，因为有隐含的成员和基类析构函数被调用</li><li>包含循环和switch语句的函数内联通常得不偿失</li><li>声明了内联也不一定会被编译器内联，虚函数和递归函数不会被正常内联</li><li>类内部的函数一般会自动内联。所以某函数一旦不需要内联，其定义就不要再放在头文件里，而是放到对应的 cpp 文件里。这样可以保持头文件的类相当精炼，也很好地贯彻了声明与定义分离的原则。</li></ul><h3 id=范例><a href=#%e8%8c%83%e4%be%8b class=header-anchor></a>范例</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=cp>#pragma once
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// 头文件区
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include</span> <span class=cpf>&#34;CoreMinimal.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;UObject/ObjectMacros.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;UObject/UObjectBaseUtility.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;UObject/Object.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;TestObject.generated.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// 前置声明区
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>class</span> <span class=nc>AActor</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>AController</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>UPrimitiveComponent</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>FAttachedActorInfo</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 结构体定义
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>USTRUCT</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>FTestStruct</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>GENERATED_BODY</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>UPROPERTY</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>TestValue</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 委托定义
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 类体定义
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>UCLASS</span><span class=p>(</span><span class=n>BlueprintType</span><span class=p>,</span> <span class=n>Blueprintable</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>ATestObject</span> <span class=o>:</span> <span class=k>public</span> <span class=n>AActor</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>GENERATED_BODY</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>ATestObject</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=p>....</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 内联函数定义
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>...</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=作用域><a href=#%e4%bd%9c%e7%94%a8%e5%9f%9f class=header-anchor></a>作用域</h2><h3 id=命名空间><a href=#%e5%91%bd%e5%90%8d%e7%a9%ba%e9%97%b4 class=header-anchor></a>命名空间</h3><ul><li>命名空间将全局作用域细分为独立的, 具名的作用域, 可有效防止全局作用域的命名冲突。</li><li>禁止使用using namespace xxx;</li><li>禁止使用内联命名空间<div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=k>namespace</span> <span class=n>X</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>inline</span> <span class=k>namespace</span> <span class=n>Y</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>void</span> <span class=nf>foo</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>X::Y::foo与X::foo是等价的</li><li>内联命名空间主要用来保持跨版本的 ABI 兼容性。（一般用不到）</li><li>在头文件中使用匿名空间违背了C++的唯一定义原则（One Definition Rule（ODR））</li></ul></li></ul><h3 id=匿名命名空间和静态变量><a href=#%e5%8c%bf%e5%90%8d%e5%91%bd%e5%90%8d%e7%a9%ba%e9%97%b4%e5%92%8c%e9%9d%99%e6%80%81%e5%8f%98%e9%87%8f class=header-anchor></a>匿名命名空间和静态变量</h3><ul><li>内部链接性<ul><li>意味着你在这个文件中声明的这些标识符都不能在另一个文件中被访问。即使两个文件声明了完全一样名字的标识符，它们所指向的实体实际上是完全不同的。</li></ul></li><li>在 .cpp 文件中定义一个不需要被外部引用的变量时，可以将它们放在匿名命名空间或声明为 <code>static</code> 。</li><li>不需要被外部引用的变量</li><li>不要在头文件中使用</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=n>xxx</span><span class=p>.</span><span class=n>cpp</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>namespace</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>xxx</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>int</span> <span class=n>xxx</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=局部变量><a href=#%e5%b1%80%e9%83%a8%e5%8f%98%e9%87%8f class=header-anchor></a>局部变量</h3><ul><li><p>函数变量尽可能置于最小作用域，并在变量声明时进行初始化</p><ul><li>离第一次使用越近越好，方便阅读者更容易定位变量声明的位置</li><li>局部变量在声明的同时进行显式值初始化，比起隐式初始化再赋值的两步过程要高效，同时也贯彻了计算机体系结构重要的概念「局部性（locality）」。</li><li>对象：循环作用域外声明要高效的多</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>i</span> <span class=o>=</span> <span class=n>f</span><span class=p>();</span> <span class=c1>// 坏——初始化和声明分离
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=n>g</span><span class=p>();</span> <span class=c1>// 好——初始化时声明
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>v</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>v</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span> <span class=c1>// 用花括号初始化更好
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>v</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>v</span> <span class=o>=</span> <span class=p>{</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>};</span> <span class=c1>// 好——v 一开始就初始化
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 低效的实现
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>1000000</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span> <span class=n>f</span><span class=p>;</span> <span class=c1>// 构造函数和析构函数分别调用 1000000 次!
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>f</span><span class=p>.</span><span class=n>DoSomething</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Foo</span> <span class=n>f</span><span class=p>;</span> <span class=c1>// 构造函数和析构函数只调用 1 次
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=mi>1000000</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>f</span><span class=p>.</span><span class=n>DoSomething</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>属于 <code>if</code>, <code>while</code> 和 <code>for</code> 语句的变量应当在这些语句中正常地声明，这样子这些变量的作用域就被限制在这些语句中了，举例而言:</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=n>strchr</span><span class=p>(</span><span class=n>str</span><span class=p>,</span> <span class=sc>&#39;/&#39;</span><span class=p>))</span> <span class=n>str</span> <span class=o>=</span> <span class=n>p</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><h3 id=静态和全局变量><a href=#%e9%9d%99%e6%80%81%e5%92%8c%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f class=header-anchor></a>静态和全局变量</h3><ul><li>原生数据类型POD（Plain Old Data）<ul><li>Int, char, float等基本类型，POD类型的指针、数组、结构体</li></ul></li><li>静态生存周期变量<ul><li>全局变量，静态变量，静态类成员变量和函数静态变量</li></ul></li><li>禁止使用类的静态生存周期变量，因为在这种情况下构造和析构函数调用顺序是不确定的，他们会导致难以发现的bug。（对象A依赖对象B，但对象B早于A析构）</li><li>不允许用函数返回值来初始化POD变量，除非该函数不涉及任何全局变量（比如 <code>getenv()</code> 或 <code>getpid()</code> ）</li><li>函数的作用域内的静态变量除外，毕竟他们的初始化顺序是有明确定义，只会在指令执行到它的声明那里才会发生</li><li>同一个编译单元（cpp）内是明确的，静态初始化优先于动态初始化，初始化顺序按照声明顺序进行，销毁则逆序，不同编译单元之间的初始化和销毁顺序则属于未明确行为</li><li>quick_exit替代exit，前者不会执行任何析构，也不会执行atexit绑定的任何handlers</li><li>如果确实需要一个class类型的静态或全局变量，可以使用单例模式</li></ul><h2 id=类><a href=#%e7%b1%bb class=header-anchor></a>类</h2><h3 id=构造函数><a href=#%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0 class=header-anchor></a>构造函数</h3><ul><li>不要在构造函数中调用自身的虚函数，这类调用时不会重定向到子类的虚函数实现，即使现在没有被子类重载，将来也是隐患<ul><li>C++中的虚函数允许在运行时动态绑定，即在运行时根据实际对象的类型来确定调用哪个虚函数实现。这样的动态绑定是通过虚函数表（vtable）来实现的。在构造函数中调用虚函数时，由于对象尚未完全构造完成，可能会导致虚函数表指针尚未被正确初始化，从而导致无法正确调用虚函数的实现。</li><li>当虚函数在构造函数中被调用时，如果基类的构造函数中调用了虚函数，由于动态绑定机制，可能会调用派生类中未被构造完全的函数。这样可能会导致对象的状态不正确，甚至产生未定义的行为。</li><li><strong>应该尽量避免在构造函数中进行复杂的初始化逻辑，以保证对象正确地构造完成。</strong></li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=n>ABaseMonster</span><span class=o>::</span><span class=n>ABaseMonster</span><span class=p>(</span><span class=k>const</span> <span class=n>FObjectInitializer</span><span class=o>&amp;</span> <span class=n>ObjectInitializer</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>:</span> <span class=n>BornLocation</span><span class=p>(</span><span class=n>FVector</span><span class=o>::</span><span class=n>ZeroVector</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>,</span> <span class=n>bCanCrouch</span><span class=p>(</span><span class=nb>true</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>,</span> <span class=n>LocomotionComp</span><span class=p>(</span><span class=k>nullptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>AutoDestory</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SpawnedByWaveSpawner</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>MonsterLevel</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SpawnType</span> <span class=o>=</span> <span class=n>ETypeofSpawn</span><span class=o>::</span><span class=n>None</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>NetCullDistanceSquared</span> <span class=o>=</span> <span class=n>FMath</span><span class=o>::</span><span class=n>Square</span><span class=p>(</span><span class=mf>8000.f</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>AkForFoot</span> <span class=o>=</span> <span class=n>CreateDefaultSubobject</span><span class=o>&lt;</span><span class=n>UAkComponent</span><span class=o>&gt;</span><span class=p>(</span><span class=n>TEXT</span><span class=p>(</span><span class=s>&#34;AkForFoot&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=n>AkForFoot</span><span class=o>-&gt;</span><span class=n>SetupAttachment</span><span class=p>(</span><span class=n>RootComponent</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>AkForFoot</span><span class=o>-&gt;</span><span class=n>PrimaryComponentTick</span><span class=p>.</span><span class=n>bAllowTickOnDedicatedServer</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>WeaponComponent</span> <span class=o>=</span> <span class=n>CreateDefaultSubobject</span><span class=o>&lt;</span><span class=n>UStarsWeaponComponent</span><span class=o>&gt;</span><span class=p>(</span><span class=n>TEXT</span><span class=p>(</span><span class=s>&#34;WeaponComponent&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>SetCollisionEnabled</span><span class=p>(</span><span class=nb>false</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>USkeletalMeshComponent</span><span class=o>*</span> <span class=n>SKMesh</span> <span class=o>=</span> <span class=n>GetMesh</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>       <span class=c1>//SKMesh-&gt;VisibilityBasedAnimTickOption = EVisibilityBasedAnimTickOption::OnlyTickPoseWhenRendered;
</span></span></span><span class=line><span class=cl><span class=c1></span>       <span class=c1>//SKMesh-&gt;bEnableUpdateRateOptimizations = true;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>AttributeManagerComponent</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>       <span class=n>AttributeManagerComponent</span><span class=o>-&gt;</span><span class=n>SetOwnerType</span><span class=p>(</span><span class=n>EAttributeOwnerType</span><span class=o>::</span><span class=n>Monster</span><span class=p>);</span>
</span></span><span class=line><span class=cl>       <span class=n>SetTeamID</span><span class=p>(</span><span class=n>FGenericTeamId</span><span class=p>((</span><span class=n>uint8</span><span class=p>)</span><span class=n>EFactionType</span><span class=o>::</span><span class=n>MonsterFac</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>RespawnRate</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>bBeingCaptured</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>构造函数内不要调类似初始化的函数，因为初始化理论上会失败，如果执行失败返回了一个初始化失败的对象，后续怎么使用该对象是比较奇怪的</li></ul><h3 id=隐式类型变换><a href=#%e9%9a%90%e5%bc%8f%e7%b1%bb%e5%9e%8b%e5%8f%98%e6%8d%a2 class=header-anchor></a>隐式类型变换</h3><ul><li>不要定义隐式类型变换，对于转换运算符和单参数构造函数, 请使用 <code>explicit</code> 关键字</li><li>隐式类型转换会隐藏类型不匹配的错误. 有时, 目的类型并不符合用户的期望, 甚至用户根本没有意识到发生了类型转换.</li><li>隐式类型转换会让代码难以阅读, 尤其是在有函数重载的时候, 因为这时很难判断到底是哪个函数被调用.</li></ul><h3 id=可拷贝类型和可移动类型><a href=#%e5%8f%af%e6%8b%b7%e8%b4%9d%e7%b1%bb%e5%9e%8b%e5%92%8c%e5%8f%af%e7%a7%bb%e5%8a%a8%e7%b1%bb%e5%9e%8b class=header-anchor></a>可拷贝类型和可移动类型</h3><ul><li>如果需要显式定义拷贝和移动，否则就把隐式产生的拷贝和移动函数禁掉</li><li>如果需要就让你的类型可拷贝 / 可移动. 作为一个经验法则, 如果对于你的用户来说这个拷贝操作不是一眼就能看出来的, 那就不要把类型设置为可拷贝. 如果让类型可拷贝, 一定要同时给出拷贝构造函数和赋值操作的定义, 反之亦然. 如果让类型可移动, 同时移动操作的效率高于拷贝操作, 那么就把移动的两个操作 (移动构造函数和赋值操作) 也给出定义. 如果类型不可拷贝, 但是移动操作的正确性对用户显然可见, 那么把这个类型设置为只可移动并定义移动的两个操作</li><li>如果定义了拷贝/移动操作, 则要保证这些操作的默认实现是正确的. 记得时刻检查默认操作的正确性, 并且在文档中说明类是可拷贝的且/或可移动的</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=k>class</span> <span class=nc>Foo</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Foo</span><span class=p>(</span><span class=n>Foo</span><span class=o>&amp;&amp;</span> <span class=n>other</span><span class=p>)</span> <span class=o>:</span> <span class=n>field_</span><span class=p>(</span><span class=n>other</span><span class=p>.</span><span class=n>field</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 差, 只定义了移动构造函数, 而没有定义对应的赋值运算符.
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Field</span> <span class=n>field_</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>如果你的类不需要拷贝 / 移动操作, 请显式地通过在 <code>public</code> 域中使用 <code>= delete</code> 或其他手段禁用之.</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=c1>// MyClass is neither copyable nor movable.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>MyClass</span><span class=p>(</span><span class=k>const</span> <span class=n>MyClass</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>MyClass</span><span class=o>&amp;</span> <span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>MyClass</span><span class=o>&amp;</span><span class=p>)</span> <span class=o>=</span> <span class=k>delete</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=继承><a href=#%e7%bb%a7%e6%89%bf class=header-anchor></a>继承</h3><ul><li>析构函数，虚函数</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=k>class</span> <span class=nc>A</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>A</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>A</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>delete</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>p</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;A::~A()&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span><span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>B</span> <span class=o>:</span> <span class=k>public</span> <span class=n>A</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>B</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>xx</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>(</span><span class=mi>6</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>B</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>xx</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>delete</span> <span class=n>xx</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>xx</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;B::~B()&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl><span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span><span class=o>*</span> <span class=n>xx</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>B</span> <span class=n>b</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=多重继承><a href=#%e5%a4%9a%e9%87%8d%e7%bb%a7%e6%89%bf class=header-anchor></a>多重继承</h3><ul><li><p>最多只有一个基类是非抽象类，其他基类都是纯接口类</p></li><li><p>菱形继承？？通常意味着设计出了问题</p></li></ul><h3 id=接口><a href=#%e6%8e%a5%e5%8f%a3 class=header-anchor></a>接口</h3><ul><li><p>C++接口</p></li><li><p>蓝图接口</p><ul><li><p>BlueprintImplementableEvent</p></li><li><p>BlueprintNativeEvent</p></li></ul></li></ul><h3 id=运算符重载><a href=#%e8%bf%90%e7%ae%97%e7%ac%a6%e9%87%8d%e8%bd%bd class=header-anchor></a>运算符重载</h3><ul><li>运算符重载会混淆视听，让人误以为耗时的操作和操作内建类型一样轻巧</li></ul><h3 id=成员变量><a href=#%e6%88%90%e5%91%98%e5%8f%98%e9%87%8f class=header-anchor></a>成员变量</h3><p>一般不建议把成员变量标记为<code>public</code>，接口变更时更容易出现遗漏。</p><p>并且一个<code>public</code>的变量，对象自身对其更难以控制，不利于约束其读写行为。</p><p>考虑为其增加<code>public</code>的<code>Set</code>与<code>Get</code>相关接口来实现对其的操作。</p><p>比如如下例子：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=n>FString</span> <span class=n>SaveKey</span> <span class=o>=</span> <span class=n>StarsSaveGame</span><span class=o>-&gt;</span><span class=n>OverrideSaveKey</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>SaveKey</span><span class=p>.</span><span class=n>IsEmpty</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>SaveKey</span> <span class=o>=</span> <span class=n>Class</span><span class=o>-&gt;</span><span class=n>GetName</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>如果调用者错误使用了<code>FString& SaveKey = StarsSaveGame->OverrideSaveKey</code>，那么就会错误修改成员变量。</p><p>如果改成函数的返回则没有这种隐患，会在编译器得到警告：</p><blockquote><p>Binding r-value to l-value reference is non-standard Microsoft C++ extension</p></blockquote><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=n>FString</span><span class=o>&amp;</span> <span class=n>SaveKey</span> <span class=o>=</span> <span class=n>StarsSaveGame</span><span class=o>-&gt;</span><span class=n>GetOverrideSaveKey</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>SaveKey</span><span class=p>.</span><span class=n>IsEmpty</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>SaveKey</span> <span class=o>=</span> <span class=n>Class</span><span class=o>-&gt;</span><span class=n>GetName</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=结构体><a href=#%e7%bb%93%e6%9e%84%e4%bd%93 class=header-anchor></a>结构体</h2><h3 id=成员变量初始化><a href=#%e6%88%90%e5%91%98%e5%8f%98%e9%87%8f%e5%88%9d%e5%a7%8b%e5%8c%96 class=header-anchor></a>成员变量初始化</h3><p>如下：用到的指针一定要进行初始化，在栈上创建结构体时，指针并不会被UE初始化，会造成野指针</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=n>USTRUCT</span><span class=p>(</span><span class=n>BlueprintType</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>FDeathInfo</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>GENERATED_BODY</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>UPROPERTY</span><span class=p>(</span><span class=n>BlueprintReadOnly</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>EDeadCauserType</span> <span class=n>DeadCauserType</span> <span class=o>=</span> <span class=n>EDeadCauserType</span><span class=o>::</span><span class=n>Common</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/** 击杀者 */</span>
</span></span><span class=line><span class=cl>    <span class=n>UPROPERTY</span><span class=p>(</span><span class=n>BlueprintReadOnly</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>AActor</span><span class=o>*</span> <span class=n>Killer</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/** 被击杀者 */</span>
</span></span><span class=line><span class=cl>    <span class=n>UPROPERTY</span><span class=p>(</span><span class=n>BlueprintReadOnly</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>AActor</span><span class=o>*</span> <span class=n>Victim</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=枚举><a href=#%e6%9e%9a%e4%b8%be class=header-anchor></a>枚举</h2><p>如果枚举值需要暴露给蓝图，那么他需要在<code>uint8</code>范围内，否则在一些时候会有超出预期的问题。</p><p>如果想要大数值的枚举，又不想在蓝图中直接写死数值，可以考虑使用<code>FName</code>来与之对应，推荐使用表格维护。</p><h3 id=枚举值类型><a href=#%e6%9e%9a%e4%b8%be%e5%80%bc%e7%b1%bb%e5%9e%8b class=header-anchor></a>枚举值类型</h3><p>枚举值应使用<code>enum class</code>定义并标识所使用的存储结构，而不应该直接使用<code>enum</code>。</p><h4 id=枚举值类型理由><a href=#%e6%9e%9a%e4%b8%be%e5%80%bc%e7%b1%bb%e5%9e%8b%e7%90%86%e7%94%b1 class=header-anchor></a>枚举值类型理由</h4><p><code>enum</code>无法指定底层所使用的数据类型。同一<code>enum</code>的存储结构在不同的编译器下可能不同，有的时候会造成代码的泛用性降低。改为<code>enum class</code>后，可以指定具体的存储结构，使得开发者对其结构更为可控。</p><p><code>enum</code>存在向整形的隐式转换。隐式转换在一些时候虽然方便了开发者调用，但在错误复制或编码时没有明确的报错，因此不建议使用隐式转换。改为<code>enum class</code>后，如果需要进行转换可以使用<code>static_cast</code>来显式转换。</p><p><code>enum</code>无法定义重名。<code>enum</code>为了解决这个问题一般需要在枚举值命名中加入类型名，从而导致在一些情境下枚举值较长。而<code>enum class</code>没有这种问题，可以按照设计的枚举值进行命名。</p><h3 id=枚举值命名><a href=#%e6%9e%9a%e4%b8%be%e5%80%bc%e5%91%bd%e5%90%8d class=header-anchor></a>枚举值命名</h3><p>枚举值类型命名为以E开头，如<code>EUnitClientType</code>，即使不暴露给蓝图也可以遵循此规范。</p><p>因为枚举值常常直接拿出值用作比较，使用此规范可以区分出枚举值和普通的类型，也方便代码补全工具查找指定枚举。</p><h3 id=枚举值顺序><a href=#%e6%9e%9a%e4%b8%be%e5%80%bc%e9%a1%ba%e5%ba%8f class=header-anchor></a>枚举值顺序</h3><p>除非明确地知道修改顺序不会产生影响，否则不要修改枚举的顺序，有可能造成逻辑或者数据不兼容。</p><p>若枚举值的顺序不应被修改（一般是在配置表或其他逻辑中有调用），考虑用<code>=</code>写出其枚举值。</p><p>若枚举值无固定值，则可以默认视为枚举值顺序改变不影响逻辑。</p><h3 id=枚举值举例><a href=#%e6%9e%9a%e4%b8%be%e5%80%bc%e4%b8%be%e4%be%8b class=header-anchor></a>枚举值举例</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=k>enum</span> <span class=k>class</span> <span class=nc>EGameType</span> <span class=o>:</span> <span class=n>uint8</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>None</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>Local</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>Multiple</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=异常><a href=#%e5%bc%82%e5%b8%b8 class=header-anchor></a>异常</h2><p>要注重异常处理，对于有可能报错的函数，可以考虑增加bool的返回值来标识是否正常处理。</p><p>如果有可能有多种错误，建议返回错误码来标识错误类型。</p><h3 id=错误码><a href=#%e9%94%99%e8%af%af%e7%a0%81 class=header-anchor></a>错误码</h3><p>使用<code>EErrorId</code>的枚举来表示错误码。</p><p>避免在逻辑中直接写死<code>int32</code>的错误值，在<code>C++</code>中使用错误码，在蓝图或者<code>Lua</code>中使用<code>FName</code>。</p><p>可以使用<code>UErrorIdLibrary</code>中的函数从<code>枚举</code>/<code>int32</code>/<code>FName</code>之间转换。</p><p>判断一个<code>int32</code>是否是<code>OK</code>可以使用<code>UErrorLibrary::IsErrorIdOK</code>。</p><p>判断一个<code>in32</code>是否是指定枚举需要将枚举转为<code>int32</code>判断。</p><p>避免<code>int32</code>转为枚举来判断，有可能出现不是一个合法的枚举而产生非预期结果。</p><h2 id=函数><a href=#%e5%87%bd%e6%95%b0 class=header-anchor></a>函数</h2><h3 id=输入和输出><a href=#%e8%be%93%e5%85%a5%e5%92%8c%e8%be%93%e5%87%ba class=header-anchor></a>输入和输出</h3><ul><li><p>按值返回，否则按引用返回。避免返回指针，除非它可以为空。</p></li><li><p>输入参数放在所有输出参数之前。</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>TestFunction</span><span class=p>(</span><span class=kt>int</span> <span class=n>p1</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>p2</span><span class=p>,</span> <span class=k>const</span> <span class=n>FString</span><span class=o>&amp;</span> <span class=n>p3</span><span class=p>,</span> <span class=kt>bool</span><span class=o>&amp;</span> <span class=n>bOutResult1</span><span class=p>,</span> <span class=n>FString</span><span class=o>&amp;</span> <span class=n>OutResult2</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=编写简短函数><a href=#%e7%bc%96%e5%86%99%e7%ae%80%e7%9f%ad%e5%87%bd%e6%95%b0 class=header-anchor></a>编写简短函数</h3><ul><li><p>如果函数特别长，应思考在不影响程序结构的前提下对其进行分割</p></li><li><p>编译器优化一方面是消除常用的子表达式。而函数越大，编译器进行辨识的工作量就越大。从而导致编译时间大大增长。</p></li></ul><h3 id=常量正确性><a href=#%e5%b8%b8%e9%87%8f%e6%ad%a3%e7%a1%ae%e6%80%a7 class=header-anchor></a>常量正确性</h3><ul><li>不要直接进行值传递，避免一次内存拷贝，传递const引用参数</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=c1>// 差 - 返回常量数组
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=n>TArray</span><span class=o>&lt;</span><span class=n>FString</span><span class=o>&gt;</span> <span class=n>GetSomeArray</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 优 - 返回常量数组的引用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>const</span> <span class=n>TArray</span><span class=o>&lt;</span><span class=n>FString</span><span class=o>&gt;&amp;</span> <span class=n>GetSomeArray</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 差 - 传递数组
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>TestSomething</span><span class=p>(</span><span class=n>TArray</span><span class=o>&lt;</span><span class=n>FString</span><span class=o>&gt;</span> <span class=n>StringArray</span><span class=p>)</span> <span class=p>{...}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 优 - 传递常引用数组（避免一次内存拷贝）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>TestSomething</span><span class=p>(</span><span class=k>const</span> <span class=n>TArray</span><span class=o>&lt;</span><span class=n>FString</span><span class=o>&gt;&amp;</span> <span class=n>StringArray</span><span class=p>)</span> <span class=p>{...}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 优 - 移动语义（避免一次内存拷贝）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>TestSomething</span><span class=p>(</span><span class=n>TArray</span><span class=o>&lt;</span><span class=n>FString</span><span class=o>&gt;&amp;&amp;</span> <span class=n>StringArray</span><span class=p>)</span> <span class=p>{...}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><p>若方法不修改对象，将函数标记为常量函数</p><ul><li><p>常量成员函数承诺不会修改类的成员变量，提高代码的安全性，防止意外的数据修改和潜在错误。</p></li><li><p>代码逻辑更清晰，一眼就能看出这是个只读函数</p></li><li><p>给编译器优化空间</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=kt>void</span> <span class=n>FThing</span><span class=o>::</span><span class=n>SomeNonMutatingOperation</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 若此代码在FThing上被调用，其不会修改FThing
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>游戏中的例子：如果PrintAIData函数定位为const，则我们立马能确认函数体内的AIDataPack成员变量进行的都是只读操作，否则还要去判断是否有写入操作。</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=kt>void</span> <span class=n>ABaseMonster</span><span class=o>::</span><span class=n>PrintAIData</span><span class=p>(</span><span class=n>FString</span><span class=o>&amp;</span> <span class=n>CompName</span><span class=p>,</span> <span class=n>FString</span><span class=o>&amp;</span> <span class=n>TreeDescName</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>TArray</span><span class=o>&lt;</span><span class=n>FString</span><span class=o>&gt;&amp;</span> <span class=n>BBLine</span><span class=p>)</span> <span class=k>const</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*if (AIDataPack.ComponmentName.IsEmpty())
</span></span></span><span class=line><span class=cl><span class=cm>       return;*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>CompName</span> <span class=o>=</span> <span class=n>AIDataPack</span><span class=p>.</span><span class=n>ComponmentName</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>TreeDescName</span> <span class=o>=</span> <span class=n>AIDataPack</span><span class=p>.</span><span class=n>TreeDescription</span><span class=p>;</span>              
</span></span><span class=line><span class=cl>    <span class=n>AIDataPack</span><span class=p>.</span><span class=n>BlackboardDescription</span><span class=p>.</span><span class=n>ParseIntoArrayLines</span><span class=p>(</span><span class=n>BBLine</span><span class=p>,</span> <span class=nb>true</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>MARK_DIRTY</span><span class=err>？？</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>若循环不修改容器，则在容器上使用常量迭代</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=n>TArray</span><span class=o>&lt;</span><span class=n>FString</span><span class=o>&gt;</span> <span class=n>StringArray</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=n>FString</span><span class=o>&amp;</span> <span class=nl>Str</span> <span class=p>:</span> <span class=n>StringArray</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 此循环的主体不会修改StringArray
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=函数重载><a href=#%e5%87%bd%e6%95%b0%e9%87%8d%e8%bd%bd class=header-anchor></a>函数重载</h3><ul><li>若要使用函数重载, 则必须能让读者一看调用点就胸有成竹, 而不用花心思猜测调用的重载函数到底是哪一种. 这一规则也适用于构造函数</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=k>class</span> <span class=nc>MyClass</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=n>Analyze</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span> <span class=o>&amp;</span><span class=n>text</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Analyze</span><span class=p>(</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=n>text</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>textlen</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>如果函数单靠不同的参数类型而重载 (这意味着参数数量不变), 读者就得十分熟悉 C++ 五花八门的匹配规则, 以了解匹配过程具体到底如何。另外，如果派生类只重载了某个函数的部分变体，继承语义就容易令人困惑。</li></ul><h3 id=缺省参数><a href=#%e7%bc%ba%e7%9c%81%e5%8f%82%e6%95%b0 class=header-anchor></a>缺省参数</h3><ul><li><p>缺省参数实际上是函数重载语义的另一种实现方式</p></li><li><p>对于子类继承的虚函数，不允许使用缺省参数</p><ul><li><p>虚函数是动态绑定，而缺省参数值是静态绑定。即虚函数是运行时确定类型，而缺省参数值是编译时就确定的。</p></li><li><p>如果重新定义的话，会使得程序使用基类虚函数的默认参数，这显然并不是你想要的结果。</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Shape</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>enum</span> <span class=nc>Color</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>Red</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=n>Green</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                <span class=n>Blue</span><span class=p>,</span>
</span></span><span class=line><span class=cl>        <span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>draw</span><span class=p>(</span><span class=n>Color</span> <span class=n>color</span> <span class=o>=</span> <span class=n>Red</span><span class=p>)</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>static</span> <span class=n>std</span><span class=o>::</span><span class=n>string</span> <span class=n>ColorToString</span><span class=p>(</span><span class=n>Color</span> <span class=n>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>switch</span> <span class=p>(</span><span class=n>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>case</span> <span class=nl>Red</span><span class=p>:</span> <span class=k>return</span> <span class=s>&#34;Red&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>case</span> <span class=nl>Green</span><span class=p>:</span> <span class=k>return</span> <span class=s>&#34;Green&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>case</span> <span class=nl>Blue</span><span class=p>:</span> <span class=k>return</span> <span class=s>&#34;Blue&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>default</span><span class=o>:</span> <span class=k>return</span> <span class=s>&#34;&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Rectangle</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Shape</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>virtual</span> <span class=kt>void</span> <span class=n>draw</span><span class=p>(</span><span class=n>Color</span> <span class=n>color</span> <span class=o>=</span> <span class=n>Green</span><span class=p>)</span> <span class=k>override</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Rectangle : &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>ColorToString</span><span class=p>(</span><span class=n>color</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Circle</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Shape</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>virtual</span> <span class=kt>void</span> <span class=n>draw</span><span class=p>(</span><span class=n>Color</span> <span class=n>color</span><span class=p>)</span> <span class=k>override</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Circle : &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>ColorToString</span><span class=p>(</span><span class=n>color</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Rectangle</span> <span class=n>R</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>Circle</span> <span class=n>C</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>R</span><span class=p>.</span><span class=n>draw</span><span class=p>();</span>  <span class=c1>//输出：Rectangle : Green
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>//C.draw(); //报错，静态绑定无法继承默认参数
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>        <span class=n>Shape</span><span class=o>*</span> <span class=n>pr</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>R</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>Shape</span><span class=o>*</span> <span class=n>pc</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>C</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>pr</span><span class=o>-&gt;</span><span class=n>draw</span><span class=p>(</span><span class=n>Shape</span><span class=o>::</span><span class=n>Blue</span><span class=p>);</span>  <span class=c1>//输出：Rectangle : Blue
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>pc</span><span class=o>-&gt;</span><span class=n>draw</span><span class=p>(</span><span class=n>Shape</span><span class=o>::</span><span class=n>Blue</span><span class=p>);</span>  <span class=c1>//输出：Circle : Blue
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>        <span class=c1>// 静态绑定，使用基类的默认参数，完成派生类的动作
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>pr</span><span class=o>-&gt;</span><span class=n>draw</span><span class=p>();</span>        <span class=c1>//输出：Rectangle : Red
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>pc</span><span class=o>-&gt;</span><span class=n>draw</span><span class=p>();</span>        <span class=c1>//输出：Circle : Red
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><h3 id=lambda表达式><a href=#lambda%e8%a1%a8%e8%be%be%e5%bc%8f class=header-anchor></a>Lambda表达式</h3><ul><li><p>不要使用默认捕获（=, &），所有变量捕获都显式写出来</p><ul><li>非异步的lambda表达式除外，例如：Foreach之类的</li></ul></li><li><p>异步回调Lambda表达式捕获局部变量</p></li><li><p>Lambda不要捕获UObject裸指针</p><ul><li><p>如果再等待异步回调执行之前，捕获的UObject裸指针已被GC且在原来的内存上又分配了新的UObject</p></li><li><p>如果此时在回调中对该过期了的UObject进行写入，则相当于在一个未知的内存上写入，可能把新的UObject写坏了。</p></li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=c1>// 异步回调的情况
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>UStarsAssetsManager</span><span class=o>::</span><span class=n>Instance</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>AsyncLoad</span><span class=p>(</span><span class=k>this</span><span class=p>,</span> <span class=n>MeshInfo</span><span class=p>.</span><span class=n>MeshPath</span><span class=p>,</span> <span class=k>this</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=p>[</span><span class=n>WeakThis</span><span class=p>,</span> <span class=n>CallBack</span><span class=p>,</span> <span class=n>CompPtr</span><span class=p>,</span> <span class=n>MeshInfo</span><span class=p>,</span> <span class=n>WithCollision</span><span class=p>](</span><span class=k>const</span> <span class=n>FSoftObjectPath</span><span class=o>&amp;</span> <span class=n>ObjectPath</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>CompPtr</span><span class=p>.</span><span class=n>IsValid</span><span class=p>()</span> <span class=o>||</span> <span class=o>!</span><span class=n>WeakThis</span><span class=p>.</span><span class=n>IsValid</span><span class=p>())</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>...</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 非异步的情况
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>SpecialElementNames</span><span class=p>.</span><span class=n>Empty</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>ForeachRow</span><span class=o>&lt;</span><span class=n>FSpecialElementTableRow</span><span class=o>&gt;</span><span class=p>([</span><span class=o>&amp;</span><span class=p>](</span><span class=k>const</span> <span class=n>FName</span><span class=o>&amp;</span> <span class=n>RowName</span><span class=p>,</span> <span class=k>const</span> <span class=n>FSpecialElementTableRow</span><span class=o>&amp;</span> <span class=n>Row</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>       <span class=n>SpecialElementNames</span><span class=p>.</span><span class=n>Emplace</span><span class=p>(</span><span class=n>Row</span><span class=p>.</span><span class=n>Type</span><span class=p>,</span> <span class=n>RowName</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=配置><a href=#%e9%85%8d%e7%bd%ae class=header-anchor></a>配置</h2><ul><li><p>使用<code>UDataManger</code>来管理所有表格</p></li><li><p>需要使用<code>StarsGetDataTable</code>等接口来读表，禁止使用UE自带的表格读取</p><ul><li>我们会对同结构表格在读取时进行合并处理</li></ul></li><li><p>考虑热更配置的需求，谨慎对配置进行缓存，优先考虑以<code>RowName</code>去查表。</p></li></ul><h2 id=回调><a href=#%e5%9b%9e%e8%b0%83 class=header-anchor></a>回调</h2><ul><li><p>谨慎使用回调，尤其需要注意是否存在跨帧逻辑与递归逻辑。</p></li><li><p>谨慎缓存Delegate，有可能会使得闭包异常。</p><ul><li>比如在Delegate的回调中，修改了这个Delegate，那么捕获的变量会存在异常。</li></ul></li></ul><h2 id=标准库><a href=#%e6%a0%87%e5%87%86%e5%ba%93 class=header-anchor></a>标准库</h2><p>UE有自己的一套模板库，大部分情况下应该使用UE，下面是可以在UE中使用的标准库。</p><div class=table-wrapper><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><atomic></td><td>应在新代码中使用，在迁移旧代码时也应该使用。原子性（Atomic）将在所有受支持平台上高效推广。 <code>TAtomic</code> 仅实现了部分功能，Epic后续也不会继续进行维护和改善。</td></tr><tr><td>&lt;type_traits></td><td>应在旧版UE特性（trait）和标准特性重叠的地方使用。</td></tr><tr><td>&lt;initializer_list></td><td>用于支持初始化器（initializer）语法</td></tr><tr><td><regex></td><td>正则表达式，UE没有自己的正则表达式方案</td></tr><tr><td><limits></td><td><code>std::numeric_limits</code> 可以完整使用。</td></tr><tr><td><cmath></td><td>这个头文件中只有浮点比较函数可以使用</td></tr></tbody></table></div><h2 id=排版与格式><a href=#%e6%8e%92%e7%89%88%e4%b8%8e%e6%a0%bc%e5%bc%8f class=header-anchor></a>排版与格式</h2><h3 id=命名相关><a href=#%e5%91%bd%e5%90%8d%e7%9b%b8%e5%85%b3 class=header-anchor></a>命名相关</h3><ul><li><p>命名（如类型或变量）中的每个单词需大写首字母，单词间通常无下划线。例如：<code>Health</code> 和 <code>UPrimitiveComponent</code>，而非 <code>lastMouseCoordinates</code> 或 <code>delta_coordinates</code>。</p></li><li><p>类型名前缀需使用额外的大写字母，用于区分其和变量命名。例如：<code>FSkin</code> 为类型名，而 <code>Skin</code> 则是 <code>FSkin</code> 的实例。</p></li><li><p>模板类的前缀为T。</p></li><li><p>继承自 <code>UObject</code> 的类前缀为U。</p></li><li><p>继承自 <code>AActor</code> 的类前缀为A。</p></li><li><p>继承自 <code>SWidget</code> 的类前缀为S。</p></li><li><p>接口的前缀为I。</p></li><li><p>枚举的前缀为E。</p></li><li><p>布尔变量必须以b为前缀（例如 <code>bPendingDestruction</code> 或 <code>bHasFadedIn</code>）。</p></li><li><p>其他多数类均以F为前缀，而部分子系统则以其他字母为前缀。</p></li><li><p>Typedefs应以任何与其类型相符的字母为前缀：若为结构体的Typedefs，则使用F；若为 <code>Uobject</code> 的Typedefs，则使用U，以此类推。</p><ul><li>特别模板实例化的Typedef不再是模板，并应加上相应前缀，例如：</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=k>typedef</span> <span class=n>TArray</span><span class=o>&lt;</span><span class=n>FMytype</span><span class=o>&gt;</span> <span class=n>FArrayOfMyTypes</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>即使不暴露给蓝图，也可以遵循此命名规范以适应UE的规范。</p></li><li><p>类型和变量的命名为名词。</p></li><li><p>方法名是动词，以描述方法的效果或未被方法影响的返回值。</p></li><li><p>所有返回布尔的函数应发起true/false的询问，如<code>IsVisible()或ShouldClearBuffer()</code>。</p></li><li><p>若函数参数通过引用传递，同时该值会写入函数，建议以"Out"做为函数参数命名的前缀（非必需）。此操作将明确表明传入该参数的值将被函数替换。</p></li><li><p>若In或Out参数同样为布尔，以b作为In/Out的前缀，如 <code>bOutResult</code>。</p></li><li><p>返回值的函数应描述返回的值.命名应说明函数将返回的值。此规则对布尔函数极为重要。请参考以下两个范例方法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=c1>// True的意义是什么？
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>bool</span> <span class=nf>CheckTea</span><span class=p>(</span><span class=n>FTea</span> <span class=n>Tea</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 命名明确说明茶是新鲜的
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>bool</span> <span class=nf>IsTeaFresh</span><span class=p>(</span><span class=n>FTea</span> <span class=n>Tea</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>对于缩写单词，推荐仍然使用首字母大写其余小写的格式</p><ul><li><p>可以避免陷入什么是缩写什么不是的争议中</p><ul><li>PHP->Php</li></ul></li><li><p>对于复杂变量名可以获得更清晰的展示</p><ul><li>如HTTPSubsystem->HttpSubsystem</li></ul></li><li><p>UE内部变量两者都有，以仅大写首字母为主</p></li></ul></li><li><p>命名范例</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=kt>float</span> <span class=n>TeaWeight</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>int32</span> <span class=n>TeaCount</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>bDoesTeaStink</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>FName</span> <span class=n>TeaName</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>FString</span> <span class=n>TeaFriendlyName</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>UClass</span><span class=o>*</span> <span class=n>TeaClass</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>USoundCue</span><span class=o>*</span> <span class=n>TeaSound</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>UTexture</span><span class=o>*</span> <span class=n>TeaTexture</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>FPlayerIdentifier</span> <span class=n>PlayerId</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><h3 id=代码格式><a href=#%e4%bb%a3%e7%a0%81%e6%a0%bc%e5%bc%8f class=header-anchor></a>代码格式</h3><ul><li><p>一行不超过120个字符</p></li><li><p>尽量不使用非ASCII编码，文件编码必须为UTF-8</p></li><li><p>缩进使用制表位\t</p></li><li><p>大括号格式必须一致。在Epic的传统做法中，大括号固定被放在新行。请遵循此格式。</p></li><li><p>固定在单语句块中使用大括号。例如：</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>bThing</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>if-else语句中的所有执行块都应该使用大括号。此举是为防止编辑时出错——未使用大括号时，可能会意外地将另一行加入if块中。多余行不受if表达式控制，会成为较差代码。条件编译的项目导致if/else语句中断时，也会造成不良结果。因此务必使用大括号。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>bHaveUnrealLicense</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>InsertYourGameHere</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>else</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>CallMarkRein</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><p>switch语句</p><ul><li>一定有Default条件，其中包含有break，以防在默认条件后添加新的条件。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=k>switch</span> <span class=p>(</span><span class=n>condition</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=mi>1</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 落入
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>case</span> <span class=mi>2</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=mi>3</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=mi>4</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=mi>5</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=p>...</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><h2 id=注释><a href=#%e6%b3%a8%e9%87%8a class=header-anchor></a>注释</h2><h3 id=规范><a href=#%e8%a7%84%e8%8c%83 class=header-anchor></a>规范</h3><ul><li><p>无所谓英不英文，代码是项目组内的人看的，方便大家读懂就行</p></li><li><p>函数注释</p><ul><li><p>大概功能描述</p></li><li><p>各个参数的描述</p></li><li><p>返回值的描述</p></li><li><p><strong>其他信息</strong>：可选择使用 <code>@warning</code>、<code>@note</code>、<code>@see</code> 和 <code>@deprecated</code> 记载额外相关信息。此类注释应在其他注释后单列一行声明。</p></li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * @brief 判断所给定义的道具是否是确定的
</span></span></span><span class=line><span class=cl><span class=cm> *        比如如果是随机品质的定义，就不是确定的
</span></span></span><span class=line><span class=cl><span class=cm> * @param ItemDef 所需检查的物品定义
</span></span></span><span class=line><span class=cl><span class=cm> * @param CheckQualityNum 是否需要检查该道具是否仅有一个品质
</span></span></span><span class=line><span class=cl><span class=cm> *                        如果检查并且发现该道具仅有一个品质
</span></span></span><span class=line><span class=cl><span class=cm> *                        那么即使定义随机也会认为是唯一的
</span></span></span><span class=line><span class=cl><span class=cm> * @return 返回值的意义
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=n>UFUNCTION</span><span class=p>(</span><span class=n>BlueprintCallable</span><span class=p>,</span> <span class=n>Category</span><span class=o>=</span><span class=s>&#34;Item&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=kt>bool</span> <span class=n>IsItemDefCertain</span><span class=p>(</span><span class=k>const</span> <span class=n>FBagItemDef</span><span class=o>&amp;</span> <span class=n>ItemDef</span><span class=p>,</span> <span class=kt>bool</span> <span class=n>CheckQualityNum</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=原则><a href=#%e5%8e%9f%e5%88%99 class=header-anchor></a>原则</h3><ul><li>编写含义清晰的代码：</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=c1>// 错误示范：
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>t</span> <span class=o>=</span> <span class=n>s</span> <span class=o>+</span> <span class=n>l</span> <span class=o>-</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 正确示范：
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>TotalLeaves</span> <span class=o>=</span> <span class=n>SmallLeaves</span> <span class=o>+</span> <span class=n>LargeLeaves</span> <span class=o>-</span> <span class=n>SmallAndLargeLeaves</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>编写有用的注释：</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=c1>// 错误示范：
</span></span></span><span class=line><span class=cl><span class=c1>// increment Leaves
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>++</span><span class=n>Leaves</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 正确示范：
</span></span></span><span class=line><span class=cl><span class=c1>// we know there is another tea leaf
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>++</span><span class=n>Leaves</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>不要对低质量代码进行注释——重新编写这些代码：</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=c1>// 错误示范：
</span></span></span><span class=line><span class=cl><span class=c1>// total number of leaves is sum of
</span></span></span><span class=line><span class=cl><span class=c1>// small and large leaves less the
</span></span></span><span class=line><span class=cl><span class=c1>// number of leaves that are both
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>t</span> <span class=o>=</span> <span class=n>s</span> <span class=o>+</span> <span class=n>l</span> <span class=o>-</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 正确示范：
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>TotalLeaves</span> <span class=o>=</span> <span class=n>SmallLeaves</span> <span class=o>+</span> <span class=n>LargeLeaves</span> <span class=o>-</span> <span class=n>SmallAndLargeLeaves</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>不要让代码与注释自相矛盾：</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=c1>// 错误示范：
</span></span></span><span class=line><span class=cl><span class=c1>// never increment Leaves!
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>++</span><span class=n>Leaves</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 正确示范：
</span></span></span><span class=line><span class=cl><span class=c1>// we know there is another tea leaf
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>++</span><span class=n>Leaves</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=todo><a href=#todo class=header-anchor></a>TODO</h3><p>对那些临时的, 短期的解决方案, 或已经够好但仍不完美的代码使用 TODO 注释。</p><p>标记一些未完成的或完成的不尽如人意的地方, 这样一搜索, 就知道还有哪些活要干, 日志都省了。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=n>PriorityQueue</span><span class=p>.</span><span class=n>Num</span><span class=p>()</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>logger</span><span class=p>.</span><span class=n>CheckLoop</span><span class=p>((</span><span class=n>__FUNCTION__</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=c1>//取出优先队列头
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>auto</span><span class=o>&amp;</span> <span class=n>PopData</span> <span class=o>=</span> <span class=n>PriorityQueue</span><span class=p>.</span><span class=n>HeapTop</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 先判空一下，TODO: 后面查一下循环内销毁问题
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>PopData</span><span class=p>.</span><span class=n>SmeltComp</span><span class=p>.</span><span class=n>IsValid</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>       <span class=n>PriorityQueue</span><span class=p>.</span><span class=n>HeapPopDiscard</span><span class=p>(</span><span class=n>DataPredicate</span><span class=p>);</span>
</span></span><span class=line><span class=cl>       <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=其他相关><a href=#%e5%85%b6%e4%bb%96%e7%9b%b8%e5%85%b3 class=header-anchor></a>其他相关</h2><h3 id=sizeof><a href=#sizeof class=header-anchor></a>Sizeof</h3><ul><li><p>尽可能的使用sizeof(varname)代替sizeof(type)</p></li><li><p>假设varname的类型变了，sizeof(type)大概率会忘改造成bug</p></li></ul><h3 id=迭代器><a href=#%e8%bf%ad%e4%bb%a3%e5%99%a8 class=header-anchor></a>迭代器</h3><ul><li><p>前置自增效率更高，少了一次拷贝</p></li><li><p>迭代器失效的情况</p><ul><li><p>TArray</p><ul><li><p>增加导致的内存重分配</p></li><li><p>删除元素</p></li><li><p>插入元素</p></li></ul></li></ul></li></ul><h3 id=死循环><a href=#%e6%ad%bb%e5%be%aa%e7%8e%af class=header-anchor></a>死循环</h3><ul><li>无符号整数错误使用导致的死循环</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span> <span class=n>i</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>;</span> <span class=o>--</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span> <span class=p>...</span> <span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>容器的size()返回类型size_t是无符号整数</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>vec</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>vec</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=n>idx</span> <span class=o>=</span> <span class=n>vec</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=n>idx</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>idx</span><span class=o>--</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;===== </span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><p>while循环，条件永远不满足</p></li><li><p>死循环检查工具</p><ul><li><p>FDeadLockDetector</p><ul><li>死循环时崩掉并打印主线程堆栈</li></ul></li></ul></li></ul><h3 id=浮点数><a href=#%e6%b5%ae%e7%82%b9%e6%95%b0 class=header-anchor></a>浮点数</h3><ul><li>判断浮点数是否相等</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=kt>float</span> <span class=n>f</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>f</span> <span class=o>==</span> <span class=mf>0.2</span><span class=p>)</span> <span class=p>{}</span> <span class=c1>// 错误用法
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=p>(</span><span class=n>abs</span><span class=p>(</span><span class=n>f</span> <span class=o>-</span> <span class=mf>0.2</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mf>0.00001</span><span class=p>)</span> <span class=p>{}</span> <span class=c1>// 正确用法
</span></span></span></code></pre></td></tr></table></div></div><h3 id=stdvectorbool><a href=#stdvectorbool class=header-anchor></a>std::vector&lt;bool></h3><ul><li>尽量不要在vector中存放bool类型，vector为了做优化，它的内部存放的其实不是bool。</li><li></li></ul><h3 id=空指针><a href=#%e7%a9%ba%e6%8c%87%e9%92%88 class=header-anchor></a>空指针</h3><ul><li><p>空指针尽量使用nullptr而非NULL</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>func</span><span class=p>(</span><span class=kt>char</span><span class=o>*</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;char*&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>func</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;int&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>func</span><span class=p>(</span><span class=nb>NULL</span><span class=p>);</span> <span class=c1>// 编译失败 error: call of overloaded ‘func(NULL)’ is ambiguous
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>func</span><span class=p>(</span><span class=k>nullptr</span><span class=p>);</span> <span class=c1>// char*
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><h2 id=数值溢出><a href=#%e6%95%b0%e5%80%bc%e6%ba%a2%e5%87%ba class=header-anchor></a>数值溢出</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Plain data-lang=Plain><span class=line><span class=cl>const int32 RetryToken = FMath::RandRange(0, INT_MAX); // 这里会随机出负数
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>##RandRange 实现
</span></span><span class=line><span class=cl>static FORCEINLINE int32 RandRange(int32 Min, int32 Max)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>        const int32 Range = (Max - Min) + 1;        //INT_MAX的情况下，一定溢出
</span></span><span class=line><span class=cl>        return Min + RandHelper(Range);
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><h2 id=内存><a href=#%e5%86%85%e5%ad%98 class=header-anchor></a>内存</h2><h3 id=常见问题><a href=#%e5%b8%b8%e8%a7%81%e9%97%ae%e9%a2%98 class=header-anchor></a>常见问题</h3><ul><li><p>避免使用原生数组，尽量使用UE容器</p><ul><li>原生数组无法检查越界</li></ul></li><li><p>空指针未判空</p><ul><li><p>空指针导致的崩溃占大多数</p></li><li><p>防御性编程</p></li></ul></li><li><p>缓冲区溢出</p><ul><li><p>sprintf，printf，memcpy，memset，strcat，strcpy等等</p></li><li><p>上述函数拷贝内存的时候没有检查是否越界，如果发生越界会把其他不相干的内存写坏，导致无法预料的bug</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>foo</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>szName</span><span class=p>[</span><span class=mi>10</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>strcpy</span><span class=p>(</span><span class=n>szName</span><span class=p>,</span> <span class=s>&#34;asdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdf&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>返回局部引用</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=nf>foo</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>xxx</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=o>&amp;</span><span class=n>xxx</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>指针未初始化</p><ul><li><p>UObject成员带UPROPERTY，会被自动初始化为nullptr</p></li><li><p>普通指针未初始化，指向任意地址</p><ul><li>if判断已经无效，向野指针内写入数据</li></ul></li><li><p>注意：USTRUCT的指针成员就算带UPROPERTY也不会初始化位null</p></li></ul></li><li><p>不正确的类型转换</p><ul><li><p>使用C++的类型转换，避免C类型转换</p><ul><li><p>static_cast，不使用C类型转换</p></li><li><p>const_cast，去掉const限定符</p></li><li><p>reinterpret_cast，指针类型和整形或其他指针之间进行不安全的相互转换</p></li></ul></li><li><p>当程序执行不正确的类型转换时，就会发生不可预测的结果。这可能会导致程序崩溃写坏内存或产生不正确的输出。</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>num</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=o>*</span><span class=n>ptr</span> <span class=o>=</span> <span class=p>(</span><span class=kt>double</span><span class=o>*</span><span class=p>)</span><span class=o>&amp;</span><span class=n>num</span><span class=p>;</span> <span class=c1>// 不正确的类型转换
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>*</span><span class=n>ptr</span> <span class=o>=</span> <span class=mf>5.0</span><span class=p>;</span>    <span class=c1>// 写越界
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=o>*</span><span class=n>ptr</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>Memcpy, memset用于非POD类型，把vtable的指针给破坏掉了</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=k>class</span> <span class=nc>A</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>A</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>test</span><span class=p>()</span> <span class=p>{</span> <span class=n>printf</span><span class=p>(</span><span class=s>&#34;%d&#34;</span><span class=p>,</span> <span class=n>nn</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>nn</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>B</span> <span class=o>:</span> <span class=k>public</span> <span class=n>A</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>B</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=kt>void</span> <span class=nf>test</span><span class=p>()</span> <span class=k>override</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>A</span><span class=o>::</span><span class=n>test</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;B::test, %d&#34;</span><span class=p>,</span> <span class=n>nn</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>B</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>memset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>b</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>b</span><span class=p>));</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>函数内自销毁，导致后续代码访问或写入成员变量时写坏内存</p><ul><li><p>宠物切换状态会停掉行为树，而此函数在行为树Task节点中直接执行（Task内停掉行为树）</p></li><li><p>行为树Task节点尝试删掉行为树Owner的Actor（危险操作、应延迟一帧执行）</p></li><li><p>有自销毁操作时需小心，考虑清楚是否需要延迟一帧</p></li></ul></li><li><p>循环操作没有取引用，导致发生了结构体拷贝</p></li><li><p>Lambda表达式自销毁，内部引用的捕获变量被销毁后使用引发的内存问题</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=n>TWeakObjectPtr</span><span class=o>&lt;</span><span class=n>UWorldManager</span><span class=o>&gt;</span> <span class=n>thisObject</span><span class=p>(</span><span class=k>this</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>Stars</span><span class=o>::</span><span class=n>Message</span><span class=o>::</span><span class=n>PvpTrigger</span> <span class=n>triggerData</span> <span class=o>=</span> <span class=n>trigger</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>GetWorld</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>GetTimerManager</span><span class=p>().</span><span class=n>SetTimer</span><span class=p>(</span><span class=n>PvPingTimerHandle</span><span class=p>,</span> <span class=n>FTimerDelegate</span><span class=o>::</span><span class=n>CreateWeakLambda</span><span class=p>(</span><span class=k>this</span><span class=p>,</span> <span class=p>[</span><span class=n>thisObject</span><span class=p>,</span> <span class=n>triggerData</span><span class=p>](){</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>thisObject</span><span class=p>.</span><span class=n>IsValid</span><span class=p>())</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>thisObject</span><span class=o>-&gt;</span><span class=n>m_GuildManager</span><span class=o>==</span><span class=k>nullptr</span> <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>int32</span> <span class=n>DefenEndTime</span> <span class=o>=</span> <span class=n>AStarsGameState</span><span class=o>::</span><span class=n>GetWorldDayZeroTime</span><span class=p>(</span><span class=n>thisObject</span><span class=p>.</span><span class=n>Get</span><span class=p>())</span> <span class=o>+</span> <span class=n>triggerData</span><span class=p>.</span><span class=n>defendendtime</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>int32</span> <span class=n>worldTime</span> <span class=o>=</span> <span class=n>AStarsGameState</span><span class=o>::</span><span class=n>GetWorldTime</span><span class=p>(</span><span class=n>thisObject</span><span class=p>.</span><span class=n>Get</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>worldTime</span> <span class=o>&gt;</span> <span class=n>DefenEndTime</span> <span class=o>&amp;&amp;</span> <span class=n>thisObject</span><span class=o>-&gt;</span><span class=n>m_WorldInfo</span><span class=p>.</span><span class=n>PlanetPVPStatus</span> <span class=o>!=</span> <span class=n>EPlanetPVPStatus</span><span class=o>::</span><span class=n>None</span> <span class=o>&amp;&amp;</span> <span class=n>DefenEndTime</span> <span class=o>&gt;</span> <span class=mi>86400</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//防守结束
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>thisObject</span><span class=o>-&gt;</span><span class=n>m_WorldInfo</span><span class=p>.</span><span class=n>PlanetPVPStatus</span> <span class=o>=</span> <span class=n>EPlanetPVPStatus</span><span class=o>::</span><span class=n>None</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>thisObject</span><span class=o>-&gt;</span><span class=n>m_GuildManager</span><span class=o>-&gt;</span><span class=n>OnPlanetPVPStatusStart</span><span class=p>(</span><span class=n>EPlanetPVPStatus</span><span class=o>::</span><span class=n>None</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>thisObject</span><span class=o>-&gt;</span><span class=n>m_GuildManager</span><span class=o>-&gt;</span><span class=n>OnPvpBattleEnd</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>SetWorldInfomation</span><span class=p>(</span><span class=n>thisObject</span><span class=o>-&gt;</span><span class=n>m_WorldInfo</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>AStarsGameState</span><span class=o>::</span><span class=n>GetWorldIntTime</span><span class=p>(</span><span class=n>thisObject</span><span class=p>.</span><span class=n>Get</span><span class=p>())</span> <span class=o>&gt;=</span> <span class=n>triggerData</span><span class=p>.</span><span class=n>enttime</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//完全结束
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>thisObject</span><span class=o>-&gt;</span><span class=n>m_WorldInfo</span><span class=p>.</span><span class=n>PlanetPVPStatus</span><span class=o>=</span><span class=n>EPlanetPVPStatus</span><span class=o>::</span><span class=n>None</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>thisObject</span><span class=o>-&gt;</span><span class=n>m_WorldInfo</span><span class=p>.</span><span class=n>PVPStatusStartTime</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>thisObject</span><span class=o>-&gt;</span><span class=n>m_WorldInfo</span><span class=p>.</span><span class=n>PVPStatusEndTime</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>thisObject</span><span class=o>-&gt;</span><span class=n>m_WorldInfo</span><span class=p>.</span><span class=n>PVPDefenseStartTime</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>thisObject</span><span class=o>-&gt;</span><span class=n>m_WorldInfo</span><span class=p>.</span><span class=n>PVPDefenseEndTime</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>thisObject</span><span class=o>-&gt;</span><span class=n>m_WorldInfo</span><span class=p>.</span><span class=n>IsPlanetBattleStatues</span><span class=o>=</span><span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>thisObject</span><span class=o>-&gt;</span><span class=n>m_GuildManager</span><span class=o>-&gt;</span><span class=n>OnPlanetPVPStatusStart</span><span class=p>(</span><span class=n>EPlanetPVPStatus</span><span class=o>::</span><span class=n>None</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>thisObject</span><span class=o>-&gt;</span><span class=n>m_GuildManager</span><span class=o>-&gt;</span><span class=n>OnPVPBattleStateChanged</span><span class=p>(</span><span class=nb>false</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>thisObject</span><span class=o>-&gt;</span><span class=n>m_GuildManager</span><span class=o>-&gt;</span><span class=n>OnPvpBattleEnd</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 这里Lambda表达式被销毁，导致thisObject被销毁
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>thisObject</span><span class=o>-&gt;</span><span class=n>GetWorld</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>GetTimerManager</span><span class=p>().</span><span class=n>ClearTimer</span><span class=p>(</span><span class=n>thisObject</span><span class=o>-&gt;</span><span class=n>PvPingTimerHandle</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 好在这里是读内存不是写，没有造成更坏的情况        
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>SetWorldInfomation</span><span class=p>(</span><span class=n>thisObject</span><span class=o>-&gt;</span><span class=n>m_WorldInfo</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}),</span> <span class=mi>1</span><span class=p>,</span> <span class=nb>true</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><h3 id=智能指针><a href=#%e6%99%ba%e8%83%bd%e6%8c%87%e9%92%88 class=header-anchor></a>智能指针</h3><ul><li><p>智能指针</p><ul><li><p>一个裸指针使用多个智能指针包裹</p><ul><li>前一个智能指针销毁后导致内存被销毁，后面的再写入导致内存写坏</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=n>rawPtr</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>TSharedPtr</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>p1</span> <span class=o>=</span> <span class=n>MakeShareable</span><span class=p>(</span><span class=n>rawPtr</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>TSharedPtr</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>p2</span> <span class=o>=</span> <span class=n>MakeShareable</span><span class=p>(</span><span class=n>rawPtr</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>p1</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=o>*</span><span class=n>p2</span> <span class=o>=</span> <span class=mi>7</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><p>TSharedPtr</p><ul><li>引用计数</li></ul></li><li><p>TUniquePtr</p><ul><li>只能转移所有权</li></ul></li><li><p>注意循环引用</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=k>class</span> <span class=nc>B</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>A</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=o>~</span><span class=n>A</span><span class=p>()</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;~A&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>TSharedPtr</span><span class=o>&lt;</span><span class=n>B</span><span class=o>&gt;</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>B</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=o>~</span><span class=n>B</span><span class=p>()</span> <span class=p>{</span> <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;~B&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>TSharedPtr</span><span class=o>&lt;</span><span class=n>A</span><span class=o>&gt;</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>TSharedPtr</span><span class=o>&lt;</span><span class=n>A</span><span class=o>&gt;</span> <span class=n>a</span> <span class=o>=</span> <span class=n>MakeShared</span><span class=o>&lt;</span><span class=n>A</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>TSharedPtr</span><span class=o>&lt;</span><span class=n>B</span><span class=o>&gt;</span> <span class=n>b</span> <span class=o>=</span> <span class=n>MakeShared</span><span class=o>&lt;</span><span class=n>B</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>a</span><span class=o>-&gt;</span><span class=n>b</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>b</span><span class=o>-&gt;</span><span class=n>a</span> <span class=o>=</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>a</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>b</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><p>TWeakPtr</p><ul><li>解决循环引用</li></ul></li></ul></li></ul><h3 id=容器><a href=#%e5%ae%b9%e5%99%a8 class=header-anchor></a>容器</h3><ul><li><p>循环内删除与添加</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>erase</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>vec</span><span class=p>,</span> <span class=kt>int</span> <span class=n>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=n>iter</span> <span class=o>=</span> <span class=n>vec</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span> <span class=n>iter</span> <span class=o>!=</span> <span class=n>vec</span><span class=p>.</span><span class=n>end</span><span class=p>();)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 这个正确
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=o>*</span><span class=n>iter</span> <span class=o>==</span> <span class=n>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>iter</span> <span class=o>=</span> <span class=n>vec</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>iter</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=o>++</span><span class=n>iter</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=n>iter</span> <span class=o>=</span> <span class=n>vec</span><span class=p>.</span><span class=n>begin</span><span class=p>();</span> <span class=n>iter</span> <span class=o>!=</span> <span class=n>vec</span><span class=p>.</span><span class=n>end</span><span class=p>();</span> <span class=o>++</span><span class=n>iter</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// error
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=o>*</span><span class=n>iter</span> <span class=o>==</span> <span class=n>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>vec</span><span class=p>.</span><span class=n>erase</span><span class=p>(</span><span class=n>iter</span><span class=p>);</span> <span class=c1>// error
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><p>拷贝到一个新容器中再做循环删除</p></li><li><p>使用迭代器</p></li></ul></li><li><p>内存重分配问题</p><ul><li><p>TArray</p></li><li><p>TMap也存在此问题</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=k>struct</span> <span class=nc>TestStruct</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>b</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>c</span> <span class=o>=</span> <span class=mf>0.0f</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>FString</span> <span class=n>s</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>TestStruct</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>       <span class=n>UE_LOG</span><span class=p>(</span><span class=n>LogTemp</span><span class=p>,</span> <span class=n>Log</span><span class=p>,</span> <span class=n>TEXT</span><span class=p>(</span><span class=s>&#34;~TestStruct&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=n>TMap</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=n>TestStruct</span><span class=o>&gt;</span> <span class=n>structMap</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>TestStruct</span><span class=o>*</span> <span class=n>val1</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>structMap</span><span class=p>.</span><span class=n>Emplace</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>TestStruct</span><span class=o>*</span> <span class=n>val2</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>structMap</span><span class=p>.</span><span class=n>Emplace</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=mi>10000</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>structMap</span><span class=p>.</span><span class=n>Emplace</span><span class=p>(</span><span class=n>i</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><h3 id=ue的内存管理><a href=#ue%e7%9a%84%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86 class=header-anchor></a>UE的内存管理</h3><h4 id=gc机制><a href=#gc%e6%9c%ba%e5%88%b6 class=header-anchor></a>GC机制</h4><p>  UE使用标记清除算法实现GC，当对象的引用链不可达时，GC会回收该对象所占用的内存。在进行GC之前，UE会从根集出发对所有UObject对象进行标记，标记活动对象，并清除所有未被标记的非活动对象。</p><p>  GC的触发通常在特定时机，如关卡切换、游戏循环周期等，以避免对游戏性能造成过多影响。</p><p>  开发者在UE中需要注意正确管理对象引用，避免出现不必要的长期引用，以确保GC可以正确回收不再使用的内存资源，从而提高游戏性能和稳定性。</p><h4 id=弱指针><a href=#%e5%bc%b1%e6%8c%87%e9%92%88 class=header-anchor></a>弱指针</h4><ul><li><p>通过UObject的弱指针判断其是否在生命周期内</p><ul><li><p>通过GUObjectArray中的索引来指向具体的UObject</p></li><li><p>自增量校验指向的合法性</p></li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=n>ATestActor</span><span class=o>*</span> <span class=n>pActor</span> <span class=o>=</span> <span class=n>GetWorld</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>SpawnActor</span><span class=o>&lt;</span><span class=n>ATestActor</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>FTimerHandle</span> <span class=n>handle</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>GetWorld</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>GetTimerManager</span><span class=p>().</span><span class=n>SetTimer</span><span class=p>(</span><span class=n>handle</span><span class=p>,</span> <span class=p>[</span><span class=n>pActor</span><span class=p>]()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 完犊子了，野指针写入！！！
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>pActor</span><span class=o>-&gt;</span><span class=n>Test</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>pActor</span><span class=o>-&gt;</span><span class=n>Destroy</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>},</span> <span class=mi>2</span><span class=p>,</span> <span class=nb>false</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 强制GC
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>pActor</span><span class=o>-&gt;</span><span class=n>Destroy</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>CollectGarbage</span><span class=p>(</span><span class=n>GARBAGE_COLLECTION_KEEPFLAGS</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 新的TestActor复用原有内存
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>ATestActor</span><span class=o>*</span> <span class=n>pActor2</span> <span class=o>=</span> <span class=n>GetWorld</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>SpawnActor</span><span class=o>&lt;</span><span class=n>ATestActor</span><span class=o>&gt;</span><span class=p>();</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><p>非主线程中使用UObject或者其弱指针的问题</p><ul><li><p>UObject是在主线程中被GC掉，所以非主线程中无法预料其生命周期</p></li><li><p>所以在非主线程中尽量不访问UObject或其弱指针，在外部主线程中将非主线程需要处理的数据全部备份好，通过Lambda表达式传递进去，任务处理完回到主线程后再访问UObject的弱指针</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=n>TWeakObjectPtr</span><span class=o>&lt;</span><span class=n>UBuildingSearchProxy</span><span class=o>&gt;</span> <span class=n>WeakThis</span><span class=p>(</span><span class=k>this</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>uint8</span> <span class=n>Id</span> <span class=o>=</span> <span class=n>WeakThis</span><span class=o>-&gt;</span><span class=n>Id</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>FString</span> <span class=n>SearchInput</span> <span class=o>=</span> <span class=n>WeakThis</span><span class=o>-&gt;</span><span class=n>SearchInput</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>TArray</span><span class=o>&lt;</span><span class=n>FName</span><span class=o>&gt;</span> <span class=n>List</span> <span class=o>=</span> <span class=n>WeakThis</span><span class=o>-&gt;</span><span class=n>List</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>AsyncTask</span><span class=p>(</span><span class=n>ENamedThreads</span><span class=o>::</span><span class=n>AnyBackgroundThreadNormalTask</span><span class=p>,</span> <span class=p>[</span><span class=n>WeakThis</span><span class=p>,</span> <span class=n>Id</span><span class=p>,</span> <span class=n>SearchInput</span><span class=p>,</span> <span class=n>List</span><span class=p>]</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>WeakThis</span><span class=p>.</span><span class=n>IsValid</span><span class=p>())</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=n>TSet</span><span class=o>&lt;</span><span class=n>FName</span><span class=o>&gt;</span> <span class=n>SearchResult</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   <span class=k>for</span> <span class=p>(</span><span class=k>const</span> <span class=n>FName</span><span class=o>&amp;</span> <span class=nl>Part</span> <span class=p>:</span> <span class=n>List</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>Id</span> <span class=o>!=</span> <span class=n>IdCounter</span><span class=p>)</span>
</span></span><span class=line><span class=cl>         <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#if WITH_EDITOR
</span></span></span><span class=line><span class=cl><span class=cp></span>      <span class=k>if</span> <span class=p>(</span><span class=n>Part</span><span class=p>.</span><span class=n>ToString</span><span class=p>().</span><span class=n>Contains</span><span class=p>(</span><span class=n>SearchInput</span><span class=p>))</span>
</span></span><span class=line><span class=cl>      <span class=p>{</span>
</span></span><span class=line><span class=cl>         <span class=n>SearchResult</span><span class=p>.</span><span class=n>Add</span><span class=p>(</span><span class=n>Part</span><span class=p>);</span>
</span></span><span class=line><span class=cl>         <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl>      <span class=k>const</span> <span class=n>FItemTableRow</span><span class=o>*</span> <span class=n>pRow</span> <span class=o>=</span> <span class=n>UDataManager</span><span class=o>::</span><span class=n>FindRow</span><span class=o>&lt;</span><span class=n>FItemTableRow</span><span class=o>&gt;</span><span class=p>(</span><span class=n>Part</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>pRow</span> <span class=o>!=</span> <span class=k>nullptr</span> <span class=o>&amp;&amp;</span> <span class=n>pRow</span><span class=o>-&gt;</span><span class=n>DisplayName</span><span class=p>.</span><span class=n>ToString</span><span class=p>().</span><span class=n>Contains</span><span class=p>(</span><span class=n>SearchInput</span><span class=p>))</span>
</span></span><span class=line><span class=cl>      <span class=p>{</span>
</span></span><span class=line><span class=cl>         <span class=n>SearchResult</span><span class=p>.</span><span class=n>Add</span><span class=p>(</span><span class=n>Part</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>   <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=n>AsyncTask</span><span class=p>(</span><span class=n>ENamedThreads</span><span class=o>::</span><span class=n>GameThread</span><span class=p>,</span> <span class=p>[</span><span class=n>WeakThis</span><span class=p>,</span> <span class=n>SearchResult</span><span class=p>]</span>
</span></span><span class=line><span class=cl>   <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>WeakThis</span><span class=p>.</span><span class=n>IsValid</span><span class=p>())</span> <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>WeakThis</span><span class=o>-&gt;</span><span class=n>Id</span> <span class=o>==</span> <span class=n>IdCounter</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>{</span>
</span></span><span class=line><span class=cl>         <span class=n>WeakThis</span><span class=o>-&gt;</span><span class=n>PostSearchResult</span><span class=p>.</span><span class=n>Broadcast</span><span class=p>(</span><span class=n>SearchResult</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=n>WeakThis</span><span class=o>-&gt;</span><span class=n>SetReadyToDestroy</span><span class=p>();</span>
</span></span><span class=line><span class=cl>   <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span></code></pre></td></tr></table></div></div></li><li><p>成员变量保存UE的接口裸指针</p><ul><li><p>无法判断其生命周期，应保存UObject的弱指针</p></li><li><p>使用的时候再将其Cast为接口指针</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=n>TWeakObjectPtr</span><span class=o>&lt;</span><span class=n>UObject</span><span class=o>&gt;</span> <span class=n>CauserAttributePtr</span><span class=p>;</span> <span class=c1>//伤害造成者
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>TWeakObjectPtr</span><span class=o>&lt;</span><span class=n>UObject</span><span class=o>&gt;</span> <span class=n>TakerAttributePtr</span><span class=p>;</span> <span class=c1>//伤害承受者
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>IAttributeInterface</span><span class=o>*</span> <span class=nf>GetCauserAttributeInterface</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>IAttributeInterface</span><span class=o>*</span> <span class=nf>GetTakerAttributeInterface</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span></code></pre></td></tr></table></div></div></li></ul><h3 id=网络><a href=#%e7%bd%91%e7%bb%9c class=header-anchor></a>网络</h3><h3 id=proto><a href=#proto class=header-anchor></a>Proto</h3><p>禁止直接缓存消息的Proto结构，内存有可能会被重新分配或回收。</p><p>如果需要保存调用项目封装的接口，或者使用Proto上的CopyFrom接口。</p><p>考虑使用<code>FByteArray</code>或者<code>FByteCompressedArray</code>来快捷保存通用数据。</p><h2 id=日志><a href=#%e6%97%a5%e5%bf%97 class=header-anchor></a>日志</h2><p>现状：该有日志的地方没有，不该有的地方疯狂打，导致出bug时很难通过日志判断。</p><h3 id=日志规范><a href=#%e6%97%a5%e5%bf%97%e8%a7%84%e8%8c%83 class=header-anchor></a>日志规范</h3><ul><li><p>各功能模块的重要事件，尽量记录（只要不是频繁重复发生）</p></li><li><p>无用信息或过于频繁打印的就不要输出了（可通过Verbosity等级控制）</p></li><li><p>新增加的模块，尽量记录足够还原现场的日志</p></li><li><p>涉及玩家数值的行为，如物品得失、经验获得、货币流通、装备升级等，尽量记录</p></li><li><p>如果数量太大可以考虑归并后打印</p></li><li><p>避免三字符序列</p><ul><li><p>在C和C++中，三字符序列是一种特殊的字符序列，用两个问号（??）开头，并由另一个字符结尾。例如，"??=&ldquo;代表#，&rdquo;??/&ldquo;代表\，等等。这些三字符序列是为了在早期的编码系统中处理一些没有对应字符的情况而设计的，但在现代的编码系统中，这些三字符序列已经不再使用。</p></li><li><p>当编译器在转换三字符序列时遇到问题时，就会报错：&ldquo;trigraph converted to &rsquo; &rsquo; character&rdquo;。这意味着编译器无法正确地将三字符序列转换为预期的字符，通常是因为在转换时出现了错误或者遇到了无法识别的三字符序列。</p></li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=n>UE_LOG</span><span class=p>(</span><span class=n>LogAStar</span><span class=p>,</span> <span class=n>Error</span><span class=p>,</span> <span class=n>TEXT</span><span class=p>(</span><span class=s>&#34;Particle Type Shrink Error????!!&#34;</span><span class=p>));</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=checklist><a href=#checklist class=header-anchor></a>CheckList</h2><ul><li><p>裸指针成员变量未初始化为空</p></li><li><p>局部变量未初始化使用</p></li><li><p>数组越界</p></li><li><p>内存拷贝缓冲区溢出</p></li><li><p>UObject需要强引用的未用UPROPERTY包裹</p></li><li><p>UObject不需强引用的没有用弱指针</p></li><li><p>USTRUCT中包含UObject成员未用UPROPERTY</p></li><li><p>成员变量保存UE接口的裸指针</p></li><li><p>构造函数内调用虚函数</p></li><li><p>基类析构函数未声明成虚函数</p></li><li><p>指针未判空使用</p></li><li><p>异步回调捕获所有&,=</p></li><li><p>异步回调Lambda表达式传入裸指针</p></li><li><p>异步回调未判断Upvalue的生命周期</p></li><li><p>异步回调Lambda表达式引用捕获局部变量</p></li><li><p>Lambda表达式自销毁导致的Upvalue生命周期问题</p></li><li><p>使用异常机制</p></li><li><p>返回局部变量的引用或指针</p></li><li><p>手动管理内存的申请和回收未成对</p></li><li><p>不正确的类型转换</p></li><li><p>容器的循环内删除错误</p></li><li><p>智能指针循环引用</p></li><li><p>TArray取值未判断边界</p></li><li><p>TArray写入未判断边界</p></li><li><p>TArray前值指针或引用在触发内存重分配后野掉</p></li><li><p>TMap前值指针或引用再触发内存重分配后野掉</p></li><li><p>TMap取值前未判断是否存在</p></li><li><p>非主线程中对UObject的使用</p></li><li><p>使用类对象的静态存储周期变量</p></li><li><p>出现菱形继承</p></li><li><p>间接无限递归调用导致栈溢出</p></li><li><p>死循环</p></li><li><p>关键事件未加日志</p></li><li><p>该用PushModel未用</p></li><li><p>Memset, memcpy用于非POD结构</p></li><li><p>浮点数判断是否相等导致的问题</p></li><li><p>UE_LOG传入的参数类型不匹配导致崩溃</p></li><li><p>设置的Timer没有回收，导致Timer泄漏</p></li><li><p>除0问题</p></li><li><p>循环操作该用引用时没有用引用</p></li><li><p>尽量使用UE内置typedef的基础数据类型（如：int32, int64，不要使用long, size_t之类的）</p></li><li><p>可复制变量不能是Public，不能是蓝图可写</p></li><li><p>配置表所有的引用都要使用软引用</p></li></ul><h2 id=参考文献><a href=#%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae class=header-anchor></a>参考文献</h2><p><a class=link href=https://docs.unrealengine.com/4.27/zh-CN/ProductionPipelines/DevelopmentSetup/CodingStandard/ target=_blank rel=noopener>https://docs.unrealengine.com/4.27/zh-CN/ProductionPipelines/DevelopmentSetup/CodingStandard/</a></p><p><a class=link href=https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/ target=_blank rel=noopener>https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/</a></p><p><a class=link href=https://www.zhihu.com/question/26901409/answer/1858690571 target=_blank rel=noopener>https://www.zhihu.com/question/26901409/answer/1858690571</a></p><p><a class=link href=https://github.com/Icassell/UE4-Style-Guide-1 target=_blank rel=noopener>https://github.com/Icassell/UE4-Style-Guide-1</a></p></section><footer class=article-footer><section class=article-tags><a href=/tags/cpp/>C/C++</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span><p>该内容采用 CC BY-NC-SA 4.0 许可协议。</p><p>如果对您有帮助或存在意见建议，欢迎在下方评论交流。</p></span></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css integrity=sha384-nB0miv6/jRmo5UMMR1wu3Gz6NLsoTkbqJghGIsx//Rlm+ZU03BU6SQNC66uf4l5+ crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js integrity=sha384-7zkQWkzuo3B5mTepMUcHkMB5jZaolc2xDwL6VFqjFALcbeS9Ggm/Yr2r3Dy4lfFg crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js integrity=sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{const e=document.querySelector(".main-article");renderMathInElement(e,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})</script></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/knowledge/cpp-protobuf/><div class=article-details><h2 class=article-title>Windows下C++版本Protobuf使用方法</h2></div></a></article><article><a href=/knowledge/cpp-static/><div class=article-details><h2 class=article-title>C++中static关键字用法总结</h2></div></a></article><article><a href=/knowledge/cpp-const/><div class=article-details><h2 class=article-title>C++中const关键字用法总结</h2></div></a></article><article><a href=/knowledge/random-weight/><div class=article-details><h2 class=article-title>常用加权随机算法说明与实现</h2></div></a></article><article><a href=/knowledge/katex-cloudflare/><div class=article-details><h2 class=article-title>Cloudflare环境下开启Rocket Loader之后Katex失效问题</h2></div></a></article></div></div></aside><script src=https://giscus.app/client.js data-repo=BoilTask/BoilTask.github.io data-repo-id="MDEwOlJlcG9zaXRvcnkyODQ5Njk2MTU=" data-category=Announcements data-category-id=DIC_kwDOEPxKj84CkD1t data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=en data-loading=lazy crossorigin=anonymous async></script><script>function setGiscusTheme(e){let t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:{setConfig:{theme:e}}},"https://giscus.app")}(function(){addEventListener("message",t=>{if(event.origin!=="https://giscus.app")return;e()}),window.addEventListener("onColorSchemeChange",e);function e(){setGiscusTheme(document.documentElement.dataset.scheme==="light"?"light":"dark_dimmed")}})()</script><footer class=site-footer><section class=copyright>&copy;
2010 -
2025 BoilTask's Blog</section><section class=powerby><a href=https://beian.miit.gov.cn/ target=_blank rel=noopener>豫ICP备15024677号-1</a><br>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.30.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script><div id=loadingOverlay><div class=loader></div><p>加载中...</p></div><style>#loadingOverlay{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(255,255,255,.9);z-index:9999;display:none;justify-content:center;align-items:center;flex-direction:column}.loader{border:8px solid #f3f3f3;border-top:8px solid #3498db;border-radius:50%;width:60px;height:60px;animation:spin 1s linear infinite}@keyframes spin{0%{transform:rotate(0)}100%{transform:rotate(360deg)}}</style></body></html>