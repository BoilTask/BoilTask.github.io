[{"content":"似乎自从空间开始流传开来，博客这一事物就有着被淘汰的趋势，似乎只有些专业人士愿意坚持这一交流形式……\n不管怎么说，博客还是有它的优点与可取之处了，比如我非常喜欢的这个代码标注功能，太赞了……\n想法和目标 既然博客创建了就不能让它没有什么卵用~ 记录一些学习道路上的所见所想吧，虽然在这里可能并没有什么人来看-_-\n但也╮(╯_╰)╭无所谓嘛~留给自己的礼物吧 毕竟怀旧并且有旧可怀是件非常爽的事……\n作为一个个探讨技术的博客~第一篇随便写写代码吧……\n想想那时候小的时候，我还是喜欢这种非正规字体时，我惧于C语言的英语性，也加上爱玩的心态，所以选择了一阵乱学，最有卵用的还是号称中文编程的易语言……于是…… 1 标签1.标题=“你好世界！我就是不写英文” 那时候甚至都没用过 调试输出 这种东西……因为感觉没什么卵用……\n但……\n既然选择了计算机专业，化成灰也要随风往前飘！ 这个大一学期开始，才第一次用心看C语言……写下了:\n1 2 3 4 #include\u0026lt;stdio.h\u0026gt; main(){ printf(\u0026#34;Hello World\u0026#34;); } 妥协了……于是耐心研究……到现在 我又更喜欢写……\n1 2 3 4 5 6 #include\u0026lt;stdio.h\u0026gt; int main(){ printf(\u0026#34;Hello World\\n\u0026#34;); printf(\u0026#34;我还是喜欢中文！\\n\u0026#34;); return 0; } ╮(╯▽╰)╭ 心中要有目标嘛\n中国计算机要继续努力啊！\n加油加油！\n心得和体会 以后慢慢来谈吧~\n网站的问题也还要继续研究！\n煮梦空间——www.BoilTask.com\n","date":"2015-11-18T05:21:05Z","permalink":"https://boiltask.com/csdn/49905797/","title":"📌第一篇正式文章 随便聊聊吧"},{"content":"之前一直是Notion的拥趸，不过随着又有好久不用Notion，又重新起了笔记软件挑选的念头。\n之前一直觉得Obsidian作为一个本地存档的笔记软件，功能也没有Notion强大，还需要自己处理同步等问题，应该是没什么优势。\n不过上次折腾起来Hugo之后，越发感觉笔记这种东西，还是返璞归真比较适合我，要不太容易忙于折腾样式、排版什么的问题而分心。到最后发现，除了设计好的模板，其实真正的内容没有多少。\n下载下来Obsidian之后，发现他和Hugo的工作流意外的搭。使用Obsidian来管理工作区，比用专注编码的IDE要更适合文档类的整理工作。虽然这样以来又有些浪费“重金”买的Typora，不过总算也是能物尽其用吧。\n说起来作为Typora刚出付费方案就首发入手的用户，好像自从买了就没大用过……反倒是之前免费的时候，还拿来写过一些东西。\n使用Obsidian打开Hugo的文件夹，正常在content路径写内容，然后把一些不需要上传到博客上的文章，还有一些Hugo不支持的文章放在单独的文件夹中即可。\n","date":"2025-04-03T21:40:08+08:00","permalink":"https://boiltask.com/record/try-obsidian/","title":"尝试Obsidian与Hugo结合"},{"content":"之前经常纠结中英文混排时的排版问题，因此引入了pangu.js来优化排版效果。\n官方仓库：vinta/pangu.js: Paranoid text spacing in JavaScript\n调用pangu.autoSpacingPage()即可将页面转换为美化之后的结果。\n由于JS的加载与处理需要时间，直接这么写的话，体验上是用户会先看到处理前的页面，然后短暂停留后刷新为新内容，这就导致体验上很奇怪。\n解决思路的话，可以考虑先隐藏页面，等DOM加载完，先进行pangu.js的处理，完毕后再重新显示页面。\n为了避免第一次加载较久，还可以加一个Loading效果。\n需要注意autoSpacingPage函数会异步处理，可以改为阻塞版本的spacingPage。\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 \u0026lt;div id=\u0026#34;loadingOverlay\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;loader\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;p\u0026gt;加载中...\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;style\u0026gt; #loadingOverlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255, 255, 255, 0.9); z-index: 9999; display: none; justify-content: center; align-items: center; flex-direction: column; } .loader { border: 8px solid #f3f3f3; border-top: 8px solid #3498db; border-radius: 50%; width: 60px; height: 60px; animation: spin 1s linear infinite; } @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } } \u0026lt;/style\u0026gt; \u0026lt;style\u0026gt; /* 初始隐藏页面内容，避免显示未经处理的文本 */ .main-container { display: none; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; let isShouldLoad = true; setTimeout(() =\u0026gt; { if (isShouldLoad) { const loadingOverlay = document.getElementById(\u0026#39;loadingOverlay\u0026#39;); if (loadingOverlay) { loadingOverlay.style.display = \u0026#39;flex\u0026#39;; } } }, 200); // 0.2秒如果还没有加载完成就开启Loading \u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import pangu from \u0026#39;https://jspm.dev/pangu\u0026#39;; document.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, () =\u0026gt; { isShouldLoad = false pangu.spacingPage(); const elements = document.getElementsByClassName(\u0026#34;main-container\u0026#34;) for (let i = 0; i \u0026lt; elements.length; i++) { elements[i].style.display = \u0026#39;flex\u0026#39;; } const loadingOverlay = document.getElementById(\u0026#39;loadingOverlay\u0026#39;); if (loadingOverlay) { loadingOverlay.style.display = \u0026#39;none\u0026#39;; } }); \u0026lt;/script\u0026gt; ","date":"2025-04-03T09:06:12+08:00","permalink":"https://boiltask.com/record/hugo-pangu/","title":"给Hugo博客引入pangu.js"},{"content":"简介 在排查一些内存问题（野指针、越界访问等）时，可以使用AddressSanitizer（ASan）工具。\n比起修改为Stomp分配器的方式，ASan的实现以性能降低约一半的代价，也能扫描出来很多问题。\n性能指标参考：AddressSanitizerPerformanceNumbers · google/sanitizers Wiki\nLinux下DS使用 基本流程 考虑开启 ASan 对流程和性能的影响，一般需要单独部署一些炮灰环境。\n在原有的打包参数之后添加-EnableAsan标识，用来开启ASan相关的编译参数 启动时通过设置环境变量ASAN_OPTIONS来控制ASan的相关配置 在原先的启动参数之后加上-ansimalloc标识 当遇见异常时，检查stderr的输出 可以选择配置log_path来指定异常时的输出文件 堆栈获取 通过指定ASAN_SYMBOLIZER_PATH可以使得输出的信息里自带堆栈，使用了llvm- symbolizer ，性能比起addr2line可以有较高的提升。\n详见：AddressSanitizerCallStack · google/sanitizers Wiki\n会使得输出日志稍微慢几秒，目测可以接受。\n可以使用格式文本设定stack_trace_format：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // %% - represents a \u0026#39;%\u0026#39; character; // %n - frame number (copy of frame_no); // %p - PC in hex format; // %m - path to module (binary or shared object); // %o - offset in the module in hex format; // %f - function name; // %q - offset in the function in hex format (*if available*); // %s - path to source file; // %l - line in the source file; // %c - column in the source file; // %F - if function is known to be \u0026lt;foo\u0026gt;, prints \u0026#34;in \u0026lt;foo\u0026gt;\u0026#34;, possibly // followed by the offset in this function, but only if source file // is unknown; // %S - prints file/line/column information; // %L - prints location information: file/line/column, if it is known, or // module+offset if it is known, or (\u0026lt;unknown module\u0026gt;) string. // %M - prints module basename and offset, if it is known, or PC. 不过测试下来似乎未取到函数行号，判断是llvm的问题，addr2line就可以。\nwindows下使用llvm-symbolizer.exe也可以成功取到。\n同时，测试下来windows下使用MinGW版本的addr2line也可以取到堆栈，但是慢到无法接收。\n推荐配置 开启堆栈输出并设置日志路径：\n1 export ASAN_OPTIONS=\u0026#34;symbolize=1:print_stacktrace=1:log_path=/home/crash/ds-${版本}-asan-crash.log\u0026#34; 问题记录 开启ASan之后加载过慢 需要检查fast_unwind_on_malloc是否被设置为0，如果fast_unwind_on_malloc被关闭，则会极大地影响性能。\n详见：Address Sanitizer | Android NDK | Android Developers\n堆栈还原 写了一个golang的脚本用于快速的分析堆栈：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 package main import ( \u0026#34;bufio\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/exec\u0026#34; \u0026#34;strings\u0026#34; ) func convertStackToAddr2line(inputFile, outputFile, binaryPath string) error { infile, err := os.Open(inputFile) if err != nil { return fmt.Errorf(\u0026#34;无法打开输入文件: %v\u0026#34;, err) } defer func(infile *os.File) { err := infile.Close() if err != nil { fmt.Printf(\u0026#34;关闭输入文件时出错: %v\\n\u0026#34;, err) } }(infile) outfile, err := os.Create(outputFile) if err != nil { return fmt.Errorf(\u0026#34;无法创建输出文件: %v\u0026#34;, err) } defer func(outfile *os.File) { err := outfile.Close() if err != nil { fmt.Printf(\u0026#34;关闭输出文件时出错: %v\\n\u0026#34;, err) } }(outfile) scanner := bufio.NewScanner(infile) writer := bufio.NewWriter(outfile) defer func(writer *bufio.Writer) { err := writer.Flush() if err != nil { fmt.Printf(\u0026#34;刷新输出文件时出错: %v\\n\u0026#34;, err) } }(writer) for scanner.Scan() { line := strings.TrimSpace(scanner.Text()) if strings.HasPrefix(line, \u0026#34;#\u0026#34;) { parts := strings.Fields(line) var address string for _, part := range parts { if strings.HasPrefix(part, \u0026#34;0x\u0026#34;) { address = part break } } if address != \u0026#34;\u0026#34; { cmd := exec.Command(\u0026#34;addr2line\u0026#34;, \u0026#34;-e\u0026#34;, binaryPath, address) output, err := cmd.Output() if err != nil { _, err := fmt.Fprintf(os.Stderr, \u0026#34;执行 addr2line 失败: %v\\n\u0026#34;, err) if err != nil { return err } continue } s := strings.TrimSpace(string(output)) _, err = writer.WriteString(s + \u0026#34;\\n\u0026#34;) if err != nil { return err } fmt.Println(s) } } else { _, err := writer.WriteString(line + \u0026#34;\\n\u0026#34;) if err != nil { return err } fmt.Println(line) } } if err := scanner.Err(); err != nil { return fmt.Errorf(\u0026#34;读取文件时出错: %v\u0026#34;, err) } fmt.Printf(\u0026#34;转换完成，结果已保存到 %s\\n\u0026#34;, outputFile) return nil } func main() { if len(os.Args) != 4 { fmt.Println(\u0026#34;Usage: go run main.go \u0026lt;input_file\u0026gt; \u0026lt;output_file\u0026gt; \u0026lt;binary_path\u0026gt;\u0026#34;) os.Exit(1) } inputFile := os.Args[1] outputFile := os.Args[2] binaryPath := os.Args[3] if err := convertStackToAddr2line(inputFile, outputFile, binaryPath); err != nil { _, err := fmt.Fprintf(os.Stderr, \u0026#34;错误: %v\\n\u0026#34;, err) if err != nil { return } os.Exit(1) } } 参考文章 在虚幻引擎项目中使用Clang检测工具 | 虚幻引擎 5.5 文档 | Epic Developer Community google/sanitizers: AddressSanitizer, ThreadSanitizer, MemorySanitizer ","date":"2025-04-03T09:03:48+08:00","permalink":"https://boiltask.com/ue/ue-asan/","title":"虚幻引擎中ASan相关机制"},{"content":"简介 在Actor的复制过程中，需要关心两个属性，Role与RemoteRole。\n通过这两个属性，可以明确地知道：\n谁拥有Actor的主控权 Actor是否被复制 复制模式 首先一件要确定的事，就是谁拥有特定 actor 的主控权。要确定当前运行的引擎实例是否有主控者，需要查看 Role 属性是否为 ROLE_Authority。如果是，就表明这个运行中的 虚幻引擎 实例负责掌管此 actor（决定其是否被复制）。\n如果 Role 是 ROLE_Authority，RemoteRole 是 ROLE_SimulatedProxy 或 ROLE_AutonomousProxy，就说明这个引擎实例负责将此 actor 复制到远程连接。\n简单来说：\n对于单机模式，Actor的Role与RemoteRole很显然都是ROLE_Authority。\n对于网络模型下，Role代表本地对于Actor的角色，RemoteRole代表对端对于Actor的角色。\n下面将重点描述多人游戏时的相关机制。\n属性类型 ROLE_Authority 代表最高权限，通常是服务器持有的状态。\n如果客户端本地生成的一个不同步的Actor，其Role有可能也为ROLE_Authority，因为此时这个客户端对这个Actor具有绝对的权限。\nROLE_SimulatedProxy 被动模拟角色，由服务器控制，客户端仅接受同步数据。\n比如对于客户端A视角下的另一个角色，它的Role就有可能是ROLE_SimulatedProxy。\nROLE_AutonomousProxy 主控端角色，通常代表由客户端直接控制，服务器接收控制的输入来同步其状态。\n比如对于客户端A视角下的自身角色，它的Role就有可能是ROLE_AutonomousProxy，接收输入之后发给服务器更新其状态。\nRemoteRole与Role的区别 RemoteRole与Role对应，代表对端对Actor的角色定义，是Role的另一个视角。\n当Actor在服务器为ROLE_Authority，他在服务器上的RemoteRole为ROLE_SimulatedProxy，对应的客户端的Role为ROLE_SimulatedProxy，RemoteRole为ROLE_Authority。\n对于不同的数值观察者，它们的 Role 和 RemoteRole 值可能发生对调。\n注意这个可能的描述\n比如客户端Role为ROLE_AutonomousProxy，RemoteRole为ROLE_Authority的角色（自己操作的那个），他在服务器上的Role为ROLE_Authority，但是RemoteRole可能为ROLE_SimulatedProxy。\n角色组合 常见Role与RemoteRole的组合 本地Role 远程RemoteRole 场景说明 ROLE_Authority ROLE_SimulatedProxy 服务器视角，控制Actor，客户端仅接收同步数据（如NPC）。 ROLE_SimulatedProxy ROLE_Authority 客户端视角，客户端接收服务器同步的Actor（如静态场景物体）。 ROLE_AutonomousProxy ROLE_SimulatedProxy 客户端视角，客户端控制Actor，服务器同步其状态（如玩家角色）。 区分SimulatedProxy与AutonomousProxy 参考官方文档的描述，由于Actor的同步具有间隔，为了弥补这个缺陷，客户端在模拟时采取两种策略：\nROLE_SimulatedProxy通常直接根据服务器同步的信息进行模拟。\nROLE_AutonomousProxy通常会考虑客户端自身的输入，通过这部分输入来补足信息，而非只通过服务器的信息推算。\n参考文档 虚幻引擎Actor的 Role 和 RemoteRole属性 | 虚幻引擎 5.5 文档 | Epic Developer Community ","date":"2025-04-02T13:17:46+08:00","permalink":"https://boiltask.com/ue/network-role/","title":"虚幻引擎中网络角色Role相关概念"},{"content":"简介 本文主要用于整理虚幻引擎中移动相关的机制。\n内容可能摘录自各个文章、论坛、文档等，仅用作记录。\n基础简介 移动是一个非常重要并且较为复杂的模块，UnrealEngine对于移动的实现使用了组合模式，在描述Actor的移动时，含义是具有移动组件的Actor可以移动。\n移动组件的基类为UMovementComponent，提供基本的移动功能，有多个不同功能的子类，一些子类移动组件专门用于服务一种特殊的Actor，比如通常代表玩家的ACharacter，对应的移动组件UCharacterMovementComponent。\nActor虽然代表在World中的一个实体，但是本身是没有位置概念的。Actor的位置由其具有的USceneComponent赋予。因此移动的本质，就是改变Actor上的某个USceneComponent的位置，通常指的是Actor的RootComponent。\nUMovementComponent上有个属性UpdatedComponent，就是用于设置移动组件所修改的USceneComponent。暴露给蓝图有个参数bAutoRegisterUpdatedComponent，如果设置为true，则会在组件初始化时，读取Owner的RootComponent，调用SetUpdatedComponent设置UpdatedComponent。\n移动流程 网络同步下的角色移动至少需要考虑以下几个方面：\n玩家客户端操作无延迟 需要直接响应移动输入并上报给服务器 位置以服务器为准 防止外挂 同步到的移动需要表现丝滑 不可能每帧都收到位置更新，需要适当进行插值 自主实现 先思考如果自己实现的情况下可能会怎么做。\n本地接收到输入之后，在本地先操作移动，同时把移动的操作发送给服务器 可能包含的信息是：当前位置、目标位置等 服务器接收到移动的操作，在服务器上执行移动，并把玩家位移的信息同步给所有客户端 信息同样包含：当前位置、目标位置、速度等 其他客户端收到了移动的信息后，修改角色的移动目标，根据插值调整角色位置 引擎实现 虚幻引擎网络同步情况下的移动流程与此类似，大概为：\n每一帧执行TickComponent时，计算这一帧的加速度和转向，之后对于主控的Character，调用ReplicateMoveToServer把移动同步给服务器\nReplicateMoveToServer会把移动保存到列表，然后执行PerformMovement在本地预执行移动操作。\n然后会调用ServerMove把移动同步给服务器，告知移动的参数、客户端自己移动的位置，以及时间戳\nServerMove在服务器上执行，根据客户端声明的位置，与服务器的位置做对比，如果差异过大，则调用ClientAdjustPosition在主控端校正位置\n客户端如果收到ClientAdjustPosition，会把客户端角色位置设置为服务器上的位置，并把bUpdatePosition标记为true，这将会影响到后续的移动更新\n当客户端再次调用TickComponent时，如果存在bUpdatePosition，则会调用ClientUpdatePositionAfterServerUpdate来重演在服务器上调整移动之后发生的所有移动。\n在引擎源码CharacterMovementComponent.h中可以找到对移动同步流程的描述：\nHere\u0026rsquo;s how player movement prediction, replication and correction works in network games:\nEvery tick, the TickComponent() function is called. It figures out the acceleration and rotation change for the frame, and then calls PerformMovement() (for locally controlled Characters), or ReplicateMoveToServer() (if it\u0026rsquo;s a network client).\nReplicateMoveToServer() saves the move (in the PendingMove list), calls PerformMovement(), and then replicates the move to the server by calling the replicated function ServerMove() - passing the movement parameters, the client\u0026rsquo;s resultant position, and a timestamp.\nServerMove() is executed on the server. It decodes the movement parameters and causes the appropriate movement to occur. It then looks at the resulting position and if enough time has passed since the last response, or the position error is significant enough, the server calls ClientAdjustPosition(), a replicated function.\nClientAdjustPosition() is executed on the client. The client sets its position to the servers version of position, and sets the bUpdatePosition flag to true.\nWhen TickComponent() is called on the client again, if bUpdatePosition is true, the client will call ClientUpdatePosition() before calling PerformMovement(). ClientUpdatePosition() replays all the moves in the pending move list which occurred after the timestamp of the move the server was adjusting.\n玩家输入 管理玩家输入的也是一个组件UInputComponent，通常可以调用BindAxis来注册事件响应。\n一般最终会调用到UPawnMovementComponent::AddInputVector来处理移动。\n主控角色移动 在UE的网络框架中，角色主要分为三种：ROLE_Authority、ROLE_AutonomousProxy、ROLE_SimulatedProxy。\n详见：虚幻引擎中网络角色Role相关概念\n在客户端主控角色也即Autonomous角色会接受控制，然后把移动数据发往服务器。\n本地的每次移动都会生成FSavedMove_Character，并维护一个TArray\u0026lt;FSavedMovePtr\u0026gt; SavedMoves的数组，保存了当前玩家本地已经做的移动，这些移动还没经过服务器检查。\n如果服务器认可了一些移动，就可以把这些移动删掉，如果检查不通过，就可以据此执行异常处理。\n协议选择 在UE中，默认使用UDP作为传输协议，这可以使得数据包尽快送达。\nUDP不保证可达和有序，但是应用层面可以通过设计来在需要的地方避免这些问题。\nServer同步移动给客户端 Actor基本同步方案 Actor自身就支持移动同步，打开ReplicateMovement开关后，当Actor的RootComponent位置、朝向等数据发生变化时，就会把数据同步给Simulate客户端。\n当Simulate的客户端收到同步之后，会简单的设置自己的位置和朝向。移动数据的同步有间隔，因此这种实现会导致Actor发生闪现。\nCharacter移动同步 针对Actor基本同步模式的不足，CharacterMovementComponent针对性的做了表现平滑处理，让Simulate角色移动尽可能平滑自然。\nCharacter主要有两个组件，Capsule和Mesh，Capsule是Chara\n关键概念 UCharacterMovement 角色移动组件是最为复杂的一个子类，需要重点进行分析。\nclassDiagram\rclass UCharacterMovementComponent {\r+IRVOAvoidanceInterface\r+INetworkPredictionInterface\r}\rUActorComponent \u0026lt;|-- UMovementComponent\rUMovementComponent \u0026lt;|-- UNavMovementComponent\rUNavMovementComponent \u0026lt;|-- UPawnMovementComponent\rUPawnMovementComponent \u0026lt;|-- UCharacterMovementComponent\rFSavedMove_Character 用于描述玩家的一次移动，可以认为是一次移动的快照。\n主要属性有：\n属性 描述 TimeStamp 这次移动发生的时间 DeltaTime 这次移动使用的时间 CustomTimeDilation 时间膨胀系数，可以用于快进和慢放 StartPackedMovementMode 移动发生前的MovementMode StartLocation 移动发生前的位置 StartVelocity 移动发生前的速度 EndPackedMovementMode 移动发生后的MovementMode SavedLocation 移动发生后的位置 SavedVelocity 移动发生后的速度 Acceleration 移动所用加速度 理论上只要有这些数据，就能复盘整个移动过程，也可用作回放功能。\nReplicateMoveToServer 首先会从SavedMoves里找到最早发生的一个ImportantMove（通过IsImportantMove判断），也就是最新被服务器确认的有显著差异的Move。\n之后创建一个FSavedMove_Character并初始化。然后执行PerformMovement，对角色计算操作后的属性，设置上相关信息。\n根据能否被合并，进行处理。\n延迟发送Move 一个Move有可能可以被延迟一会，与后面的Move合并后再发给服务器。因此一个新建的Move被发往服务器前会先判断是否可以延迟发送。\n首先判断是否开启了NetEnableMoveCombining，如果没开也不会延迟发送。\n同时还会判断当前的Move是否能被延迟发送，会检查该Move前后MovementMode是否改变，如果改变也需要即使变化。也就是说，如果此次Move没有显著改变，那么则可以延后发送，理论上服务器根据之前的信息推算，结果应该是一样的。\n然后会计算当前预期的移动更新时间间隔，根据当前网速、玩家数量等信息，在基准值ClientNetSendMoveDeltaTime上做调整，得到最终间隔，如果Tick时还没达到更新间隔，就会延迟发送Move，把它储存在PendingMove中，留着以后处理。\nCallServerMove 函数接受两个参数，一个是刚创建的Move，另一个是之前获取的ImportantMove（ImportantMove可能为空）。不需要把整个Move都发往服务器，只需要位置、旋转、加速度等关键信息，并且这些信息会经过压缩。\n压缩的过程简单来说，会尝试牺牲精度，把一些字段合并在一个数据结构中。\n之后还会调用ServerMoveOld，把ImportantMove中的一些信息发送到服务器，可以简单理解为一种冗余的保险。\n如果存在PendingMove，说明存在未合并的Move，需要调用ServerMoveDual一次发送两个连续的Move。否则，说明发送间隔较大，或者PendingMove已经被合并，就调用ServerMode发送这个Move。\nServerMoveOld ServerMoveOld主要作为一种冗余措施，防止服务器新收到一个移动数据时，因为网络丢包而落后太多，导致移动判断不通过，进而纠正客户端位置。ServerMoveOld可以让服务器使用传递的加速度，粗略的从旧位置快速移动到新位置，不校验移动结果。\nTODO：安全性如何保证？\nTODO 具有物理模拟下的移动\n移动如何通过RPC发送的\n参考文章 UE4移动的网络同步 - 知乎 UE4/UE5 Character Movement Component移动组件网络同步详解 - 知乎 「Grow by UE」图解角色移动组件 - 知乎 UE移动同步原理分析（一）：Pawn的移动属性复制 - 知乎 ","date":"2025-04-02T12:54:31+08:00","permalink":"https://boiltask.com/ue/character-movement/","title":"虚幻引擎中角色移动相关机制"},{"content":"配置参数 Window指定编译SDK 修改Engine/Saved/UnrealBuildTool/BuildConfiguration.xml中的配置，添加MSVC版本号、SDK的版本号。\n1 2 3 4 \u0026lt;WindowsPlatform\u0026gt; \u0026lt;CompilerVersion \u0026gt;14.40.33807\u0026lt;/CompilerVersion\u0026gt; \u0026lt;WindowsSdkVersion\u0026gt;10.0.20348.0\u0026lt;/WindowsSdkVersion\u0026gt; \u0026lt;/WindowsPlatform\u0026gt; 最终示例 配置文件形如：\n1 2 3 4 5 6 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34; ?\u0026gt; \u0026lt;Configuration xmlns=\u0026#34;https://www.unrealengine.com/BuildConfiguration\u0026#34;\u0026gt; \u0026lt;WindowsPlatform\u0026gt; \u0026lt;WindowsSdkVersion\u0026gt;10.0.19041.0\u0026lt;/WindowsSdkVersion\u0026gt; \u0026lt;/WindowsPlatform\u0026gt; \u0026lt;/Configuration\u0026gt; 参考文章 Build Configuration for Unreal Engine | Unreal Engine 5.5 Documentation | Epic Developer Community\n","date":"2025-03-05T12:42:21+08:00","permalink":"https://boiltask.com/ue/build-configuration/","title":"UnrealEngine虚幻引擎编译选项"},{"content":"在编辑器中按下~键打开控制台（就是数字1左边的那个按键）\n下面列出一些常用的控制台指令：\nstat fps 显示帧率\nstat unit 显示包括drawcall，游戏逻辑线程，渲染线程，面数等信息（面数信息需要在设置中调整ES3.1才会显示）\nslomo 0.1 游戏运行下的速度0.1表示运行速度变为正常的十分之一\nr.showcollision 显示碰撞体\nt.maxfps 60 设置最大帧率\n更多控制台指令可以在下面这个网站查询： https://digilander.libero.it/ZioYuri78/\n","date":"2025-02-26T11:44:41+08:00","permalink":"https://boiltask.com/ue/common-console-command/","title":"UE4常用控制台指令"},{"content":"UE对于Blueprint似乎有个函数级的Merge工具，初体验不太好用还在研究。\n1 D:\\MetaEngine\\Engine\\Binaries\\Win64\\UE4Editor.exe D:\\Meta\\Meta.uproject -diff %theirs %mine %base %merged ","date":"2025-02-24T11:57:11+08:00","permalink":"https://boiltask.com/ue/blueprint-merge/","title":"虚幻引擎蓝图合并工具"},{"content":"A-J\n参考文章 加权随机采样 (Weighted Random Sampling) | 三点水\n加权随机采样 | HCigmoid\n前缀和应用之生成加权随机数 | coolcao的小站\n","date":"2024-12-13T12:50:53+08:00","permalink":"https://boiltask.com/knowledge/random-weight/","title":"常用加权随机算法说明与实现"},{"content":" Detailed Actor Replication Flow暂时没有官方翻译，尝试理解顺便翻译一下。\n简介 Actor复制是一个详细的多步骤过程，其中网络驱动程序（Net Driver）确定需要向哪些连接复制哪些Actor，以及按照什么顺序复制。本页面提供了Actor复制流程的概述。\n大多数Actor的复制是在UNetDriver::ServerReplicateActors函数中进行的。 在这个函数中，服务器会首先收集所有被判定对每个客户端相关的Actor，然后将自上次更新以来发生变化的属性发送给每个已连接的客户端。随后，UActorChannel::ReplicateActor 函数负责处理将特定Actor复制到某一通道的详细操作。\n重要属性 对于如何更新 actor、调用某些框架回调以及用于确定在当前服务器 tick 期间是否复制 actor 的属性，有一个定义的流程。以下是一些重要的属性：\n属性 描述 AActor::NetUpdateFrequency 决定Actor复制的频率。 AActor::PreReplication 在任何复制操作发生之前调用。 AActor::bOnlyRelevantToOwner 如果该Actor只会复制给其拥有者，则为True。 AActor::IsRelevancyOwnerFor 当bOnlyRelevantToOwner为True时，决定Actor的相关性。 AActor::IsNetRelevantFor 当bOnlyRelevantToOwner为False时，决定Actor的相关性。 AActor::NetDormancy 决定Actor是处于休眠状态还是激活状态。 Actor复制流程概述 以下步骤构成了Actor复制过程的高级概述：\n确定需要复制的Actors，并进行检查以确定它们的休眠状态、更新频率以及拥有的连接。 将通过这些检查的Actors添加到一个列表中，准备进行复制。 遍历每个连接，并根据当前的Actor和连接执行检查。完成此步骤后，得到每个连接需要复制的Actor列表。 按照优先级对每个连接的Actors进行排序。 确定该Actor是否对当前连接相关。 将该Actor复制到当前连接。 以下部分将提供上述Actor复制流程概述中每一步的详细描述。\n将Actor添加到待复制列表 此步骤首先检查所有Actors，确定哪些Actors正在进行复制（通过检查是否调用了 AActor::SetReplicates(true)）。对于每个正在复制的Actor，NetDriver 执行以下检查：\n判断当前Actor是否初始处于休眠状态（ENetDormancy::DORM_Initial）。 如果是休眠状态，则跳过该Actor。 检查当前Actor是否需要更新，具体通过检查 AActor::NetUpdateFrequency 属性。 如果不需要更新，则跳过该Actor。 如果 AActor::bOnlyRelevantToOwner 为 true，则检查该Actor的拥有连接的相关性，通过调用 AActor::IsRelevancyOwnerFor 来判断。 如果相关，则将其添加到该连接的“拥有者相关列表”中。 在这种情况下，该Actor只会发送给单个连接。 对于通过上述检查的每个Actor，调用 AActor::PreReplication。在 AActor::PreReplication 中，你可以决定是否希望某些属性仅复制到特定连接。可以使用 DOREPLIFETIME_ACTIVE_OVERRIDE 宏来控制Actor复制到哪些连接。 如果Actor通过了所有检查，将其添加到待复制列表中。\n遍历每个连接 接下来，系统遍历每个连接，并为从前一步骤中获得的待复制Actor列表中的每个Actor执行以下检查和操作：\n判断当前Actor是否处于休眠状态，通过调用 AActor::NetDormancy。 如果该Actor在此连接下处于休眠状态，则跳过该Actor。 如果尚未打开通道： 判断客户端是否已加载当前Actor所在的关卡。 如果该关卡尚未加载，则跳过该Actor。 判断当前Actor是否与该连接相关，通过调用 AActor::IsNetRelevantFor。 如果Actor与连接不相关，则跳过该Actor。 将所有在连接的“拥有者相关列表”中的Actors添加到此列表中。此时，列表中包含了所有与该连接相关且不处于休眠状态的Actors。然后按照优先级（AActor::GetNetPriority）对这些Actors进行排序，优先级从高到低排序。排序至关重要，尤其是当考虑复制大量Actor时，需要确保优先复制高优先级的Actor。 遍历排序后的Actor列表 对于该连接的每个Actor，在排序后的待复制列表中执行以下操作：\n如果连接尚未加载该Actor所在的关卡，则关闭通道（如果存在）并继续。 每秒检查一次Actor是否与连接相关，调用 AActor::IsNetRelevantFor。 如果在5秒内不相关，则关闭通道。 如果相关且没有通道打开，则打开通道。 如果此连接在任何时刻变得饱和： 对于剩余的Actors： 如果相关时间少于1秒，则强制在下一tick更新。 如果相关时间超过1秒，调用 AActor::IsNetRelevantFor 判断是否在下一tick更新。 对于通过所有检查的Actor，通过调用 UActorChannel::ReplicateActor 将Actor复制到连接。 控制每次调用时复制的客户端数 你可以通过以下几种方式控制 UNetDriver::ServerReplicateActors 每次调用时复制的客户端数：\n引擎配置和命令行参数：\n启动项目时使用 -limitclientticks 命令行参数。 修改引擎配置中的 NetClientTicksPerSecond 值（位于 [/Script/Engine.Engine] 类别）。 命令行参数：\n启动项目时使用命令行参数：-limitclientticks -ini:Engine:[/Script/Engine.Engine]:NetClientTicksPerSecond=\u0026lt;VALUE\u0026gt;，其中 \u0026lt;VALUE\u0026gt; 是每秒希望使用的客户端ticks数。 控制台变量：\n设置 net.MaxConnectionsToTickPerServerFrame 控制台变量。 更多信息请参考 UNetDriver::ServerReplicateActors_PrepConnections。\n将Actor复制到连接 UActorChannel::ReplicateActor 是复制Actor及其所有组件到连接的主要方法。其流程如下：\n判断这是Actor通道打开后的第一次更新。 如果是第一次更新，则序列化需要的信息（初始位置、旋转等）。 判断当前连接是否拥有该Actor。 如果没有拥有该Actor，且该Actor的角色为 ENetRole::ROLE_AutonomousProxy，则降级为 ENetRole::ROLE_SimulatedProxy。 复制该Actor已更改的属性。 复制每个组件已更改的属性。 对于任何已删除的组件，发送特殊的删除命令。 一旦Actor列表已处理完，或通道已饱和，开始考虑下一个连接，并重复该过程直到所有连接都已更新。 更多信息 有关Actor复制的更多信息，请参考以下头文件中的内容：\n/Engine/Source/Runtime/Engine/Classes/Engine/NetDriver.h\n关于 UNetDriver::ServerReplicateActors 的信息。\n/Engine/Source/Runtime/Engine/Classes/GameFramework/Actor.h\n关于 AActor 及其函数和属性的信息。\n/Engine/Source/Runtime/Engine/Classes/Engine/ActorChannel.h\n关于 UActorChannel 和 UActorChannel::ReplicateActor 的信息。\n/Engine/Source/Runtime/Engine/Classes/Engine/EngineTypes.h\n关于 ENetRole 和 ENetDormancy 等类型的信息。\n","date":"2024-12-02T22:17:16+08:00","permalink":"https://boiltask.com/ue/actor-replication/","title":"虚幻引擎中Actor复制流程"},{"content":"简介 想到哪里写到哪里吧，后续有可能再补充。\n虚幻引擎中Actor复制流程 虚幻引擎中网络角色Role相关概念 ","date":"2024-12-02T13:13:25+08:00","permalink":"https://boiltask.com/ue/network-start/","title":"虚幻引擎中网络相关机制"},{"content":"功能简介 参考文档：使用Python脚本化运行虚幻编辑器\n","date":"2024-12-02T12:57:53+08:00","permalink":"https://boiltask.com/ue/editor-python/","title":"虚幻引擎中编辑器下Python的使用"},{"content":"DataAsset简介 一般用于表示一个数据块，功能与DataTable类似，某种程度上可以理解成一个仅有一行的DataTable。\n参考文档：数据资产\n","date":"2024-11-28T13:14:08+08:00","permalink":"https://boiltask.com/ue/data-asset/","title":"虚幻引擎中DataAsset的使用"},{"content":"打开Lyra的默认场景，运行后发现其生成了几个关卡选择器，研究一下生成原理。\n","date":"2024-11-28T13:04:08+08:00","permalink":"https://boiltask.com/lyra/start-map/","title":"Lyra的默认场景中关卡选择器的创建"},{"content":"最近想要细研究一下UE5的官方示例项目Lyra，因此创建了一些相关的博文来记录一下研究过程中的所想，总结一下项目所涉及到的技术点。\n时间点开始于2024年11月，没有提到的话相关项目以此时间点的最新版本为准。\nLyra的项目目前可以在Fab中找到：https://www.fab.com/zh-cn/listings/93faede1-4434-47c0-85f1-bf27c0820ad0\n在虚幻引擎启动器Epic Games Launcher中，可以在库找到Lyra项目，创建项目即可。\n经过测试，虽然更新日志标注了支持UE5.5，不过目前创建的仍然是UE5.1版本，后续先使用UE5.1版本测试。\n","date":"2024-11-27T12:54:43+08:00","permalink":"https://boiltask.com/lyra/download/","title":"虚幻引擎中下载Lyra官方示例项目"},{"content":"在博客部署到线上之后，发现Katex公式无法正常显示，而相同的Html文件在本地环境下是可以正常显示的。\n其中解析的核心代码如下：\n1 2 3 4 5 6 7 8 9 10 11 window.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, () =\u0026gt; { renderMathInElement(document.body, { delimiters: [ { left: \u0026#34;$$\u0026#34;, right: \u0026#34;$$\u0026#34;, display: true }, { left: \u0026#34;$\u0026#34;, right: \u0026#34;$\u0026#34;, display: false }, { left: \u0026#34;\\\\(\u0026#34;, right: \u0026#34;\\\\)\u0026#34;, display: false }, { left: \u0026#34;\\\\[\u0026#34;, right: \u0026#34;\\\\]\u0026#34;, display: true } ], ignoredClasses: [\u0026#34;gist\u0026#34;] }); }) 通过添加日志发现是DOMContentLoaded事件没有触发。\n但是一直没想到是什么原因，直到留意到了线上版本里\u0026lt;script\u0026gt;标签变成了形如\u0026lt;script type=\u0026quot;d6a94c0af8a975daac5bee56-text/javascript\u0026quot;\u0026gt;。\n最终回想起来是Cloudflare开启了Rocket Loader。\nRocket Loader是Cloudflare的一个功能，用于异步加载JavaScript，以提高页面加载速度。\n但是Rocket Loader可能会导致加载顺序变化从而导致某些JavaScript代码无法正常执行。\n暂时关闭了Rocket Loader，问题解决。\n也可以通过在标签里添加data-cfasync=\u0026quot;false\u0026quot;来禁用Rocket Loader，不过考虑还需要修改主题，暂时不做修改了。\n","date":"2024-11-09T12:45:51+08:00","permalink":"https://boiltask.com/knowledge/katex-cloudflare/","title":"Cloudflare环境下开启Rocket Loader之后Katex失效问题"},{"content":"在给博客配置评论区的时候，遇见了一些问题，记录一些。\n为何选择Giscus Stack这个主题默认的评论区是Disqus，但是Disqus是个国外的服务，而且需要收费，因此没有使用。\n同时，主题也支持了其他常见的评论区配置。我首先选择了之前经常注意到的Gitalk，使用Github的Issue来作为评论区的方式当时让人眼前一亮。\n不过配置的时候遇见了一些权限问题，发现Gitalk的权限有些不合理，评论者需要把自己的账号授权给博主来评论，理论上来说博主会获得一些不该有的登陆者的权限。 而且由于跨域问题，还需要找个处理跨域的代理，这又增添了一些隐私问题以及配置成本。\n最后选择了Giscus，它使用自己的App来作为权限拥有者，作为一个第三方，使用着只需要授权给这个应用即可完成Github的授权。\n同时使用起来也更方便和灵活。\n配置方式 在Github中安装Giscus 将仓库授权给应用 在Applications中找到Giscus 在Repository access中选择所存放评论的仓库 前往Giscus的官网继续完成配置 选择一个语言 在仓库中输入所授权的仓库，如：BoilTask/BoilTask.github.io 根据后续的配置描述选择自己所要的配置 在启用 giscus一项中查看所需要的配置 可以在需要的地方填写上生成的配置即可。\n","date":"2024-11-08T13:06:06+08:00","permalink":"https://boiltask.com/knowledge/hugo-giscus/","title":"Hogo中Giscus配置"},{"content":"最近在整理之前写的事件系统：DidaEvent，为此创建了一个文档网站。 使用了Hugo来做了网站生成系统，体验还不错，因此决定把博客也从WordPress迁移到Hugo。\n为什么要迁移 本身其实对静态建站方案是比较排斥的，一是和传统的直接在线编辑的方式比没有那么直观，二来有服务器的方案感觉也更加灵活。\n但是自己维护服务器的成本相对还是比较高的，虽然使用了WordPress，但本身我对PHP的发展也不太看好，而且相对来说也过于重了。\n经过过去的经验，服务器往往由于续费、维护等原因需要迁移，这就导致每次博客都需要重新折腾一番。让写作这件事情也变得成本更高，也很难坚持下来。\n因此使用类似于Hugo之类的静态建站方案就突显出了优势，一是有免费的托管方案，二来直接Markdown的写作方式，也能更灵活的运用起来手头的工具。\n而且真需要一些特殊的模块，其实也可以自己自定义一些空间和页面，因此应该也可以符合目前的需求。\n为什么选择Hugo 备选的静态网站生成器有很多，比如Jekyll、Hexo等等，为什么选择Hugo呢？\nHexo是用的Node.js，生成速度较慢，因此不再考虑了。\nJekyll具有Github的官方支持，可以直接在Github上部署。但是尝试了一个Jekyll的主题，感觉太复杂了。 而且其实我是希望数据源与最后生成的文件分开的，这样也方便管理。\n最后选择了Hugo，一是有合适的主题，二来生成速度快，三来使用的Golang语言也是我比较看好的一种语言。\nDidaEvent的文档使用的主题是Doks，博客使用的主题是Stack。\n迁移过程 简单的部署好框架后，感觉整体还是比较满意的。\n剩下的就是需要迁移原先WordPress的文章了，本来都做好一点一点复制的准备了，不过好在发现了一款插件：wordpress-to-hugo-exporter。 经过插件的导出，得到了一个文章的压缩包，又根据我自己的需求简单调整了一下，一个大体的博客就算搭建完毕了。\n不过有一些陈年老文章，还有一些图片需要再整理一下，就后续再慢慢翻新吧。\n评论区配置 评论区配置的时候还是遇见了一些麻烦，详见：Hogo中Giscus配置\n","date":"2024-11-08T12:46:38+08:00","permalink":"https://boiltask.com/record/202411081/","title":"又双叒叕一次重新梳理了一下博客"},{"content":" 一个写一半的文章，有缘后补。\n一个客户端程序，图像感弱，一心想做服务器。\n心路历程：\n多线程 意义 网络 Socket如何编写 如何部署 单机承载 分布式 可扩展性 先实现基础功能→随着需求演变扩展（承载力、鲁棒性等） ","date":"2024-10-24T18:12:31+08:00","permalink":"https://boiltask.com/record/talk-about-server/","title":"谈谈对服务器的认识"},{"content":" 随着灵感逐步更新，主要用于记录一下感觉这辈子应该学的东西……\n思维导图 mindmap root((知识树)) TEMP 编程语言 C++ Boost asio system gdb Python Java TypeScript Golang Lua 服务器 分布式架构 数据库 Mongo Redis\r","date":"2024-10-09T17:25:11+08:00","permalink":"https://boiltask.com/record/knowledge-tree/","title":"人生知识树"},{"content":"人常说，时间是抚平伤痛的良药。最近的事情就发生的挺多的，凸显出时间过得非常快。亲人离去，无疑是给所有人心口上刺了一刀。而时间如微风，时不时地吹得伤口隐隐做痛。在做一件不相关的事情的时候，突然脑海浮现一处画面，不自觉地又回想起很多事情。\n总感觉应该写得什么，但一开始动手，又不知道从哪开始。虽然知道这辈子总有这天，但爷爷真得离去时，内心却总难以释怀。二十多年的时光，足够在心中种下许多难以淡忘的回忆。\n爷爷是一名老教师，从事教育43年，教书育人成为他最为看重的事情。乡下教师工作环境自然也比不上城里，不过爷爷也尽其所能，为学生们答疑解惑，培养出了一代代的栋梁之才。\n小时候，爷爷有一次把我带到他工作的学校。一个破旧的自行车，沿着乡间小路骑了好久，到地方把我放到了办公室，然后他去教室上课。怎么说呢，漫长的道路、破旧的校园、无聊的教室，对我可能算不上什么有趣的经历，但是爷爷坚持了数十载时光。\n爷爷说话不喜欢别人插话，一有人说小话，总得把人的话按住才能继续说。我常说爷爷这算职业病，可惜以后大抵是没机会说起了。\n爷爷退休也有段时间了，离开了讲台也没离开教育事业。对家中尚未成年的孩子们，爷爷言传身教，每有机会便给我们传递刻苦学习、艰苦奋斗、团结友爱的精神。爷爷自己也是这么做的，团结家人帮助邻里。他曾说：“人要勤劳要善良，谁有困难咱就帮。不图名来不图利，只要有个好心肠”。当时国家补贴乡村教师，爷爷不辞辛劳，为15名民师证明身份。奔波数月，帮助这些教室落实了国家政策，得到了周围人的称赞。\n爷爷是位老教师，也是位老农民。家里没有条件，自己想尽一些办法培养子孙后代。辛劳了一辈子，自己吃苦受罪，都是为了孩子孙子能茁壮成长。后面慢慢地，各家的生活都安稳下来，本该安详晚年生活的。爷爷也不舍得吃穿玩乐，拿着退休金自己确没什么花销。每有机会，就补贴给还在上学的孩子们。爷爷给考上大学的孩子每人一万元，还小的弟弟妹妹都准备了。很难想象，爷爷是怎么攒下的这些。从中，也能感受到爷爷对我们的爱护与期待。\n作为长孙，比起弟弟妹妹们又多了几年的回忆。印象最深的，是每逢过年都回老家爷爷奶奶那一起团圆守岁。除夕做一桌子菜，大大小小的聚在一起，说说话逗逗小孩，讨论讨论联欢晚会的节目，就是我对过年的童年回忆。后面考虑老家条件差，把爷爷奶奶接到城里了，也方便大家能日常看望。过年也就没在老家吃饭了，年味也少了许多。\n爷爷奶奶偶尔会兴起做几句诗，有时间了把这些誊抄到本子上，这些年也攒下了几十首。爷爷给写下了一篇前言，现在读起来也能感受到爷爷的心情。\n1.春节有感\n风风雨雨几十年，过去日子如黄连。\n现在生活赛蜜甜，争取活到一百年。\n注：2016年2月正当全家人欢度春节时，刚好是爷爷奶奶结婚五十年。\n24年过年的时候，一凡来永城做客。家里准备去饭店聚一聚，爷爷奶奶很高兴。前一天，爷爷掏出来第二天准备讲话用的小诗给我看。\n38.热烈欢迎\n一凡来到咱家园，全家高兴笑开颜。\n祝福大家身体好，幸福美满万万年。\n第二天一念，大家鼓掌欢呼，奶奶也不甘示弱献唱念了一首。\n39.吉祥如意\n孙女来了我高兴，全家老少把她迎。\n欢天喜地摆酒宴，吉祥如意到永远。\n爷爷说奶奶这小学没毕业的文化，现在能随口成章可不简单。\n40.知书达理\n范秀英来不简单，用心作诗好多篇。\n文化知识有点浅，知书达理美名传。\n一时间，欢笑声遍布宴席，不曾想爷爷的诗作停留在了40。\n初一得知爷爷检查身体不好，我还在劝我妈说哪能那么严重，数个月过去最后确成了这样。可能病情也随着我爷爷的节俭种下了因，有点小毛病不愿意打扰大家。年前便有些食欲不振，说着大过年的不影响大家心情，也没去医院检查。最后终于是元宵节，才去了趟医院，谁能想到一个好几年的结石，最后能演变成了这么棘手的癌症。\n于是全家人的心思都为之所牵挂，爸爸妈妈、叔叔婶子、姑姑姑父，还有几个小辈，都在想尽办法让爷爷能延续一些时光。可惜天不遂人愿，只能说科学技术还有发展空间。五一放假的时候，爸爸安排了一起照个照片，现在也成为了一家人的回忆。\n爷爷乐观开朗，一直积极地配合治疗。即使到后期病痛已经难以抵抗，也让我们安心工作学习，他会努力和病魔作斗争。为了安慰我们，还时常地说个玩笑来活跃气氛。去看望时的最后一次聊天，爷爷还在让该上班上班，该上学上学，没啥通知不需要来，不希望给我们找麻烦。\n再回去，爷爷已经难以出声了，留下最后的气力看我们一眼。\n2024年9月4日20点14分，爷爷永远离开了我们，享年77岁。\n纵有再多遗憾，往事种种也只能留在心中了。即使离去，爷爷的教诲和精神也将陪伴着我们。一家人也将铭记爷爷的遗愿，经营好自己的生活，愿爷爷在天堂安息，相信未来您也会护佑着我们继续向前。\n欧阳天\n2024年10月4日\n","date":"2024-10-04T20:20:00+08:00","permalink":"https://boiltask.com/qzone/1728044081/","title":"悼念亲爱的爷爷"},{"content":"功能简述 有时候需要还原错误提交，这个时候可以使用Revert命令。\n操作说明 在项目根目录上右键选择TortoiseSVN-\u0026gt;Show log，打开日志窗口。\n英文版 中文版 在所需回退的记录上右键选择Revert changes from this revision，打开确认窗口。\n英文版 中文版 选择Revert即可。\n英文版 中文版 选项说明 Revert to this revision与Revert changes from this revision的区别：\nRevert to this revision指的是复原到此版本，也即执行完之后，本地的状态应该是此版本提交后的状态。\nRevert changes from this revision指的是复原此版本的修改，执行完之后应该是此版本提交前的状态。\n","date":"2023-10-09T10:41:32+08:00","permalink":"https://boiltask.com/knowledge/svn-revert/","title":"SVN回退操作"},{"content":"想知道一个Module被谁引入的，可以通过让其报错来查看堆栈。\n在模块的Build.cs中第一行加入：throw new Exception()。\n编译，查看报错即可。\n","date":"2023-08-02T12:13:26+08:00","permalink":"https://boiltask.com/ue/find-module-reference/","title":"查找Module被谁引入"},{"content":"以下以英文版为例，中文版同理选择对应位置选项即可。\n合并是一个相对的概念，既可以从主干（trunk）合并到分支（branch），也可以从分支（branch）合并到主干（trunk），下文以从主干（trunk）合并到分支（branch）为例。\n功能简述 为了保证一个相对稳定的文件版本，开发过程中有时会新建一个分支（branch） ，这样可以可以直接从分支获取资产以提高稳定性。\n相关操作：SVN切分支\n在我们提交主干（trunk）后，有时候需要把相同的提交传到分支，这个时候可以直接使用SVN的合并（merge）功能来简化操作。\n操作说明 准备工作 需要本地拉取（Checkout）主干目录与分支目录，并尽可能保证干净无多余变化，以降低冲突可能性。\n合并操作 在项目根目录上右键选择TortoiseSVN-\u0026gt;Show log，打开日志窗口。\n英文版 中文版 在所需合并的记录上右键选择Merge revision to...，打开选择目标窗口。\n英文版 中文版 选择本地分支的根目录，等待完成即可。\n解决冲突 若分支的版本与主干对不上，则SVN会尝试合并，如果失败则会提供如何解决冲突的确认框。\n如果涉及到多人维护的文件，请充分沟通以减少异常。\n为了表述清晰，下文把来源文件称之为主干，目标文件称之为分支。\nPostpone - 暂不处理，分支会保持冲突状态，相关文件或目录会标红，SVN会创建临时文件需要及时处理\nAccept Base - 放弃主干的文件，仍然使用分支的文件\nAccept incoming - 使用主干的文件，覆盖分支的文件\nMark as resolved - 标记为解决，但需要注意此时文件仍处于冲突状态，SVN会删除临时文件\n英文版 中文版 合并成功 出现下面的提示说明合并成功，此时分支的文件已经被修改，正常提交（commit）即可。\n英文版 中文版 ","date":"2023-05-29T21:44:15+08:00","permalink":"https://boiltask.com/knowledge/svn-merge/","title":"SVN合并操作"},{"content":"功能简述 有时候需要为了避免开发中的机制造成主干不稳定，我们会拉出来一个新的分支。\n可以使用Switch命令将本地目录切换到目标分支。\n切换分支 在项目工程所在文件夹右键选择Switch...打开分支切换窗口。\n英文版 中文版 输入目标分支，点击确认，然后等待完成即可。\n英文版 中文版 单个目录或文件切换分支 在当前想切换的目录选择switch\n找到想要切换到的分支对应的目录点击确定\n回到这个界面点击ok即可\n注：如单独切换某个目录或文件到指定分支，修改完记得切回原分支\n","date":"2023-03-13T23:14:21+08:00","permalink":"https://boiltask.com/knowledge/svn-switch-branch/","title":"SVN切分支"},{"content":"以下主要以英文版为例，中文版同理选择对应位置选项即可。\n多图警告，可通过左侧目录跳转所需章节。\n功能简述 因为修改某一文件往往需要一段时间，在此期间内如果有人上传了同一文件，如果无法合并就会导致自己提交时产生冲突。\n为了尽量避免此问题，我们可以在修改前就把文件锁定（Lock），这样其他人通过正常操作就无法上传。\n同时如果他也在修改前尝试锁定，就可以得到别人已经锁定本文件的提示，从而也避免了无效工作。\n工具使用 锁定文件 在所需锁定的文件上右键选择TortoiseSVN-\u0026gt;GetLock...，弹出确认窗口。\n英文版 中文版 在窗口里输入锁定原因，点击确认即可。\n英文版 中文版 查看锁定 如果需要查看一个文件有没有被别人锁定，可以右键选择TortoiseSVN-\u0026gt;Check for modifications。\n英文版 中文版 点击Check repository即可扫描出变更，并通过Lock一栏查看锁定者。\n英文版 中文版 释放文件 手动释放 同理，在所需释放的文件上右键选择TortoiseSVN-\u0026gt;ReleaseLock...，弹出确认窗口点击确认即可。\n英文版 中文版 自动释放 SVN默认会在提交文件时解锁对应文件，如果提交后也不想解锁，可以选择Keep Locks。\n英文版 中文版 意外情况 如果锁定时出现了如下提示，则说明已被用户锁定，锁定信息会显示在图示位置（如果锁定者没填则不显示）。\n英文版 中文版 此时需要和该用户沟通锁定原因，协商处理。\n强制锁定 由于锁标记是存在本地文件夹的，有时候由于换机器等原因锁定未释放，此时需要强制解除锁定。\n锁定操作勾选Steal the locks时，会强制无效已锁定状态，把锁定转为此次操作的用户。\n如果文件由其他用户锁定，应尽量避免使用此操作破坏开发流程。\n英文版 中文版 结合引擎 UnrealEngine提供了内置的版本控制工具，可以快捷的实现一些SVN操作，可参考引擎内置版本控制工具进行配置。\n注意事项 由于锁定之后会干扰其他同事操作，因此锁定前需要确认操作的必要性。如果遇见有人询问相关问题，应积极处理。\n未避免误操作，应不定期查看Release Lock列表，看看是否有误锁文件。\n","date":"2023-03-13T19:35:21+08:00","permalink":"https://boiltask.com/knowledge/svn-lock/","title":"SVN锁定操作"},{"content":"功能简述 为了便于多人协作UnrealEngine提供了一个版本控制工具，可结合SVN、Git等工具对蓝图等资产进行版本控制。\n工具使用 配置连接 在引擎的工具栏处有一个Source Control的选项，选择Connect to Source Control弹出确认框。 选择Subversion也即SVN，展示信息输入框。\n按照所需信息输入然后点击Accept Settings即可。 其中几项含义分别如下：\n字段 说明 示例 Provider 使用的版本控制系统 Subversion Repository 仓库的链接 http://..com/svn/***/ User Name 用户名 *** Labels Directory 仓库子路径，比如主干、某一分支等 trunk Password 用户密码 abcdefg123465 资产保存 链接版本管理后，对资产做保存等操作时会弹出确认框，询问是否要CheckOut。\n此操作对应SVN的SVN锁定操作，修改前先锁定，这样避免了多人修改同一蓝图时的冲突。\n如果该资产已经被其他人锁定了，那么点CheckOut时会有如下提示。\n如果大家都遵循此操作，则可以大大减少蓝图冲突的可能性。\n如果不需要锁定蓝图，那么可以点击Make Writable在不锁定的情况下保存。\n资产操作 链接版本管理后，在资产上右键可以展开版本管理的操作。\n其中几项含义分别如下：\n字段 说明 CheckOut CheckOut资产，对应前文的锁定 Refresh 刷新资产版本状态，解决有时候更新不及时的问题 History 打开资产的版本历史 Diff Against Depot 对比资产与仓库中的最新版本 其中最常用的是History打开资产版本历史。\n可以在版本历史里右键选择对比前一版本或对比本地文件。\n注意事项 在资产管理中CheckOut操作对应SVN的Lock操作，会锁定资产防止别人提交，因此会干扰其他同事操作。\nSVN锁定操作前需要确认操作的必要性，如果遇见有人询问相关问题，应积极处理。\n连接SVN后，一些操作会自动对SVN做标记，如移动路径、重命名、删除等，会增加操作时间，耐心等待即可。\n","date":"2023-03-13T19:33:24+08:00","permalink":"https://boiltask.com/ue/source-control-tool/","title":"引擎内置版本控制工具"},{"content":"功能简述 蓝图因为是二进制文件，所以没办法使用svn自带的版本对比工具来比较变更。\n为了解决蓝图对比的问题，UE4提供了一个工具用以展示两个蓝图的区别。\n可以在UE编辑器中可以直接连接版本控制工具，从而提供直接查看版本历史、启动对比工具、冲突提示等功能，配置细节可以查看：引擎内置版本控制工具\n本文描述的是如何从外部调用引擎的对比工具。\n工具使用 直接使用可以在cmd命令提示符窗口输入如下命令：\n1 引擎路径\\Engine\\Binaries\\Win64\\UE4Editor.exe 项目路径\\Meta.uproject -diff 文件1路径 文件2路径 完整示例如下：\n1 D:\\MetaEngine\\Engine\\Binaries\\Win64\\UE4Editor.exe D:\\Meta\\Meta.uproject -diff D:\\Meta\\Content\\Test1.uasset D:\\Meta\\Content\\Test2.uasset 原理是运行引擎时传入-diff参数开启对比窗口，同时传入所需的项目路径与文件路径。\n结合SVN 结合svn的自定义对比工具功能，可以实现双击版本打开对比工具。\n右键项目svn根目录，选择设置（中文版同理）。\n英文版 中文版 在对比工具页签下选择高级选项（中文版同理）。\n英文版 中文版 在此窗口可以根据不同的文件后缀调用不同的对比工具，因此选择新增一条.uasset文件设置。\n英文版 中文版 输入指定命令行即可。\n英文版 中文版 扩展名输入：.uasset\n命令行完整示例如下：\n1 D:\\MetaEngine\\Engine\\Binaries\\Win64\\UE4Editor.exe D:\\Meta\\Meta.uproject -diff %base %mine 其中D:\\MetaEngine\\Engine\\Binaries\\Win64\\UE4Editor.exe为引擎可执行文件，D:\\Meta\\Meta.uproject为项目文件，%base会被转义为svn文件，%mine会被转义为当前文件。\n对比效果 注意事项 由于引擎问题，部分格式的蓝图可能不被支持。\n打开对比工具的过程较为缓慢，请耐心等待。在此过程中不能关闭svn版本历史窗口，以免目标临时文件被清除从而对比失败。\n此工具不能自动合并蓝图，因此仍需要自己手动合并文件，请谨慎操作避免冲突。\n期待UnrealEngine能更为完善！\n","date":"2023-03-13T18:50:21+08:00","permalink":"https://boiltask.com/ue/blueprint-diff/","title":"虚幻引擎蓝图对比工具"},{"content":"在自己维护项目的时候，有的时候会因为忘了切换账号而错误标记了提交者。\n考虑只有自己在用，force强制推送也是可以接受的，所以记录一下可以使用工具来强制修改信息。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #!/bin/sh git filter-branch --env-filter \u0026#39; OLD_EMAIL=\u0026#34;BoilTask@qq.com\u0026#34; CORRECT_NAME=\u0026#34;tian.ouyang\u0026#34; CORRECT_EMAIL=\u0026#34;tian.ouyang@yingxiong.com\u0026#34; if [ \u0026#34;$GIT_COMMITTER_EMAIL\u0026#34; = \u0026#34;$OLD_EMAIL\u0026#34; ] then export GIT_COMMITTER_NAME=\u0026#34;$CORRECT_NAME\u0026#34; export GIT_COMMITTER_EMAIL=\u0026#34;$CORRECT_EMAIL\u0026#34; fi if [ \u0026#34;$GIT_AUTHOR_EMAIL\u0026#34; = \u0026#34;$OLD_EMAIL\u0026#34; ] then export GIT_AUTHOR_NAME=\u0026#34;$CORRECT_NAME\u0026#34; export GIT_AUTHOR_EMAIL=\u0026#34;$CORRECT_EMAIL\u0026#34; fi \u0026#39; 1 git push --force --tags origin \u0026#39;refs/heads/*\u0026#39; ","date":"2023-02-16T19:02:13Z","permalink":"https://boiltask.com/knowledge/git-modify/","title":"强制修改Git记录中提交者"},{"content":" 本文是若干年后补的，也不清楚是什么时候创建的了。\n现在看看这个鸽了的文章，也别有一番感觉，所以补个档。\n上一次好像还是2019总结，复盘一下为啥2020没想到写总结呢。可能整个2020仿佛都沉浸在疫情和项目中，中间穿插了7月入职一周年的时候说要为以后做准备了，然后好像也就没发生什么大事了。毕竟2019年总结也是鸽到了3月份才写，2021年总结这甚至鸽到了年终……\n其实很少设置各种隐藏，也基本不会去删除一些记录，让愿意了解我的人了解我，也是种挺好的事情。\n翻了翻记录，说要写总结是3月，结果又鸽到了7月底。\n20250403：嗯……一鸽又是好多年。\n","date":"2022-11-03T09:06:12+08:00","permalink":"https://boiltask.com/record/summary-2021/","title":"2021总结"},{"content":"String实现 思路 使用Hash方式分配字符串，根据Hash值获取对应桶，与其存在的元素比对，若都不相同，则在桶中新增元素\n需要判断的时候根据Hash值判断\n❓是否需要再判断桶中所有元素\n源码 比对桶中元素时，先对比字符串长度，不同的则认为肯定不相同。\n最新的实现根据LUAI_MAXSHORTLEN = 40判断长短字符串，对于短字符串计算Hash并使用桶机制进行对比，对于长字符串通过随机种子来分配Hash。\n❓长字符串的Hash冲突如何解决\n","date":"2022-08-01T11:21:14Z","permalink":"https://boiltask.com/notes/lua-design-implement-1/","title":"Lua设计与实现"},{"content":" 整理一下总结的客户端向的编程规范，尽可能做到有理有据，后续可能还会不定期修订。\n头文件 Include 头文件 通过宏防止重复包含 #pragma once，所用的所有编译器均支持 包含时尽量细粒化。例如，勿包含Core.h，而在核心中包含需要定义的特定头文件。 尽量直接包含所需的头文件，以便进行细粒化包含。 在 #include 中插入空行以分割相关头文件, C 库, C++ 库, 其他库的 .h 和本项目内的 .h 是个好习惯。 尽可能在cpp中引用其他头文件，避免头文件中直接引用某一类。 可以考虑优先使用声明类的形式来在头文件中使用另一类而在cpp中再真正include，可以有效梳理结构避免循环引用。 尽可能先根据：cpp对应头文件、C++标准库文件、框架头文件、第三方头文件、项目通用头文件、具体功能头文件的顺序来引用文件，方便理清文件引用结构。 引用头文件时尽可能避免使用相对位置，比如....\\NetDef.h，不利于文件梳理以及理解文件结构。 避免使用反斜线\\来标记路径，在一些编译器会存在异常，应使用斜线/来标记路径。 前置声明 所谓「前置声明」（forward declaration）是类、函数和模板的纯粹声明，没伴随着其定义 前置声明能够节省编译时间，多余的 #include 会迫使编译器展开更多的文件，处理更多的输入。 前置声明能够节省不必要的重新编译的时间。 #include 使代码因为头文件中无关的改动而被重新编译多次。 尽可能的使用前置声明，而非头文件，在CPP中包含对应的头文件 减少编译的时间 内联函数 内联函数的合理使用可提高代码执行效率 当函数只有10行甚至更少时才将其定义为内联函数 谨慎对待析构函数，析构函数往往比其表面看起来要更长，因为有隐含的成员和基类析构函数被调用 包含循环和switch语句的函数内联通常得不偿失 声明了内联也不一定会被编译器内联，虚函数和递归函数不会被正常内联 类内部的函数一般会自动内联。所以某函数一旦不需要内联，其定义就不要再放在头文件里，而是放到对应的 cpp 文件里。这样可以保持头文件的类相当精炼，也很好地贯彻了声明与定义分离的原则。 范例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #pragma once // 头文件区 #include \u0026#34;CoreMinimal.h\u0026#34; #include \u0026#34;UObject/ObjectMacros.h\u0026#34; #include \u0026#34;UObject/UObjectBaseUtility.h\u0026#34; #include \u0026#34;UObject/Object.h\u0026#34; #include \u0026#34;TestObject.generated.h\u0026#34; // 前置声明区 class AActor; class AController; class UPrimitiveComponent; struct FAttachedActorInfo; // 结构体定义 USTRUCT() struct FTestStruct { GENERATED_BODY() public: UPROPERTY() int TestValue = 0; ... }; // 委托定义 // 类体定义 UCLASS(BlueprintType, Blueprintable) class ATestObject : public AActor { GENERATED_BODY() public: ATestObject(); .... }; // 内联函数定义 ... 作用域 命名空间 命名空间将全局作用域细分为独立的, 具名的作用域, 可有效防止全局作用域的命名冲突。 禁止使用using namespace xxx; 禁止使用内联命名空间 1 2 3 4 5 namespace X { inline namespace Y { void foo(); } } X::Y::foo与X::foo是等价的 内联命名空间主要用来保持跨版本的 ABI 兼容性。（一般用不到） 在头文件中使用匿名空间违背了C++的唯一定义原则（One Definition Rule（ODR）） 匿名命名空间和静态变量 内部链接性 意味着你在这个文件中声明的这些标识符都不能在另一个文件中被访问。即使两个文件声明了完全一样名字的标识符，它们所指向的实体实际上是完全不同的。 在 .cpp 文件中定义一个不需要被外部引用的变量时，可以将它们放在匿名命名空间或声明为 static 。 不需要被外部引用的变量 不要在头文件中使用 1 2 3 4 5 6 7 xxx.cpp namespace { int xxx = 0; } static int xxx = 0; 局部变量 函数变量尽可能置于最小作用域，并在变量声明时进行初始化\n离第一次使用越近越好，方便阅读者更容易定位变量声明的位置 局部变量在声明的同时进行显式值初始化，比起隐式初始化再赋值的两步过程要高效，同时也贯彻了计算机体系结构重要的概念「局部性（locality）」。 对象：循环作用域外声明要高效的多 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int i; i = f(); // 坏——初始化和声明分离 int j = g(); // 好——初始化时声明 vector\u0026lt;int\u0026gt; v; v.push_back(1); // 用花括号初始化更好 v.push_back(2); vector\u0026lt;int\u0026gt; v = {1, 2}; // 好——v 一开始就初始化 // 低效的实现 for (int i = 0; i \u0026lt; 1000000; ++i) { Foo f; // 构造函数和析构函数分别调用 1000000 次! f.DoSomething(i); } Foo f; // 构造函数和析构函数只调用 1 次 for (int i = 0; i \u0026lt; 1000000; ++i) { f.DoSomething(i); } 属于 if, while 和 for 语句的变量应当在这些语句中正常地声明，这样子这些变量的作用域就被限制在这些语句中了，举例而言: 1 while (const char* p = strchr(str, \u0026#39;/\u0026#39;)) str = p + 1; 静态和全局变量 原生数据类型POD（Plain Old Data） Int, char, float等基本类型，POD类型的指针、数组、结构体 静态生存周期变量 全局变量，静态变量，静态类成员变量和函数静态变量 禁止使用类的静态生存周期变量，因为在这种情况下构造和析构函数调用顺序是不确定的，他们会导致难以发现的bug。（对象A依赖对象B，但对象B早于A析构） 不允许用函数返回值来初始化POD变量，除非该函数不涉及任何全局变量（比如 getenv() 或 getpid() ） 函数的作用域内的静态变量除外，毕竟他们的初始化顺序是有明确定义，只会在指令执行到它的声明那里才会发生 同一个编译单元（cpp）内是明确的，静态初始化优先于动态初始化，初始化顺序按照声明顺序进行，销毁则逆序，不同编译单元之间的初始化和销毁顺序则属于未明确行为 quick_exit替代exit，前者不会执行任何析构，也不会执行atexit绑定的任何handlers 如果确实需要一个class类型的静态或全局变量，可以使用单例模式 类 构造函数 不要在构造函数中调用自身的虚函数，这类调用时不会重定向到子类的虚函数实现，即使现在没有被子类重载，将来也是隐患 C++中的虚函数允许在运行时动态绑定，即在运行时根据实际对象的类型来确定调用哪个虚函数实现。这样的动态绑定是通过虚函数表（vtable）来实现的。在构造函数中调用虚函数时，由于对象尚未完全构造完成，可能会导致虚函数表指针尚未被正确初始化，从而导致无法正确调用虚函数的实现。 当虚函数在构造函数中被调用时，如果基类的构造函数中调用了虚函数，由于动态绑定机制，可能会调用派生类中未被构造完全的函数。这样可能会导致对象的状态不正确，甚至产生未定义的行为。 应该尽量避免在构造函数中进行复杂的初始化逻辑，以保证对象正确地构造完成。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 ABaseMonster::ABaseMonster(const FObjectInitializer\u0026amp; ObjectInitializer) : BornLocation(FVector::ZeroVector) , bCanCrouch(true) , LocomotionComp(nullptr) { AutoDestory = true; SpawnedByWaveSpawner = false; MonsterLevel = -1; SpawnType = ETypeofSpawn::None; NetCullDistanceSquared = FMath::Square(8000.f); AkForFoot = CreateDefaultSubobject\u0026lt;UAkComponent\u0026gt;(TEXT(\u0026#34;AkForFoot\u0026#34;)); AkForFoot-\u0026gt;SetupAttachment(RootComponent); AkForFoot-\u0026gt;PrimaryComponentTick.bAllowTickOnDedicatedServer = false; WeaponComponent = CreateDefaultSubobject\u0026lt;UStarsWeaponComponent\u0026gt;(TEXT(\u0026#34;WeaponComponent\u0026#34;)); SetCollisionEnabled(false); if (USkeletalMeshComponent* SKMesh = GetMesh()) { //SKMesh-\u0026gt;VisibilityBasedAnimTickOption = EVisibilityBasedAnimTickOption::OnlyTickPoseWhenRendered; //SKMesh-\u0026gt;bEnableUpdateRateOptimizations = true; } if (AttributeManagerComponent) { AttributeManagerComponent-\u0026gt;SetOwnerType(EAttributeOwnerType::Monster); SetTeamID(FGenericTeamId((uint8)EFactionType::MonsterFac)); } RespawnRate = 1; bBeingCaptured = false; } 构造函数内不要调类似初始化的函数，因为初始化理论上会失败，如果执行失败返回了一个初始化失败的对象，后续怎么使用该对象是比较奇怪的 隐式类型变换 不要定义隐式类型变换，对于转换运算符和单参数构造函数, 请使用 explicit 关键字 隐式类型转换会隐藏类型不匹配的错误. 有时, 目的类型并不符合用户的期望, 甚至用户根本没有意识到发生了类型转换. 隐式类型转换会让代码难以阅读, 尤其是在有函数重载的时候, 因为这时很难判断到底是哪个函数被调用. 可拷贝类型和可移动类型 如果需要显式定义拷贝和移动，否则就把隐式产生的拷贝和移动函数禁掉 如果需要就让你的类型可拷贝 / 可移动. 作为一个经验法则, 如果对于你的用户来说这个拷贝操作不是一眼就能看出来的, 那就不要把类型设置为可拷贝. 如果让类型可拷贝, 一定要同时给出拷贝构造函数和赋值操作的定义, 反之亦然. 如果让类型可移动, 同时移动操作的效率高于拷贝操作, 那么就把移动的两个操作 (移动构造函数和赋值操作) 也给出定义. 如果类型不可拷贝, 但是移动操作的正确性对用户显然可见, 那么把这个类型设置为只可移动并定义移动的两个操作 如果定义了拷贝/移动操作, 则要保证这些操作的默认实现是正确的. 记得时刻检查默认操作的正确性, 并且在文档中说明类是可拷贝的且/或可移动的 1 2 3 4 5 6 7 8 class Foo { public: Foo(Foo\u0026amp;\u0026amp; other) : field_(other.field) {} // 差, 只定义了移动构造函数, 而没有定义对应的赋值运算符. private: Field field_; }; 如果你的类不需要拷贝 / 移动操作, 请显式地通过在 public 域中使用 = delete 或其他手段禁用之. 1 2 3 // MyClass is neither copyable nor movable. MyClass(const MyClass\u0026amp;) = delete; MyClass\u0026amp; operator=(const MyClass\u0026amp;) = delete; 继承 析构函数，虚函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class A { public: A() { p = new int(5); } ~A() { if (p) { delete p; p = nullptr; } printf(\u0026#34;A::~A()\u0026#34;); } protected: int* p = nullptr; }; class B : public A { public: B() { xx = new int(6); } ~B() { if (xx) { delete xx; xx = nullptr; } printf(\u0026#34;B::~B()\u0026#34;); } protected: int* xx = nullptr; }; B b; 多重继承 最多只有一个基类是非抽象类，其他基类都是纯接口类\n菱形继承？？通常意味着设计出了问题\n接口 C++接口\n蓝图接口\nBlueprintImplementableEvent\nBlueprintNativeEvent\n运算符重载 运算符重载会混淆视听，让人误以为耗时的操作和操作内建类型一样轻巧 成员变量 一般不建议把成员变量标记为public，接口变更时更容易出现遗漏。\n并且一个public的变量，对象自身对其更难以控制，不利于约束其读写行为。\n考虑为其增加public的Set与Get相关接口来实现对其的操作。\n比如如下例子：\n1 2 3 4 5 FString SaveKey = StarsSaveGame-\u0026gt;OverrideSaveKey; if (SaveKey.IsEmpty()) { SaveKey = Class-\u0026gt;GetName(); } 如果调用者错误使用了FString\u0026amp; SaveKey = StarsSaveGame-\u0026gt;OverrideSaveKey，那么就会错误修改成员变量。\n如果改成函数的返回则没有这种隐患，会在编译器得到警告：\nBinding r-value to l-value reference is non-standard Microsoft C++ extension\n1 2 3 4 5 FString\u0026amp; SaveKey = StarsSaveGame-\u0026gt;GetOverrideSaveKey(); if (SaveKey.IsEmpty()) { SaveKey = Class-\u0026gt;GetName(); } 结构体 成员变量初始化 如下：用到的指针一定要进行初始化，在栈上创建结构体时，指针并不会被UE初始化，会造成野指针\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 USTRUCT(BlueprintType) struct FDeathInfo { GENERATED_BODY() public: UPROPERTY(BlueprintReadOnly) EDeadCauserType DeadCauserType = EDeadCauserType::Common; /** 击杀者 */ UPROPERTY(BlueprintReadOnly) AActor* Killer = nullptr; /** 被击杀者 */ UPROPERTY(BlueprintReadOnly) AActor* Victim = nullptr; }; 枚举 如果枚举值需要暴露给蓝图，那么他需要在uint8范围内，否则在一些时候会有超出预期的问题。\n如果想要大数值的枚举，又不想在蓝图中直接写死数值，可以考虑使用FName来与之对应，推荐使用表格维护。\n枚举值类型 枚举值应使用enum class定义并标识所使用的存储结构，而不应该直接使用enum。\n枚举值类型理由 enum无法指定底层所使用的数据类型。同一enum的存储结构在不同的编译器下可能不同，有的时候会造成代码的泛用性降低。改为enum class后，可以指定具体的存储结构，使得开发者对其结构更为可控。\nenum存在向整形的隐式转换。隐式转换在一些时候虽然方便了开发者调用，但在错误复制或编码时没有明确的报错，因此不建议使用隐式转换。改为enum class后，如果需要进行转换可以使用static_cast来显式转换。\nenum无法定义重名。enum为了解决这个问题一般需要在枚举值命名中加入类型名，从而导致在一些情境下枚举值较长。而enum class没有这种问题，可以按照设计的枚举值进行命名。\n枚举值命名 枚举值类型命名为以E开头，如EUnitClientType，即使不暴露给蓝图也可以遵循此规范。\n因为枚举值常常直接拿出值用作比较，使用此规范可以区分出枚举值和普通的类型，也方便代码补全工具查找指定枚举。\n枚举值顺序 除非明确地知道修改顺序不会产生影响，否则不要修改枚举的顺序，有可能造成逻辑或者数据不兼容。\n若枚举值的顺序不应被修改（一般是在配置表或其他逻辑中有调用），考虑用=写出其枚举值。\n若枚举值无固定值，则可以默认视为枚举值顺序改变不影响逻辑。\n枚举值举例 1 2 3 4 5 6 enum class EGameType : uint8 { None, Local, Multiple, }; 异常 要注重异常处理，对于有可能报错的函数，可以考虑增加bool的返回值来标识是否正常处理。\n如果有可能有多种错误，建议返回错误码来标识错误类型。\n错误码 使用EErrorId的枚举来表示错误码。\n避免在逻辑中直接写死int32的错误值，在C++中使用错误码，在蓝图或者Lua中使用FName。\n可以使用UErrorIdLibrary中的函数从枚举/int32/FName之间转换。\n判断一个int32是否是OK可以使用UErrorLibrary::IsErrorIdOK。\n判断一个in32是否是指定枚举需要将枚举转为int32判断。\n避免int32转为枚举来判断，有可能出现不是一个合法的枚举而产生非预期结果。\n函数 输入和输出 按值返回，否则按引用返回。避免返回指针，除非它可以为空。\n输入参数放在所有输出参数之前。\n1 void TestFunction(int p1, bool p2, const FString\u0026amp; p3, bool\u0026amp; bOutResult1, FString\u0026amp; OutResult2); 编写简短函数 如果函数特别长，应思考在不影响程序结构的前提下对其进行分割\n编译器优化一方面是消除常用的子表达式。而函数越大，编译器进行辨识的工作量就越大。从而导致编译时间大大增长。\n常量正确性 不要直接进行值传递，避免一次内存拷贝，传递const引用参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 差 - 返回常量数组 const TArray\u0026lt;FString\u0026gt; GetSomeArray(); // 优 - 返回常量数组的引用 const TArray\u0026lt;FString\u0026gt;\u0026amp; GetSomeArray(); // 差 - 传递数组 void TestSomething(TArray\u0026lt;FString\u0026gt; StringArray) {...} // 优 - 传递常引用数组（避免一次内存拷贝） void TestSomething(const TArray\u0026lt;FString\u0026gt;\u0026amp; StringArray) {...} // 优 - 移动语义（避免一次内存拷贝） void TestSomething(TArray\u0026lt;FString\u0026gt;\u0026amp;\u0026amp; StringArray) {...} 若方法不修改对象，将函数标记为常量函数\n常量成员函数承诺不会修改类的成员变量，提高代码的安全性，防止意外的数据修改和潜在错误。\n代码逻辑更清晰，一眼就能看出这是个只读函数\n给编译器优化空间\n1 2 3 4 void FThing::SomeNonMutatingOperation() const { // 若此代码在FThing上被调用，其不会修改FThing } 游戏中的例子：如果PrintAIData函数定位为const，则我们立马能确认函数体内的AIDataPack成员变量进行的都是只读操作，否则还要去判断是否有写入操作。 1 2 3 4 5 6 7 8 9 10 11 void ABaseMonster::PrintAIData(FString\u0026amp; CompName, FString\u0026amp; TreeDescName, TArray\u0026lt;FString\u0026gt;\u0026amp; BBLine) const { /*if (AIDataPack.ComponmentName.IsEmpty()) return;*/ CompName = AIDataPack.ComponmentName; TreeDescName = AIDataPack.TreeDescription; AIDataPack.BlackboardDescription.ParseIntoArrayLines(BBLine, true); MARK_DIRTY？？ } 若循环不修改容器，则在容器上使用常量迭代 1 2 3 4 5 TArray\u0026lt;FString\u0026gt; StringArray; for (const FString\u0026amp; Str : StringArray) { // 此循环的主体不会修改StringArray } 函数重载 若要使用函数重载, 则必须能让读者一看调用点就胸有成竹, 而不用花心思猜测调用的重载函数到底是哪一种. 这一规则也适用于构造函数 1 2 3 4 5 6 class MyClass { public: void Analyze(const string \u0026amp;text); void Analyze(const char *text, size_t textlen); }; 如果函数单靠不同的参数类型而重载 (这意味着参数数量不变), 读者就得十分熟悉 C++ 五花八门的匹配规则, 以了解匹配过程具体到底如何。另外，如果派生类只重载了某个函数的部分变体，继承语义就容易令人困惑。 缺省参数 缺省参数实际上是函数重载语义的另一种实现方式\n对于子类继承的虚函数，不允许使用缺省参数\n虚函数是动态绑定，而缺省参数值是静态绑定。即虚函数是运行时确定类型，而缺省参数值是编译时就确定的。\n如果重新定义的话，会使得程序使用基类虚函数的默认参数，这显然并不是你想要的结果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;iostream\u0026gt; class Shape { public: enum Color { Red, Green, Blue, }; virtual void draw(Color color = Red) = 0; static std::string ColorToString(Color c) { switch (c) { case Red: return \u0026#34;Red\u0026#34;; case Green: return \u0026#34;Green\u0026#34;; case Blue: return \u0026#34;Blue\u0026#34;; default: return \u0026#34;\u0026#34;; } } }; class Rectangle : public Shape { public: virtual void draw(Color color = Green) override { std::cout \u0026lt;\u0026lt; \u0026#34;Rectangle : \u0026#34; \u0026lt;\u0026lt; ColorToString(color) \u0026lt;\u0026lt; std::endl; } }; class Circle : public Shape { public: virtual void draw(Color color) override { std::cout \u0026lt;\u0026lt; \u0026#34;Circle : \u0026#34; \u0026lt;\u0026lt; ColorToString(color) \u0026lt;\u0026lt; std::endl; } }; int main() { Rectangle R; Circle C; R.draw(); //输出：Rectangle : Green //C.draw(); //报错，静态绑定无法继承默认参数 Shape* pr = \u0026amp;R; Shape* pc = \u0026amp;C; pr-\u0026gt;draw(Shape::Blue); //输出：Rectangle : Blue pc-\u0026gt;draw(Shape::Blue); //输出：Circle : Blue // 静态绑定，使用基类的默认参数，完成派生类的动作 pr-\u0026gt;draw(); //输出：Rectangle : Red pc-\u0026gt;draw(); //输出：Circle : Red return 0; } Lambda表达式 不要使用默认捕获（=, \u0026amp;），所有变量捕获都显式写出来\n非异步的lambda表达式除外，例如：Foreach之类的 异步回调Lambda表达式捕获局部变量\nLambda不要捕获UObject裸指针\n如果再等待异步回调执行之前，捕获的UObject裸指针已被GC且在原来的内存上又分配了新的UObject\n如果此时在回调中对该过期了的UObject进行写入，则相当于在一个未知的内存上写入，可能把新的UObject写坏了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 异步回调的情况 UStarsAssetsManager::Instance()-\u0026gt;AsyncLoad(this, MeshInfo.MeshPath, this, [WeakThis, CallBack, CompPtr, MeshInfo, WithCollision](const FSoftObjectPath\u0026amp; ObjectPath) { if (!CompPtr.IsValid() || !WeakThis.IsValid()) return; ... }); // 非异步的情况 SpecialElementNames.Empty(); ForeachRow\u0026lt;FSpecialElementTableRow\u0026gt;([\u0026amp;](const FName\u0026amp; RowName, const FSpecialElementTableRow\u0026amp; Row) { SpecialElementNames.Emplace(Row.Type, RowName); } ); 配置 使用UDataManger来管理所有表格\n需要使用StarsGetDataTable等接口来读表，禁止使用UE自带的表格读取\n我们会对同结构表格在读取时进行合并处理 考虑热更配置的需求，谨慎对配置进行缓存，优先考虑以RowName去查表。\n回调 谨慎使用回调，尤其需要注意是否存在跨帧逻辑与递归逻辑。\n谨慎缓存Delegate，有可能会使得闭包异常。\n比如在Delegate的回调中，修改了这个Delegate，那么捕获的变量会存在异常。 标准库 UE有自己的一套模板库，大部分情况下应该使用UE，下面是可以在UE中使用的标准库。\n应在新代码中使用，在迁移旧代码时也应该使用。原子性（Atomic）将在所有受支持平台上高效推广。 TAtomic 仅实现了部分功能，Epic后续也不会继续进行维护和改善。 \u0026lt;type_traits\u0026gt; 应在旧版UE特性（trait）和标准特性重叠的地方使用。 \u0026lt;initializer_list\u0026gt; 用于支持初始化器（initializer）语法 正则表达式，UE没有自己的正则表达式方案 std::numeric_limits 可以完整使用。 这个头文件中只有浮点比较函数可以使用 排版与格式 命名相关 命名（如类型或变量）中的每个单词需大写首字母，单词间通常无下划线。例如：Health 和 UPrimitiveComponent，而非 lastMouseCoordinates 或 delta_coordinates。\n类型名前缀需使用额外的大写字母，用于区分其和变量命名。例如：FSkin 为类型名，而 Skin 则是 FSkin 的实例。\n模板类的前缀为T。\n继承自 UObject 的类前缀为U。\n继承自 AActor 的类前缀为A。\n继承自 SWidget 的类前缀为S。\n接口的前缀为I。\n枚举的前缀为E。\n布尔变量必须以b为前缀（例如 bPendingDestruction 或 bHasFadedIn）。\n其他多数类均以F为前缀，而部分子系统则以其他字母为前缀。\nTypedefs应以任何与其类型相符的字母为前缀：若为结构体的Typedefs，则使用F；若为 Uobject 的Typedefs，则使用U，以此类推。\n特别模板实例化的Typedef不再是模板，并应加上相应前缀，例如： 1 typedef TArray\u0026lt;FMytype\u0026gt; FArrayOfMyTypes; 即使不暴露给蓝图，也可以遵循此命名规范以适应UE的规范。\n类型和变量的命名为名词。\n方法名是动词，以描述方法的效果或未被方法影响的返回值。\n所有返回布尔的函数应发起true/false的询问，如IsVisible()或ShouldClearBuffer()。\n若函数参数通过引用传递，同时该值会写入函数，建议以\u0026quot;Out\u0026quot;做为函数参数命名的前缀（非必需）。此操作将明确表明传入该参数的值将被函数替换。\n若In或Out参数同样为布尔，以b作为In/Out的前缀，如 bOutResult。\n返回值的函数应描述返回的值.命名应说明函数将返回的值。此规则对布尔函数极为重要。请参考以下两个范例方法：\n1 2 3 4 5 // True的意义是什么？ bool CheckTea(FTea Tea); // 命名明确说明茶是新鲜的 bool IsTeaFresh(FTea Tea); 对于缩写单词，推荐仍然使用首字母大写其余小写的格式\n可以避免陷入什么是缩写什么不是的争议中\nPHP-\u0026gt;Php 对于复杂变量名可以获得更清晰的展示\n如HTTPSubsystem-\u0026gt;HttpSubsystem UE内部变量两者都有，以仅大写首字母为主\n命名范例\n1 2 3 4 5 6 7 8 9 float TeaWeight; int32 TeaCount; bool bDoesTeaStink; FName TeaName; FString TeaFriendlyName; UClass* TeaClass; USoundCue* TeaSound; UTexture* TeaTexture; FPlayerIdentifier PlayerId; 代码格式 一行不超过120个字符\n尽量不使用非ASCII编码，文件编码必须为UTF-8\n缩进使用制表位\\t\n大括号格式必须一致。在Epic的传统做法中，大括号固定被放在新行。请遵循此格式。\n固定在单语句块中使用大括号。例如：\n1 2 3 4 if (bThing) { return; } if-else语句中的所有执行块都应该使用大括号。此举是为防止编辑时出错——未使用大括号时，可能会意外地将另一行加入if块中。多余行不受if表达式控制，会成为较差代码。条件编译的项目导致if/else语句中断时，也会造成不良结果。因此务必使用大括号。 1 2 3 4 5 6 7 8 if (bHaveUnrealLicense) { InsertYourGameHere(); } else { CallMarkRein(); } switch语句\n一定有Default条件，其中包含有break，以防在默认条件后添加新的条件。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 switch (condition) { case 1: ... // 落入 case 2: ... break; case 3: ... return; case 4: case 5: ... break; default: break; } 注释 规范 无所谓英不英文，代码是项目组内的人看的，方便大家读懂就行\n函数注释\n大概功能描述\n各个参数的描述\n返回值的描述\n其他信息：可选择使用 @warning、@note、@see 和 @deprecated 记载额外相关信息。此类注释应在其他注释后单列一行声明。\n1 2 3 4 5 6 7 8 9 10 11 /** * @brief 判断所给定义的道具是否是确定的 * 比如如果是随机品质的定义，就不是确定的 * @param ItemDef 所需检查的物品定义 * @param CheckQualityNum 是否需要检查该道具是否仅有一个品质 * 如果检查并且发现该道具仅有一个品质 * 那么即使定义随机也会认为是唯一的 * @return 返回值的意义 */ UFUNCTION(BlueprintCallable, Category=\u0026#34;Item\u0026#34;) static bool IsItemDefCertain(const FBagItemDef\u0026amp; ItemDef, bool CheckQualityNum); 原则 编写含义清晰的代码： 1 2 3 4 5 // 错误示范： t = s + l - b; // 正确示范： TotalLeaves = SmallLeaves + LargeLeaves - SmallAndLargeLeaves; 编写有用的注释： 1 2 3 4 5 6 7 // 错误示范： // increment Leaves ++Leaves; // 正确示范： // we know there is another tea leaf ++Leaves; 不要对低质量代码进行注释——重新编写这些代码： 1 2 3 4 5 6 7 8 // 错误示范： // total number of leaves is sum of // small and large leaves less the // number of leaves that are both t = s + l - b; // 正确示范： TotalLeaves = SmallLeaves + LargeLeaves - SmallAndLargeLeaves; 不要让代码与注释自相矛盾： 1 2 3 4 5 6 7 // 错误示范： // never increment Leaves! ++Leaves; // 正确示范： // we know there is another tea leaf ++Leaves; TODO 对那些临时的, 短期的解决方案, 或已经够好但仍不完美的代码使用 TODO 注释。\n标记一些未完成的或完成的不尽如人意的地方, 这样一搜索, 就知道还有哪些活要干, 日志都省了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 while (PriorityQueue.Num() \u0026gt; 0) { logger.CheckLoop((__FUNCTION__)); //取出优先队列头 auto\u0026amp; PopData = PriorityQueue.HeapTop(); // 先判空一下，TODO: 后面查一下循环内销毁问题 if (!PopData.SmeltComp.IsValid()) { PriorityQueue.HeapPopDiscard(DataPredicate); continue; } } 其他相关 Sizeof 尽可能的使用sizeof(varname)代替sizeof(type)\n假设varname的类型变了，sizeof(type)大概率会忘改造成bug\n迭代器 前置自增效率更高，少了一次拷贝\n迭代器失效的情况\nTArray\n增加导致的内存重分配\n删除元素\n插入元素\n死循环 无符号整数错误使用导致的死循环 1 for (unsigned int i = 10; i \u0026gt;= 0; --i) { ... } 容器的size()返回类型size_t是无符号整数 1 2 3 4 5 6 std::vector\u0026lt;int\u0026gt; vec; vec.push_back(1); for (auto idx = vec.size(); idx \u0026gt;= 0; idx--) { cout \u0026lt;\u0026lt; \u0026#34;===== \\n\u0026#34;; } while循环，条件永远不满足\n死循环检查工具\nFDeadLockDetector\n死循环时崩掉并打印主线程堆栈 浮点数 判断浮点数是否相等 1 2 3 float f; if (f == 0.2) {} // 错误用法 if (abs(f - 0.2) \u0026lt; 0.00001) {} // 正确用法 std::vector\u0026lt;bool\u0026gt; 尽量不要在vector中存放bool类型，vector为了做优化，它的内部存放的其实不是bool。 空指针 空指针尽量使用nullptr而非NULL\n1 2 3 4 5 6 7 8 9 10 11 12 void func(char*) { cout \u0026lt;\u0026lt; \u0026#34;char*\u0026#34;; } void func(int) { cout \u0026lt;\u0026lt; \u0026#34;int\u0026#34;; } int main() { func(NULL); // 编译失败 error: call of overloaded ‘func(NULL)’ is ambiguous func(nullptr); // char* return 0; } 数值溢出 1 2 3 4 5 6 7 8 const int32 RetryToken = FMath::RandRange(0, INT_MAX); // 这里会随机出负数 ##RandRange 实现 static FORCEINLINE int32 RandRange(int32 Min, int32 Max) { const int32 Range = (Max - Min) + 1; //INT_MAX的情况下，一定溢出 return Min + RandHelper(Range); } 内存 常见问题 避免使用原生数组，尽量使用UE容器\n原生数组无法检查越界 空指针未判空\n空指针导致的崩溃占大多数\n防御性编程\n缓冲区溢出\nsprintf，printf，memcpy，memset，strcat，strcpy等等\n上述函数拷贝内存的时候没有检查是否越界，如果发生越界会把其他不相干的内存写坏，导致无法预料的bug\n1 2 3 4 5 6 void foo() { char szName[10]; int n = 0; strcpy(szName, \u0026#34;asdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdf\u0026#34;); } 返回局部引用\n1 2 3 4 5 int* foo() { int xxx = 0; return \u0026amp;xxx; } 指针未初始化\nUObject成员带UPROPERTY，会被自动初始化为nullptr\n普通指针未初始化，指向任意地址\nif判断已经无效，向野指针内写入数据 注意：USTRUCT的指针成员就算带UPROPERTY也不会初始化位null\n不正确的类型转换\n使用C++的类型转换，避免C类型转换\nstatic_cast，不使用C类型转换\nconst_cast，去掉const限定符\nreinterpret_cast，指针类型和整形或其他指针之间进行不安全的相互转换\n当程序执行不正确的类型转换时，就会发生不可预测的结果。这可能会导致程序崩溃写坏内存或产生不正确的输出。\n1 2 3 4 5 6 7 int main() { int num = 10; double *ptr = (double*)\u0026amp;num; // 不正确的类型转换 *ptr = 5.0; // 写越界 std::cout \u0026lt;\u0026lt; *ptr \u0026lt;\u0026lt; std::endl; return 0; } Memcpy, memset用于非POD类型，把vtable的指针给破坏掉了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class A { public: A() {} virtual void test() { printf(\u0026#34;%d\u0026#34;, nn); } protected: int nn; }; class B : public A { public: B() {} virtual void test() override { A::test(); printf(\u0026#34;B::test, %d\u0026#34;, nn); } }; B b; memset(\u0026amp;b, 0, sizeof(b)); 函数内自销毁，导致后续代码访问或写入成员变量时写坏内存\n宠物切换状态会停掉行为树，而此函数在行为树Task节点中直接执行（Task内停掉行为树）\n行为树Task节点尝试删掉行为树Owner的Actor（危险操作、应延迟一帧执行）\n有自销毁操作时需小心，考虑清楚是否需要延迟一帧\n循环操作没有取引用，导致发生了结构体拷贝\nLambda表达式自销毁，内部引用的捕获变量被销毁后使用引发的内存问题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 TWeakObjectPtr\u0026lt;UWorldManager\u0026gt; thisObject(this); Stars::Message::PvpTrigger triggerData = trigger; GetWorld()-\u0026gt;GetTimerManager().SetTimer(PvPingTimerHandle, FTimerDelegate::CreateWeakLambda(this, [thisObject, triggerData](){ if (!thisObject.IsValid()) return; if (thisObject-\u0026gt;m_GuildManager==nullptr ) { return; } int32 DefenEndTime = AStarsGameState::GetWorldDayZeroTime(thisObject.Get()) + triggerData.defendendtime(); int32 worldTime = AStarsGameState::GetWorldTime(thisObject.Get()); if (worldTime \u0026gt; DefenEndTime \u0026amp;\u0026amp; thisObject-\u0026gt;m_WorldInfo.PlanetPVPStatus != EPlanetPVPStatus::None \u0026amp;\u0026amp; DefenEndTime \u0026gt; 86400) { //防守结束 thisObject-\u0026gt;m_WorldInfo.PlanetPVPStatus = EPlanetPVPStatus::None; thisObject-\u0026gt;m_GuildManager-\u0026gt;OnPlanetPVPStatusStart(EPlanetPVPStatus::None); thisObject-\u0026gt;m_GuildManager-\u0026gt;OnPvpBattleEnd(); SetWorldInfomation(thisObject-\u0026gt;m_WorldInfo); } if (AStarsGameState::GetWorldIntTime(thisObject.Get()) \u0026gt;= triggerData.enttime()) { //完全结束 thisObject-\u0026gt;m_WorldInfo.PlanetPVPStatus=EPlanetPVPStatus::None; thisObject-\u0026gt;m_WorldInfo.PVPStatusStartTime=0; thisObject-\u0026gt;m_WorldInfo.PVPStatusEndTime=0; thisObject-\u0026gt;m_WorldInfo.PVPDefenseStartTime=0; thisObject-\u0026gt;m_WorldInfo.PVPDefenseEndTime=0; thisObject-\u0026gt;m_WorldInfo.IsPlanetBattleStatues=false; thisObject-\u0026gt;m_GuildManager-\u0026gt;OnPlanetPVPStatusStart(EPlanetPVPStatus::None); thisObject-\u0026gt;m_GuildManager-\u0026gt;OnPVPBattleStateChanged(false); thisObject-\u0026gt;m_GuildManager-\u0026gt;OnPvpBattleEnd(); // 这里Lambda表达式被销毁，导致thisObject被销毁 thisObject-\u0026gt;GetWorld()-\u0026gt;GetTimerManager().ClearTimer(thisObject-\u0026gt;PvPingTimerHandle); // 好在这里是读内存不是写，没有造成更坏的情况 SetWorldInfomation(thisObject-\u0026gt;m_WorldInfo); } }), 1, true); 智能指针 智能指针\n一个裸指针使用多个智能指针包裹\n前一个智能指针销毁后导致内存被销毁，后面的再写入导致内存写坏 1 2 3 4 5 int* rawPtr = new int(5); TSharedPtr\u0026lt;int\u0026gt; p1 = MakeShareable(rawPtr); TSharedPtr\u0026lt;int\u0026gt; p2 = MakeShareable(rawPtr); p1 = nullptr; *p2 = 7; TSharedPtr\n引用计数 TUniquePtr\n只能转移所有权 注意循环引用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class B; class A { public: ~A() { std::cout \u0026lt;\u0026lt; \u0026#34;~A\u0026#34; \u0026lt;\u0026lt; std::endl; } TSharedPtr\u0026lt;B\u0026gt; b; }; class B { public: ~B() { std::cout \u0026lt;\u0026lt; \u0026#34;~B\u0026#34; \u0026lt;\u0026lt; std::endl; } TSharedPtr\u0026lt;A\u0026gt; a; }; int main() { TSharedPtr\u0026lt;A\u0026gt; a = MakeShared\u0026lt;A\u0026gt;(); TSharedPtr\u0026lt;B\u0026gt; b = MakeShared\u0026lt;B\u0026gt;(); a-\u0026gt;b = b; b-\u0026gt;a = a; a = nullptr; b = nullptr; return 0; } TWeakPtr\n解决循环引用 容器 循环内删除与添加\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void erase(std::vector\u0026lt;int\u0026gt; \u0026amp;vec, int a) { for (auto iter = vec.begin(); iter != vec.end();) { // 这个正确 if (*iter == a) { iter = vec.erase(iter); } else { ++iter; } } for (auto iter = vec.begin(); iter != vec.end(); ++iter) { // error if (*iter == a) { vec.erase(iter); // error } } } 拷贝到一个新容器中再做循环删除\n使用迭代器\n内存重分配问题\nTArray\nTMap也存在此问题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 struct TestStruct { int a = 0; bool b = false; float c = 0.0f; FString s; ~TestStruct() { UE_LOG(LogTemp, Log, TEXT(\u0026#34;~TestStruct\u0026#34;)); } }; TMap\u0026lt;int, TestStruct\u0026gt; structMap; TestStruct* val1 = \u0026amp;structMap.Emplace(1); TestStruct* val2 = \u0026amp;structMap.Emplace(2); for (int i=0;i\u0026lt;10000;i++) { structMap.Emplace(i); } UE的内存管理 GC机制 UE使用标记清除算法实现GC，当对象的引用链不可达时，GC会回收该对象所占用的内存。在进行GC之前，UE会从根集出发对所有UObject对象进行标记，标记活动对象，并清除所有未被标记的非活动对象。\nGC的触发通常在特定时机，如关卡切换、游戏循环周期等，以避免对游戏性能造成过多影响。\n开发者在UE中需要注意正确管理对象引用，避免出现不必要的长期引用，以确保GC可以正确回收不再使用的内存资源，从而提高游戏性能和稳定性。\n弱指针 通过UObject的弱指针判断其是否在生命周期内\n通过GUObjectArray中的索引来指向具体的UObject\n自增量校验指向的合法性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ATestActor* pActor = GetWorld()-\u0026gt;SpawnActor\u0026lt;ATestActor\u0026gt;(); FTimerHandle handle; GetWorld()-\u0026gt;GetTimerManager().SetTimer(handle, [pActor]() { // 完犊子了，野指针写入！！！ pActor-\u0026gt;Test(); pActor-\u0026gt;Destroy(); }, 2, false); // 强制GC pActor-\u0026gt;Destroy(); CollectGarbage(GARBAGE_COLLECTION_KEEPFLAGS); // 新的TestActor复用原有内存 ATestActor* pActor2 = GetWorld()-\u0026gt;SpawnActor\u0026lt;ATestActor\u0026gt;(); 非主线程中使用UObject或者其弱指针的问题\nUObject是在主线程中被GC掉，所以非主线程中无法预料其生命周期\n所以在非主线程中尽量不访问UObject或其弱指针，在外部主线程中将非主线程需要处理的数据全部备份好，通过Lambda表达式传递进去，任务处理完回到主线程后再访问UObject的弱指针\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 TWeakObjectPtr\u0026lt;UBuildingSearchProxy\u0026gt; WeakThis(this); uint8 Id = WeakThis-\u0026gt;Id; FString SearchInput = WeakThis-\u0026gt;SearchInput; TArray\u0026lt;FName\u0026gt; List = WeakThis-\u0026gt;List; AsyncTask(ENamedThreads::AnyBackgroundThreadNormalTask, [WeakThis, Id, SearchInput, List] { if (!WeakThis.IsValid()) return; TSet\u0026lt;FName\u0026gt; SearchResult; for (const FName\u0026amp; Part : List) { if (Id != IdCounter) break; #if WITH_EDITOR if (Part.ToString().Contains(SearchInput)) { SearchResult.Add(Part); continue; } #endif const FItemTableRow* pRow = UDataManager::FindRow\u0026lt;FItemTableRow\u0026gt;(Part); if (pRow != nullptr \u0026amp;\u0026amp; pRow-\u0026gt;DisplayName.ToString().Contains(SearchInput)) { SearchResult.Add(Part); } } AsyncTask(ENamedThreads::GameThread, [WeakThis, SearchResult] { if (!WeakThis.IsValid()) return; if (WeakThis-\u0026gt;Id == IdCounter) { WeakThis-\u0026gt;PostSearchResult.Broadcast(SearchResult); } WeakThis-\u0026gt;SetReadyToDestroy(); }); }); 成员变量保存UE的接口裸指针\n无法判断其生命周期，应保存UObject的弱指针\n使用的时候再将其Cast为接口指针\n1 2 3 4 5 TWeakObjectPtr\u0026lt;UObject\u0026gt; CauserAttributePtr; //伤害造成者 TWeakObjectPtr\u0026lt;UObject\u0026gt; TakerAttributePtr; //伤害承受者 IAttributeInterface* GetCauserAttributeInterface() const; IAttributeInterface* GetTakerAttributeInterface() const; 网络 Proto 禁止直接缓存消息的Proto结构，内存有可能会被重新分配或回收。\n如果需要保存调用项目封装的接口，或者使用Proto上的CopyFrom接口。\n考虑使用FByteArray或者FByteCompressedArray来快捷保存通用数据。\n日志 现状：该有日志的地方没有，不该有的地方疯狂打，导致出bug时很难通过日志判断。\n日志规范 各功能模块的重要事件，尽量记录（只要不是频繁重复发生）\n无用信息或过于频繁打印的就不要输出了（可通过Verbosity等级控制）\n新增加的模块，尽量记录足够还原现场的日志\n涉及玩家数值的行为，如物品得失、经验获得、货币流通、装备升级等，尽量记录\n如果数量太大可以考虑归并后打印\n避免三字符序列\n在C和C++中，三字符序列是一种特殊的字符序列，用两个问号（??）开头，并由另一个字符结尾。例如，\u0026quot;??=\u0026ldquo;代表#，\u0026rdquo;??/\u0026ldquo;代表\\，等等。这些三字符序列是为了在早期的编码系统中处理一些没有对应字符的情况而设计的，但在现代的编码系统中，这些三字符序列已经不再使用。\n当编译器在转换三字符序列时遇到问题时，就会报错：\u0026ldquo;trigraph converted to \u0026rsquo; \u0026rsquo; character\u0026rdquo;。这意味着编译器无法正确地将三字符序列转换为预期的字符，通常是因为在转换时出现了错误或者遇到了无法识别的三字符序列。\n1 UE_LOG(LogAStar, Error, TEXT(\u0026#34;Particle Type Shrink Error????!!\u0026#34;)); CheckList 裸指针成员变量未初始化为空\n局部变量未初始化使用\n数组越界\n内存拷贝缓冲区溢出\nUObject需要强引用的未用UPROPERTY包裹\nUObject不需强引用的没有用弱指针\nUSTRUCT中包含UObject成员未用UPROPERTY\n成员变量保存UE接口的裸指针\n构造函数内调用虚函数\n基类析构函数未声明成虚函数\n指针未判空使用\n异步回调捕获所有\u0026amp;,=\n异步回调Lambda表达式传入裸指针\n异步回调未判断Upvalue的生命周期\n异步回调Lambda表达式引用捕获局部变量\nLambda表达式自销毁导致的Upvalue生命周期问题\n使用异常机制\n返回局部变量的引用或指针\n手动管理内存的申请和回收未成对\n不正确的类型转换\n容器的循环内删除错误\n智能指针循环引用\nTArray取值未判断边界\nTArray写入未判断边界\nTArray前值指针或引用在触发内存重分配后野掉\nTMap前值指针或引用再触发内存重分配后野掉\nTMap取值前未判断是否存在\n非主线程中对UObject的使用\n使用类对象的静态存储周期变量\n出现菱形继承\n间接无限递归调用导致栈溢出\n死循环\n关键事件未加日志\n该用PushModel未用\nMemset, memcpy用于非POD结构\n浮点数判断是否相等导致的问题\nUE_LOG传入的参数类型不匹配导致崩溃\n设置的Timer没有回收，导致Timer泄漏\n除0问题\n循环操作该用引用时没有用引用\n尽量使用UE内置typedef的基础数据类型（如：int32, int64，不要使用long, size_t之类的）\n可复制变量不能是Public，不能是蓝图可写\n配置表所有的引用都要使用软引用\n参考文献 https://docs.unrealengine.com/4.27/zh-CN/ProductionPipelines/DevelopmentSetup/CodingStandard/\nhttps://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/\nhttps://www.zhihu.com/question/26901409/answer/1858690571\nhttps://github.com/Icassell/UE4-Style-Guide-1\n","date":"2021-05-10T21:34:36+08:00","permalink":"https://boiltask.com/knowledge/client-style-guide/","title":"客户端编程规范"},{"content":"参考下文配置Protobuf：\nhttps://github.com/protocolbuffers/protobuf/tree/master/src#c-installation\u0026mdash;windows\n所需环境 推荐提前安装以下环境：\nWindows 10 Git Cmake Visual Studio 2019 生成工具 在https://github.com/protocolbuffers/protobuf/releases/latest下载protobuf生成工具。\n文件应形如protoc-$VERSION-win32.zip，解压其中的bin/protoc.exe，放于Dep/protobuf/bin下。\n编译依赖 参考下文编译所需依赖：\nhttps://github.com/protocolbuffers/protobuf/blob/master/cmake/README.md\n在https://github.com/protocolbuffers/protobuf/releases/latest下载protobuf源文件。\n文件应形如 protobuf-cpp-[VERSION].tar.gz。\n解压全部文件到文件夹中，此处以D:\\Protobuf为例。\n打开cmake-gui，选择source code文件夹为D:\\Protobuf\\cmake，build the binaries文件夹为目标文件夹，此处以D:\\Protobuf-build为例。\n点击Configure，选择Visual Studio 2019。\n取消配置中的所有勾选。\n留意CMAKE_INSTALL_PREFIX值，此值为之后运行安装后目标文件存放位置。此处以D:/Protobuf-install为例。\n点击Generate生成解决方案，之后Open Project打开解决方案。\n选择MinSizeRel与x64，之后生成解决方案。\n右键INSTALL，选择生成，目标文件会被生成在前面所配置文件夹中。\n复制D:/Protobuf-install/include到项目/protobuf/include。\n复制D:/Protobuf-install/lib到项目/protobuf/lib。\n配置项目 在Visual Studio的项目中，参考如下方法配置Protobuf。\n配置头文件引用 右键项目属性，点击C/C++，在附加包含目录之中，填入protobuf头文件目录，如：\\protobuf\\include。\n配置静态链接 右键项目属性，点击链接器，在附加库目录之中，填入protobuf依赖文件目录，如：\\protobuf\\lib。\n展开链接器一栏，选择输入，在附加依赖项之中，填入protobuf依赖文件名，如libprotobuf.lib与libprotobuf-lite.lib。\n","date":"2020-07-18T17:39:54Z","permalink":"https://boiltask.com/knowledge/cpp-protobuf/","title":"Windows下C++版本Protobuf使用方法"},{"content":"修饰普通变量 修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。\n普通变量，当程序执行到它的定义处时，为其在栈上分配空间，在函数执行结束时被释放掉。使用static修饰变量，可以使得函数中的值保存至下一次调用。\nstatic修饰的静态局部变量只执行初始化一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放。\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; using namespace std; void staticLocalVar() { static int a = 0; // 运行期时初始化一次, 下次再调用时, 不进行初始化工作 cout \u0026lt;\u0026lt; \u0026#34;a=\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; ++a; } int main() { staticLocalVar(); // 第一次调用, 输出a=0 staticLocalVar(); // 第二次调用, 记忆了第一次退出时的值, 输出a=1 return 0; } 修饰普通函数 表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为static。\n修饰成员变量 修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。\nC++中需要一个数据对象为整个类服务，可将其定义为静态数据。\n比如一个类的所有对象都要调用的值，设为static后只需要修改这个值，就能使得所有对象都可以使用新值。\n修饰成员函数 修饰成员函数使得不需要生成对象就可以访问该函数，但是在static函数内不能访问非静态成员。\nstatic与const static const等价于const static，修饰成员变量把二者结合起来理解。\n不可以同时用const和static修饰成员函数，二者的含义矛盾。\n","date":"2020-03-23T05:30:15Z","permalink":"https://boiltask.com/knowledge/cpp-static/","title":"C++中static关键字用法总结"},{"content":" 当用const进行修饰时，根据const位置的不同有三种不同效果。\n判断的标准是：const修饰谁，谁（在const后面）的内容就是不可变的。\n修饰变量 const int a;，表示变量不可被改变。\n修饰指针 分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）。\nconst int *p = \u0026amp;a; *p不可变，*p是p指向的内存单元的内容，所以*p不可变也就是p指向的内存单元的内容不可变。p是可变的，即p指向的内存单元（变量）是可变的，但是p指向谁，谁的值就不可变。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include\u0026lt;iostream\u0026gt; using namespace std; int main(){ int a = 10; const int *p = \u0026amp;a; //不可以用*p改变a的值 printf(\u0026#34;a = %d \\n\u0026#34;, a); //*p = 20; //语法错误，*p不可被修改 a = 40; //可以直接赋值进行修改 printf(\u0026#34;a = %d \\n\u0026#34;, a); int b = 11; p = \u0026amp;b; printf(\u0026#34;b = %d \\n\u0026#34;, *p); int *q = \u0026amp;a; *q = 20; //可以用*q改变a的值 printf(\u0026#34;a = %d \\n\u0026#34;, a); a = 30; //给a赋值也可以修改a的值 printf(\u0026#34;a = %d \\n\u0026#34;, a); return 0; } \u0026gt;a = 10 a = 40 b = 11 a = 20 a = 30 int* const p = \u0026amp;a; const修饰p，指针p是不可变的，即p指向的内存单元不可变。p的指向不可变，p指向的内存单元的内容可以变。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include\u0026lt;iostream\u0026gt; using namespace std; int main(){ int a = 10; int* const p = \u0026amp;a; //p的指向不可变 printf(\u0026#34;a = %d \\n\u0026#34;, a); *p = 20; //可以修改p指向的内存单元的内容 printf(\u0026#34;a = %d \\n\u0026#34;, a); int b = 11; //p = \u0026amp;b; //语法错误 printf(\u0026#34;b = %d \\n\u0026#34;, b); *p = b; //修改了a的值 printf(\u0026#34;a = %d \\n\u0026#34;, a); return 0; } \u0026gt;a = 10 a = 20 b = 11 a = 11 const int* const p = \u0026amp;a; const修饰了*p和p，所以p指向的内存单元和p指向的内存单元的内容都不可变。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include\u0026lt;iostream\u0026gt; using namespace std; int main(){ int a = 10; const int* const p = \u0026amp;a; //const修饰了p和*p printf(\u0026#34;a = %d \\n\u0026#34;, a); //*p = 20; //不可修改p指向的内存单元的内容 printf(\u0026#34;a = %d \\n\u0026#34;, *p); int b = 11; //p = \u0026amp;b; //不可修改p的指向 printf(\u0026#34;b = %d \\n\u0026#34;, b); return 0; } \u0026gt;a = 10 a = 10 b = 11 修饰引用 指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include\u0026lt;iostream\u0026gt; using namespace std; int main(){ int a = 10; int \u0026amp;r = a; //定义了a的引用r printf(\u0026#34;a = %d \\n\u0026#34;, r); r = 20; //也修改了a的值 printf(\u0026#34;a = %d \\n\u0026#34;, a); //int \u0026amp;rm = 3; //语法错误，引用不可直接绑定常量 const int \u0026amp;rm = 3; printf(\u0026#34;\u0026amp;rm = %d \\n\u0026#34;, rm); //常量可以绑定const引用 /* 编译器分配内存空间，把rm放在符号表中 int temp = 3; const int \u0026amp;rm = temp; */ int b = 5; const int \u0026amp;rb = b; printf(\u0026#34;b = %d \\n\u0026#34;, rb); //rb = 6; //const修饰引用不可更改 double p = 3.1415; //int \u0026amp;rp = p; //引用类型需与绑定类型相同 const int \u0026amp;rp = p; //可以绑定到const引用上 printf(\u0026#34;\u0026amp;rp = %d \\n\u0026#34;, rp); //常量可以绑定const引用 /* double p = 3.1415; int temp = p; const int \u0026amp;rp = temp; */ return 0; } \u0026gt;a = 10 a = 20 \u0026amp;rm = 3 b = 5 \u0026amp;rp = 3 const引用的目的,禁止通过修改引用值来改变被引用的对象。\n没有const reference，因为引用本身就是 const pointer。\n普通引用相当于int* const e const int \u0026amp;e相当于const int* const e 修饰成员函数 说明该成员函数内不能修改成员变量。\n有const修饰的成员函数，对数据成员只能读取，没有const修饰的成员函数，对数据成员可读可写。 const对象可以调用const成员函数，不能调用非const修饰的函数。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; using namespace std; class Test { public: Test(int v) : a(v) {} int getA() { return a; } int getAc() const { return a; } int a; }; int main() { Test test(2); cout \u0026lt;\u0026lt; test.getA() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; test.getAc() \u0026lt;\u0026lt; endl; return 0; } \u0026gt;2 2 相当于，C++对类的成员函数数中的this指针做了隐藏。本质上，const修饰的是被隐藏的this指针所指向的内存空间，修饰的是this指针（const Class *this）。\n","date":"2020-03-23T05:00:00Z","permalink":"https://boiltask.com/knowledge/cpp-const/","title":"C++中const关键字用法总结"},{"content":"今天是2020年3月8日的0点，拖了小半年的2019总结，终于在2020年都已经过去四分之一的时候开始动笔了。说起总结2019，其实在去年国庆左右的时候就已经开始计划了，零零散散写了些东西。本来计划元旦认真总结一下的，结果一拖又拖了好久。但，再不总结恐怕就再也没有兴致了，所以还是来动笔吧。\n2020年对大多数人来说都是一个不平常的年份，而2019年对我来说，比之更有过之而无不及。从这一年中零零散散，短至一句话，长至一篇文的随笔之中，也能感受到这一年来的心路历程。虽然可能很多东西已经想不到当时的背景，没办法完全记录下来当时的所想了，但是总还能给历史留下点见证。\n2019的故事，自然从元旦开始说起。2019年1月1日，离开了租住了半年的房子，一时间突然特别伤感。回忆起2019，伴随着考研、实习、过年、毕设、求职、入职、进京等一系列的故事。考研的失败对我来说是个不太愿意聊起的事情，这个故事掺杂了很多话题。\n1月2号，是踏上去郑州实习的日子。虽然不喜欢智游的安排，但是不得不说，在智游的几周，我学到了我想要学习的知识。作为酝酿毕业设计良久的我，自然希望能够系统的学习一下前端的知识。在智游的学习，虽然浅显，但是确实给了我入门很大的帮助。后面能够顺利的驾驭Vue等框架，也有很多这段经历的功劳。\n顺嘴说一句，确实想再试试智游楼下的竹筒饭了。\n学着学着，过年了，2019年的春节其实倒也没什么说的。只不过伴随着考研成绩的出炉，给了人生道路又一个抉择。其实在人生的大方向上，从幼儿园到到目前为止还基本没怎么变过。幼儿园到小学五年级之间喜爱美术等艺术性的领域，小学五年级到初三喜欢小说剧本等文艺性的领域。这其中，又掺杂着对计算机魅力的向往。再往后，突然发现电子游戏这一行业，完美契合一路以来的心路历程。既满足了对计算机的向往，又满足了对文学性艺术性的追求。\n所以，不挺好的吗。\n然后，开学了。在得知没办法在智游继续学习前端知识之后，自然不准备在智游熬时间了。于是待了一天之后选择了回学校，准备毕业设计和求职。\n我现在对学弟学妹们说没有什么追求的话，毕业设计随便做做就好了。那么，对于我来说，为什么想这么认真地准备一下毕设呢。首先，自然是来源于大一以来对OJ系统的好气。再来，正如我那天写下的。可能，这是我最后一次花这么久的精力去做一个网站。\n人的一生，是要学会舍得的。我自认在这方面做得并不好，尝尝不舍得扔垃圾，考研资源这么久过去了也没舍得删除。但是在人生的选择上，既然百分百选择了游戏行业，那么其他领域可能注定不会有太大成就了。毕竟，我自认综合天赋不高。\n事实证明CodeOJ项目，足够给我的大学生活画上一个不一定完美但完整的句号。从起初的项目构思，到理论验证，实际开发，测试与维护。一段段的心路历程，回忆起来都是难忘的。\n犹记得在清明节之前，我甚至没决定好后台采用什么技术。还是假期去南京的火车上，抱着Ipad找相关资料，决定了使用PHP框架PhalApi来做后台服务器。\n说起来Ipad虽然没给考研带来太多帮助，但确实给毕设和后面的学习提供了很大的帮助。\n前端的Ivew框架来源于最早寻找好看的前端模板时，发现了一套易用、美观还组件丰富的UI框架。包括Vue也是当时维护HPUACM官网时，自己研究了一下简单的用法。\n整个开发过程吧，也算体会了一下简单的全栈工程师的感觉。回忆起来，也是一种乐趣。每天晚上搞个通宵，特别是当时前期晚上还断电，于是又研究怎么延长一波晚上的工作时间。唉，那种不用考虑其他事情，一心只需要把自己喜欢的东西做完的机会，恐怕是不多了。\n到了毕设后期临近毕业，又开始研究了一下小程序。也是赞叹微信能做出一个这么简单易用的平台，也对互联网环境起着引领的作用。包括我自己，也对基于微信小程序的小游戏很看好。依托于微信的用户量，一个小型精品很容易在朋友圈之间流行开来。\n再然后，三方协议的催促，开始尝试投一波简历。虽然四月份网易的笔试通过，面试一塌糊涂的经历给了一定的心理负担。但是最终好歹还算顺利拿到了Offer。\n所以，工作的事情也不用愁了。\n那么，毕业吧。\n毕业照拍的还算难忘，与同学们共同生活了四年。大学四年时间，人生最美好的时光之一。很幸运，能和这群人一起度过。\n再然后，东西打包收拾回家。过了一周，启程前往北京。\n北京这个城市给我的体验一直不太好，并没有给我向往的感觉。但是，进了北京，却依旧能感受到这个城市的魅力。看着以往一二十年，只能在电视网络上知晓的建筑，在自己的眼前飘过。那种感觉，还是别有一番滋味。\n入职，前一个月迷迷糊糊地度过了。好在老大与项目组大佬们的帮助下，慢慢熟悉了整个的工作流程。改改BUG，问问问题，也就度过了又一两个月。到了临近国庆节，开始接到了工作以来的第一个新功能。\n密藏宝箱系统，整个制作来说不算特别困难，但也确实在很多点上有所卡顿。所以，国庆节注定是要加个小班了。但是，当完成的时候，内心的喜悦自然也是不用提的。不管怎么说，这也是自己进入游戏行业的里程碑事件。\n再往后，机器人的修改，NPC的修改，慢慢地能感受到自己的提升，也继续沉醉着游戏行业的魅力。\n所以，2019大抵也就是这样了。\n说他特殊吧，确实挺特殊的。正如2015年那样。2015衔接了高考与大学，2019衔接了大学与工作。说起来是挺分裂的两种感受，高考之前的紧张与迷茫，大学之后的自由与梦想；毕业之前的懵懂与无措，工作之后的憧憬与拼搏。\n但是说他普通吧，好像也很普通。只是一个年份，发生大事随便写写几千字也足以记录了。况且，比起2020的广泛性特殊来说，2019好像也算不得什么。这么想，晚点写总结，可能和早点写的感受确实不会完全一样。不好说孰是孰非吧，但感觉下次这种东西还是尽量早些写吧，毕竟晚点有啥事想补充大不了再说呗。\n这半年个人文件夹数据大小增加缓慢，也确实是没产出什么自创性的东西了。也许，后面有机会要继续进行适度的创作。毕竟灵感这种东西，不经常挖掘真的会越来越枯竭的。\n国庆节假期的时候，站在天安门广场上，就有一种很特殊的情绪。那一瞬间，你就感觉前几天还是世界焦点的地方，此时此刻就在你的面前。仿佛这一瞬间，你自己就变成了世界的焦点。但愿，有朝一日能给这个世界留下一笔属于我的记忆。\n剩下的，就是零零星星根据留下的只言片语再说几句了。唉，真的是可惜很多脑子里的东西没办法全部写下来。\n很多事情不是技术可以搞定的。比如BiliBili的弹幕功能，做出来可能很容易，但是培养一个弹幕社区与文化，却需要更多的努力。正是我认为游戏行业，不单单是技术引领的。技术的发展，给了游戏设计者更多的发挥空间。但对于同时代的玩家来说，只需要使用此时代已有的技术，就足以让其快乐了。这个，也是游戏制作者需要正视的一个问题。一个游戏是否好玩，有的时候并不在于技术是否高端，而要看技术是否完美解决了设计者的需求。\n世界上的很多事情应该都不是纯粹的技术问题，可惜我自己是没什么头脑的，只能自己尝试去努力创造自己的价值。\n现在还年轻，还能有打小怪兽的梦，所以就还挺开心的。想想很多人，可能不知不觉间就忘记了自己在追寻什么。或者说，变得更为“佛系”，无所谓未来追寻什么。我是感觉，能有一个努力的目标，并且这个目标对于世界来说是有正向价值的，就挺好的。\n六岁那年，在门口小摊位抽个次奖，一毛钱一次。然后第一次里面什么都没有，第二次的时候抽到了一个飞镖，三个角的那种，还能调整角度。很高兴，然后绑了一个绳子每天甩着玩。这段故事应该之前也说过，一些奇思妙想也是从小就根深蒂固地。包括目前，也能零零星星想起来小时候的一些想法，还有思考时候的一些状态和场景。虽然从目前的眼光来看，很多想法可能并没有参考价值，设置随便用系统地方法去设计都要更好一些。但有想法这件事情本身，就足够我难忘一辈子了。\n作为游戏制作者，只要人家肯玩就应该谢谢人家，至少在玩的时候，玩家此时是比起那些知名作品更愿意在你身上花费时间的。所以要珍惜每个愿意尝试了解你的玩家，尽量不要亲手毁掉这一份信任。这，也是我在此愿意许下的承诺。\n有的时候，确实感觉到了自己的平庸。不光是生理上的，而且是教育等各方面的平庸。但是，好在游戏行业并不一定是个非要争第一的行业。就好像去年玩过一段时间的《家国梦》，虽然卸载很久不玩了，之后可能也不会再去下载。但玩的那段时间，确实给了我快乐和一定的思索。\n所以，努力提高自身综合素质。尽量能给大家带来一些快乐和情感，我想我的人生价值也就实现了。当然，在这个过程中能让自身和在乎我的人以及我在乎的人幸福，那就再好不过了。\n想说的时候可以说，不想说的时候可以不说。这，也就是日志的魅力了。2019就总结到这吧，2020年再见了。\n我有预感，2020年也同样是一个值得总结的一年。\n也许这一年之后，可以加大日志的频率。没事写写的话，若干年之后再看一定是别样的感受。\n","date":"2020-03-07T17:17:48Z","permalink":"https://boiltask.com/record/202003081/","title":"从大学到工作 – 我的2019总结"},{"content":"原理15 记忆和技巧 在游戏设计领域有很多游戏种类，有更广义的游戏分类方法把游戏分为记忆游戏和技巧游戏。\n在记忆游戏中需要用到试错法、记忆识别、本能反应（平台跳跃游戏）以及对游戏本身的掌握。技巧游戏需要体能或精神上的实力和条件来完成。许多游戏在特定情况下对这两种类型都有涵盖。\n记忆游戏可能会在玩了一段时间之后让玩家感到无聊，解决这个问题的方法是在保持游戏机制、故事和结果不变的前提下为游戏加入一些随机性。\n原理16 “极小极大”与“极大极小” 与“最小/最大化”（Min/Maxing）不同，“极小极大”（Minimax）指出，在一个零和博弈中，每个博弈者会选择一个能最大化他们回报的混合策略，由此产生的策略和回报的组合是帕累托最优的。\n在经济博弈论中，极小极大原理常被用来减低机会成本（也就是后悔）。\n极大极小原理解决的问题是玩家致力于防止最差的后果，想要避免错误决定导致的最坏结果。\n在数学上，极小极大算法是一个递归算法，用来在参与人数确定（通常是两个）的博弈中做出下一步的决定。\n极小极大也被应用于没有其他对手，但结果取决于不可预知事件情形下的决策。在这样的情形下，可能出现的结果与有两个参与者的零和博弈类似。\n原理17 纳什均衡 纳什认为，在任意一个混合策略博弈中有这样一个策略组合，在该策略组合上，任何参与人都有有限的选择；而当所有其他人都不改变策略的时候，没有人会改变自己的策略，因为改变策略会导致该博弈者得到的得益降低，那么这个策略组合就是一个纳什均衡。\n纳什均衡原理可用于预测博弈者在他们最优策略的基础上互动的结果。\n纳什均衡可以通过数学方法，基于回报矩阵（payoff matrix）得出。\n囚徒困境博弈\n假设有两个小偷A和B联合犯事、私入民宅被警察抓住。警方将两人分别置于不同的两个房间内进行审讯，对每一个犯罪嫌疑人，警方给出的政策是：如果一个犯罪嫌疑人坦白了罪行，交出了赃物，于是证据确凿，两人都被判有罪。如果另一个犯罪嫌疑人也作了坦白，则两人各被判刑8年；如果另一个犯罪嫌人没有坦白而是抵赖，则以妨碍公务罪（因已有证据表明其有罪）再加刑2年，而坦白者有功被减刑8年，立即释放。如果两人都抵赖，则警方因证据不足不能判两人的偷窃罪，但可以私入民宅的罪名将两人各判入狱1年。\n收益矩阵\nA╲B 坦白 抵赖 坦白 -8，-8 0，-10 抵赖 -10，0 -1，-1 可以看出对于个人而言，坦白的收益总比抵赖要高。\n关于案例，显然最好的策略是双方都抵赖，结果是大家都只被判1年。但是由于两人处于隔离的情况，首先应该是从心理学的角度来看，当事双方都会怀疑对方会出卖自己以求自保、其次才是亚当·斯密的理论，假设每个人都是“理性的经济人”，都会从利己的目的出发进行选择。这两个人都会有这样一个盘算过程：假如他坦白，如果我抵赖，得坐10年监狱，如果我坦白最多才8年；假如他要是抵赖，如果我也抵赖，我就会被判一年，如果我坦白就可以被释放，而他会坐10年牢。综合以上几种情况考虑，不管他坦白与否，对我而言都是坦白了划算。两个人都会动这样的脑筋，最终，两个人都选择了坦白，结果都被判8年刑期。\n囚徒困境中，在都选择背叛时，任何一个人单独改变策略都不会使自己的收益更高，所以都背叛就是纳什均衡点。相反在都合作的情况下，任何单独的改变状态都会增加自己的收益，所以合作不是纳什均衡点。\n原理18 帕累托最优 许多博弈论的例子都是零和命题——其中参与一方的收益来自于另一方的损失。然而，也有一些情况下，玩家可以在不影响其他玩家地位的情况下让自己的地位上升。意大利经济学家维尔弗雷多·帕累托（Vilfredo Pareto）在财富和收入分配等领域研究了这样的关系。人们以他的名字命名了他的发现。\n当有人得到了一定数量的货物、金钱、土地等，而且是从一个人手上转移到了另一个人手上（比如通过销售），这就是“帕累托交换”（Pareto shift）。\n如果一个交换过程在改进了系统中一个人的状态的情况下没有直接损害系统中其他人的利益，这个变化就是一个“帕累托改进”（Pareto improvement）。\n当一个角色扮演游戏（roleplaying games，RPG）中的角色升级自己的能力和技能时，这就是一个帕累托改进。另一方面，如果一个玩家偷了另一个玩家的装备，这就不是一个帕累托改进，因为这会让被偷的一方能力削弱。\n当一个系统达到了没有帕累托改进的余地的状态，它就达到了“帕累托最优”（Pareto optimality），又称“帕累托效率”（Pareto efficiency）。这时，系统中的任何一个交换都是零和的。\n帕累托最优的一个重要特性是它不一定是一个公平合理的分配，它也并不意味着这个分配是可能的分配方案中最好的。它只是说明当前的选择已经被扩展到了没有任何人可以在不损害其他人利益的情况下进行改善的地步。\n“占优策略”（参见原理84“占优策略”）并不总是与帕累托最优一致。在囚徒困境中，占优策略（也就是背叛）就跟帕累托最优（双方合作）不一致。这是因为双方“保持沉默”相当于一系列同步的帕累托改进——每人都在不使对方状况变差的情况下让自己的状况变好了。没有人能在不让对方变差的情况下让自己的状况变好（要让自己的状况变好只能背叛对方，也就意味着对方的状况变差）。\n在合作的游戏或系统中，帕累托最优是一个理想的目标。\n在竞争的游戏中如果达到了帕累托最优，则往往意味着僵局或不可避免的冲突。\n帕累托改进（及其最终带来的帕累托最优）在资源平衡的游戏机制中也经常被使用。达到帕累托最优并不意味着这就是最佳组合，只是表示所有的资源都被有效地使用了。\n原理19 得益 得益（Payoff）是指在游戏中一个决定所带来的产出或结果，不管是正面的还是负面的，不管它如何被计量。\n不是所有的玩家玩游戏都是出于追求同样的回报（巴特尔的玩家分类理论）。\n假定游戏中的所有玩家都是理性自利的，也就是说每个人的行为都以获得自己的最佳回报，并且将其最大化为目的，根据玩家自己的价值体系，每个决定对玩家带来的影响都是合理的。\n在博弈论中，得益可被分为基数的和序数的。\n基数得益（Cardinal Payoffs）是固定量的值。\n序数得益（Ordinal Payoffs）采用得益产生的顺序而不在于其数值的大小来描述结果。就像竞赛一样，排序名次比时间和距离更重要。\n当游戏是同步进行的，也就是说，当一个玩家必须在不知道其他玩家会怎么做的情况下采取行动时，通常会有一个正则形式的表格来显示得益，这样我们就可以比较游戏双方所做选择的结果。\n在平衡一个游戏的得益时需要注意的一点是：在决策过程中的理性自利（没有与其他玩家之间的可信承诺）通常会给玩家带来最坏的结果。\n在“囚徒困境”中，我们要注意尽管这个游戏看起来是基数得益的，它实质上却是序数得益的。因为唯一重要的一点是它们的顺序保持不变。\n原理20 囚徒困境 囚徒困境（Prisoner’s Dilemma）是一个简单的博弈，它解释的是为什么两个博弈者在博弈时会分别作出不是对自己最有利的，却能通过合作达成一个更好结果的选择。\n博弈可以按照传统方式进行，如单一决策，或重复决策，产生基于过去结果的行为模式。\n如果两个博弈者连续完成了多次囚徒困境的情景，并基于对方之前的行为各自形成了一个对对方的看法，这两人都将开始基于对方的行为来规划自己的策略。连续玩N（N已知）次游戏时，最合理的决定是每一次都背叛对方。然而在实践中，大多数人都不会超理性到能够意识到对他们来说能得到最大利益的做法是：每一次都与对方合作，然后在最后一次背叛对方。假定他们会这么做，这也会让他们推断对方也与他们一样理性，也会做出同样的事情。于是他们在倒数第二轮选择背叛，如此循环往复，回到开头。而如果N是未知的，这个做法就不再是游戏的“占优策略”，而是一个“纳什均衡”。\n罗伯特·阿克塞尔罗德（Robert Axelrod）提出了博弈者的策略要获得成功的4 个必要条件。\n要友好（Nice）。不要首先背叛（尽可能的合作）。 不嫉妒（Non-Envious）。不要试图比对方得到更多（优化平衡积分）。 要报复（Retaliating）。当对方背叛你时一定要报复（不要永远合作）。 要宽容（Forgiving）。报复之后要改回合作（如果对方不背叛你的话）。 威廉姆斯·普雷斯（William Press）和弗里曼·戴森（Freeman Dyson）提出了一个被称为“零行列式策略”（Zero-Determinant Strategy）的新方法，该方法认为一个博弈者可以通过让对方相信他们会做出某个特定选择的方式来控制博弈，该博弈者通过利用假信息来从对方那里获得好处。\n原理21 解谜游戏的设计 设计师斯科特·金（Scott Kim）这样定义“谜题”（puzzle）：“有趣的东西，并且有一个正确的解答”。这个定义尽管模糊，却至少提出了一个定义谜题的有用元素：它是有解的。\n一个好的谜题对它的受众而言既不能太容易也不能太难。要让一个谜题游戏做到这一点，一个好的方式就是面包屑式（breadcrumbs）的引导。例如在数独（Sodoku）或纵横填字（crossword）游戏中，随着一个一个空格被填上，玩家也就得到了对剩下的空格更多的提示，那些剩下的空格也就变得越来越好填了。\n一个好的谜题应该需要一个聪明、智慧的解决方法，而不是通过简单的蛮力就能解决。\n一个谜题的产生可以是随机的，但当玩家开始解答它时，它必须是确定的。\n最后，一个好的谜题必须让玩家知道目标是什么，他们需要进行怎样的操作来达成这个目标。谜题”的设计师通过模糊化规则来增加解谜的难度，但是这样的谜题是不公平的。\n当我们设计一个谜题时，要确保：\n在难度上要让玩家保持在一个“心流”的状态 需要一个聪明、智慧的解决方法 是确定的 从其目标和机制上来说是明确而公平的 原理22 石头剪刀布 石头剪刀布（Roshambo），是一种只需要通过手势参与的、同步的、半随机的，零和博弈。\n石头剪刀布可以通过算法对对手的行为模式及其发展趋势进行分析，基于马尔科夫链（Markov Chains）、战略预测和随机数的算法来选择应对的手势。\n这种循环的制约关系已被应用于其他游戏中，以防止占优策略的演进，保证游戏过程中各种类型的元素保持同等的价值。\n石头剪刀布有时也被一些不愿意去探索更有趣的、创新或独特的方法来平衡游戏机制的设计师当作偷懒的依托。如果石头剪刀布方式是我们针对功能设计的唯一策略，我们要小心了。\n原理23 7种通用情感 游戏设计师往往致力于唤起玩家的情感，他们花费很大的精力去研究“兴趣曲线”，以及设法保持玩家对游戏的注意力。\n有7种通用的情感表达是世界的每一种文化公认的。\n惊讶（Surprise） 轻蔑（Contempt） 愤怒（Anger） 喜悦（Joy） 恐惧（Fear） 悲伤（Sadness） 厌恶（Disgust） 情感总是无意识的、稍纵即逝，但可以很容易地通过人们面部的变化看出来。这是情感和情绪的一个显著区别，后者持续的时间更长，并且可以被隐藏和掩饰。\n原理24 斯金纳箱 预测玩家的行为是游戏设计师最基本的需求。其中一个被过分广泛使用的理论流派——行为主义。\n斯金纳做了如下尝试：\n老鼠每次按下杠杆，就给它食物作为奖励；\n老鼠每X次按下杠杆，就给它食物作为奖励；\n在老鼠每隔N分钟后第一次按下杠杆时给它奖励；\n当老鼠每第X（X是随机的）次按下杠杆时给它奖励；\n在老鼠每隔N（N是随机的）分钟后第一次按下杠杆时给它奖励。\n实验结果表明老鼠对几种不同的奖励周期有十分明确的回应方式。有一些奖励周期引起老鼠狂热地一次又一次按下杠杆，以期得到更多食物；有一些则相对温和，造成老鼠按杆的机会相对较少。\n如果要让老鼠尽可能多按杆，最好的奖励周期是以变化比率的形式，也就是使用随机变化的参数。在给老鼠加强“多按就会多得”印象的同时，又让它们摸不清楚到底按多少下才能得到食物。\n玩家与游戏的交互等同于价值，因此，最能引导玩家与游戏产生更多交互的方式就是以随机的周期给用户奖励。采访这些游戏的玩家会发现他们对这个游戏是否“好玩”抱有矛盾的意见，但却承认自己被吸引不停地玩。\n行为主义理论是可以被当作一个推动玩家参与的妙招的。\n有些孩子被要求每周末修剪草坪。对孩子来说有些院子太大了，而且他们从开头就害怕这个苦差事。在盛夏的日头下推割草机可不是他们爱干的事儿。但是他们随后就发现，这个工作越接近完成就变得越轻松，他们割完一行草的速度更快，他们也越来越为即将到手的5美元兴奋。\n这种现象被称为目标的梯度效应（goal-gradient effect）。\n如果玩家知道他将马上能得到奖励，他们会更有动力去完成能让他们得到这个奖励的任务。如果你发现你的玩家在游戏中的某一点逐渐失去他们的兴趣，或许这就是向他们展示他们如果继续下去将得到的奖励的最佳时机。\n原理25 社会关系 对大部分的玩家来说，游戏是一项群体活动，不管是棋盘游戏、卡牌游戏，还是视频游戏。\n这些社交性、合作性的游戏的发展证明在游戏设计中社会关系对增加玩家的兴趣、参与和满意度是非常有效的。\n大多数现代游戏要求设计师至少要考虑激活玩家的社会关系网络。\n邓巴数理论认为，任何一个人的社交网络大概由150个连接，也就是社会关系构成。它是指你能从你的社交网络中的每一个个体中得到的好处，包括互相帮助、互相访问，或通过其他手段帮助彼此。\n社交机制可以是主动的、被动的，也可以介于两者之间。\n有一个心理现象叫“害怕错过”，这是个体寻求能帮助他们被纳入团体的经验的一个很有说服力的理由。\n目标受众的偏好和他们的舒适区都会影响与社会关系相关的设计的一般方法。\n研究受众的喜好并巧妙地使用社交设计方法能够将游戏的复杂性和娱乐性提高一个层次，并最终帮助游戏从市场竞争中脱颖而出。\n原理26 公地悲剧 公地悲剧（Tragedy of the Commons）的含义是，如果一项资源是可供所有人使用的，那么该资源最终一定会被耗尽，而这对所有人都是有害的，长期的损失远大于短期内获取该资源得到的好处。\n公地悲剧的假定条件是在有限的系统内对资源的使用是增长的。\n广义而言，公地悲剧表达了一个人艰难的选择：努力争取物质利益，并由此导致自己和他人的长期损失——寄希望于短期的物质利益能弥补长期损失——或者为了所有人的利益与大家合作来节约资源，但是这样做的风险是，如果有其他人有更好的个人资源，或者有其他人谎称合作实则过度使用公共资源，这个人就吃亏了。\n在游戏中，玩家的策略或游戏的机制都有可能导致公地悲剧。应该有某种协议（或一些特殊的规则来奖励使用资源较少的玩家）来预防玩家们用完所有可用资源。\n对于公地悲剧有两种常见的，并且是相反的解决方案，但是它们都不能理想地解决这个问题。\n资源平等的再分配（共产主义）意味着无法有效利用资源的人依然能得到它，这样有很大一部分被浪费掉或很快被用完。\n另一方面，垄断资源（政府控制）则意味着资源的利用效率远低于腐败、法律法规和特殊利益集团对资源的征用。\n向人们提供足够的资源被过度使用的信息来让他们意识到保护资源的重要，确保对社区的强烈归属感以减少自私的囤积行为和滥用集体财产，建立值得信赖的机构来管理关键资源的分配，以及对负责任的资源利用行为提供激励机制，并惩罚那些不负责任的过度使用行为。\n原理27 信息透明 许多游戏都是围绕着发现隐藏信息的过程而展开的。\n游戏理论将这些信息不透明的游戏归类为“不完全信息（imperfect information）游戏”。\n另一种信息——游戏状态，则在不完全信息游戏的分类下还有所细分。\n在不完全信息游戏中有一个子分类，这类游戏中玩家能够接触到关于游戏环境和规则的所有信息，但不能看到其他玩家的行动状态，这就是完整信息（complete information）的游戏。\n在不完全信息游戏中，那些玩家没有依据对未知进行假设的游戏就是不完整信息（incomplete information）的游戏。\n理解信息透明的概念对于游戏设计师（国内公司通常称为游戏策划）而言有多强大的最后一个关键是，记住信息透明可以是自愿的或非自愿的。\n游戏中有规则规定玩家有时必须向另一名玩家展示手中的一张牌，这张牌本来应该是保密的，这就是非自愿的信息透明。\n自愿信息透明，设立这样的规则通常是为了鼓励玩家虚张声势、双重间谍的行为，并且建立一个互相不信任的氛围。\n原理28 范登伯格的大五人格游戏理论 理解人们的心理是游戏设计的基础。在许多方面，游戏的功能性目标就是激发起玩家采取行动的意愿。\n大五理论认为人类的行为主要是由5类动机驱动的：\n对体验的开放性（Openness to Experience），这一点将那些有创造力、有想象力的人和那些更务实、更循规蹈矩的人区分开来 尽责性（Conscientiousness），人如何控制和缓和自己的冲动情绪 外倾性（Extraversion），这一点将那些追求刺激以及在他人面前的存在感的人，与那些不这么做的人区分开来 随和性（Agreeableness），反应人如何处理与社会和谐的规则相关的问题 神经质或情绪稳定性（Neuroticism），这反应了一个人是否选择经历（或不经历）负面情绪的倾向 每一类人格特质都能被细分为6个子维度，这描述了更加具体的内在驱动。\n“对体验的开放性”就包括以下几个子维度：\n想象力（Imagination），这将那些认为自己的内在精神世界比外部世界更有趣的人跟与他们相反的人区别开来 艺术趣味（Artistic Interest），这关系到一个人如何体验美 情绪性（Emotionality），这指示了一个人意识到自己内心情感状态的程度 冒险性（Adventurousness），区分那些喜欢探索、寻求新事物的人和那些更喜欢已知和常规事物的人 求知欲（Intellect），关于一个人从用他们自己的脑子解决谜题，或者参与进复杂的心理游戏这样的活动中能得到多少满足感 自由主义（Liberalism），衡量一个人希望社会如何发展，是向未来推进、保持稳定不动、还是回到过去。 与想象力相关联的是玩家对幻想和写实的偏好。\n与冒险性相关联的是玩家是更喜欢将探索作为游戏机制的一部分。\n我们抱着同样的目的生活和游戏。\n我们希望在游戏中扮演别人的看法很普遍，但这是错误的。\n注：补充阅读《大五人格心理学》\n原理29 志愿者困境 “志愿者困境”（Volunteer’s dilemma）是群体博弈理论中的一个特殊例子，类似于“公地悲剧”。\n在志愿者困境中，一个人面临的选择是，是否牺牲自己的一小部分利益来让群体中的所有人受益，同时这个人自己不能得到任何额外的好处。而如果这个人不牺牲，并且也没有任何一个其他人这么做，则所有人都要面临严重的利益损害。当然，这个选择是，自己牺牲一小部分时间、经历、钱等等，或是承担等着其他人来做的风险。\n这些情况在互联网合作游戏中屡见不鲜。\n玩家可能会选择不参与一些危险的、但是对团队来说是必须的任务，而是去做更多对自己有好处的任务。他们会假设为了团队的生存和胜利，团队会去承担完成那些危险任务的责任。\n如果这个策略成功，他们会受到鼓励而继续这样的行为——并且可能会有更多的玩家选择这种对自己来说没有风险的做法——这样也就把越来越多的责任转嫁到了仍然愿意执行危险任务的团队成员身上。显然，如果这个趋势继续下去，整个团队（包括那些搭便车者）都会完蛋。\n心得 书中所介绍游戏原理其实很多在目前主流游戏中都有所体现，而学习游戏原理的意义，在于自己不仅限于“感觉这个模块挺有意思，可以拿来借鉴一下”，而是能够根据原理去设计一个模块。\n成品是游戏原理的实际运用，游戏设计的“抄作业”也至少应该明白这道题的答案为何，这样才能在以后的设计中交出一个满意的答卷。\n","date":"2019-11-14T11:00:24Z","permalink":"https://boiltask.com/notes/100principles-2/","title":"游戏设计的100个原理笔记(2) – 第1篇 游戏创新的一般原理（下）"},{"content":"第1章 如何深入高效地学习语言 在比较中学习多种语言时，一些知识能理解得更深刻。所谓语言不同，规则不同。\n知道了语言设计者为解决何种问题而创造了这种语言，以及这种语言经历过怎么样的历史变迁后，慢慢地就能理解为什么需要有这种功能了。\n了解了语言的历史，我们往往更能加深所学。\n第2章 程序设计语言诞生史 优秀的程序员具有三大美德： 懒惰、急躁和傲慢（Laziness, Impatience and Hubris）。\n“急躁”的意思是，程序员忍受不了程序执行的低效。\n“傲慢”的意思是，程序员容不得对错误不管不顾。\n“懒惰”的意思是，一项为了减少总能量支出，而不遗余力地努力的素质。\n程序设计语言是为了给人们带来便捷，但是何为便捷，语言不同，便捷的含义也各不相同。\n语言只是工具，要看通过使用它自己能做出多大成果，应当根据自己的实际情况选择好的工具。\n第3章 语法的诞生 语言设计者制定的规则就是语法。\n第4章 程序的流程控制 在提倡规则让读写程序更轻松的时代潮流中，结构化程序设计应运而生。\n第5章 函数 函数，即把代码的一部分视作有机整体，然后切分出来并为之命名的程序设计机制。\n把相同的操作封装在一起的好处不仅仅在于使程序更简短，也在于能使阅读程序的人无需反复读取相同内容的源代码。从冗长的程序中切分出反复使用的代码将其封装成一个整体，程序就更容易理解了。\n第6章 错误处理 程序在执行过程中也有可能出错，出错时如何处理（错误处理）很重要。错误处理的方法大体可分为两种：使用返回值和使用异常（异常处理）。\n为了提高软件的品质通过检查代码来确认程序员期待的程序行为，这一测评方法也是基于同样的想法。\n发生错误应该停止操作立刻报告，这一设计思想被称为错误优先（fail first）。\n第7章 名字和作用域 给内容或位置取个易于理解的名字，并用该名字来指示它们会更加方便。\n作用域是编写易于理解的代码的有力工具，很多地方都应用了这一概念。\n第8章 类型 类型是人们给数据附加的一种追加数据。\n需要有表示这个值为何种类型的额外的信息，这就是类型。\n第9章 容器和字符串 在不同的语言中，容器的名称不同，性质各异。\n根据容器的使用目的、使用方式和操作类型的不同，最适宜的容器类型也会相应地变化。\n这个地球不是单靠程序员运转的，现实中还有很多不依赖于程序实现方式的解决方案。\n第10章 并发处理 为了实现便利的并发处理，出现了进程和线程的概念。\n执行处理用的线路（CPU）只有一个，在人们察觉不到的极短间隔内交替进行多项处理，尽管在某一瞬间实际只进行一项处理，但人们会觉得似乎有多项处理在同时进行。\n在合适的节点自发进行交替，利用这种方法实现的多任务（并发处理）称为协作式多任务模式。有一个问题，有可能某个处理一直找不到合适的节点进行任务切换从而持续地进行，导致其他处理无法等到执行的机会。\n隔一定时间就进行交替，任务管理器在一定时间后强制中断现在正在进行的处理，以便允许其他程序执行。\n并行执行的两个处理之间出现竞态条件必须同时满足以下三个条件。\n两个处理共享变量 至少一个处理会对变量进行修改 一个处理未完成之前另一个处理有可能介入进来 人们在共享→非共享→共享、协调→非协调→协调、硬件→软件→硬件这样两种对立观念中左右摇摆，不单看片面而是兼顾两面，在平衡中灵活运用或许才是最为重要的。\n第11章 对象与类 在不同语言中，同一个用语的含义可能会有很大差别。\n在 C++ 语言里，类被定义为是“用户可自定义的类型”。\n类的存在只不过是因为人们觉得有了它编写程序会更方便些，而约定的一种事项。\nC++ 语言和 Java 语言的类具有以下几个作用：\n整合体的生成器 可行操作的功能说明 代码再利用的单位 第12章 继承与代码再利用 继承的实现策略大体可以分为三种。\n一般化与专门化 共享部分的提取 差异实现 一般化与专门化，在父类中实现那些一般化的功能，在子类中实现那些专门的个性化的功能\n共享部分的提取，从多个类中提取出共享部分作为父类，子类并否为父类的一种。\n差异实现，继承之后仅实现有变更的那些属性会带来效率的提高。它把继承作为实现方式再利用的途径，旨在使编程实现更加轻松。这些情况下通常子类都不是父类的一种。\n使用方法多意味着继承这种机制有很高的自由度。\n影响范围越广，就越难确定这种修改会不会带来什么问题。这个问题不是单靠在程序设计上下工夫就能解决的，同时也可以把大量的检查工作交给计算机去完成来帮助解决，这叫回归测试。\n里氏置换原则可以表述为：假设对于 T 类型的对象 x，属性 q(x) 恒为真。如果 S 为 T 的派生类，那么 S 类型的对象 y 的属性 q(y) 也必须恒为真。\n对于类 T 的对象一定成立的条件，对于类 T 的子类 S 的对象也必须成立。\n当要继承某种类时，需要考虑该类是否可以被继承。\n多重继承对于实现方式再利用是一种非常便利的方法。\n类具有两种截然相反的作用。一种是用于创建实例的作用，它要求类是全面的、包含所有必需的内容的、大的类。另一种是作为再利用单元的作用，它要求类是按功能分的、没有多余内容的、小的类。\n后记 只要是编程，大概都不可避免要产生一些错误（bug）。为了使程序准确运行，就需要调试（debug）。\n我们很容易更加关注 How 的问题（即如何去实现），实际上，What（要实现什么）和 Why（为什么要实现）的问题也是不可忽略的。\n专栏 要确认理解是否正确，首先得表达出来 为了验证理解正确与否，需要表达出来。只能基于自己的理解说出自己的观点，然后让第三方来判断和检验。\n程序员一直受益于这一点。只有理解了这一点，才能和语言处理器打交道。\n当你不知道该学习什么时 自己到底想做什么，然后再去学习能够达成这一目标的知识。\n具体的知识和抽象的知识 我们不仅要学习具体的知识，更要有意识地去学习那些应用范围广泛的抽象的概念。\n学习讲求细嚼慢咽 在庞大信息量面前心力交瘁的时候有三种战略可供参考：从需要的地方开始阅读，先掌握概要再阅读细节，从头开始逐章手抄。\n从需要的地方开始阅读 明确阅读的目的并弄清楚为达成这一目的需要阅读哪些地方，就可以有针对性地阅读，无需在其他无关的地方花费大量精力。\n先掌握概要再阅读细节 要先掌握概要再渐进式地追求细节，这是大的原则。\n从头开始逐章手抄 当没有明确要做的事情或者想要了解的东西时，当简单浏览的内容过目即忘时，以这种学习状态，不管怎么学也无法获得真知。\n","date":"2019-11-11T13:43:08Z","permalink":"https://boiltask.com/notes/coreconcept/","title":"代码之髓：编程语言核心概念笔记"},{"content":"原理1 游戏的对称性/非对称性和同步性 在对称性游戏（Symmetric gameplay）中，参与游戏的玩家的体验完全一样。\n在非对称性游戏（Asymmetric gameplay）中，参与游戏的玩家的体验并不完全一样。\n游戏中的延迟也会导致玩家看到的画面有不同，这种意外产生的信息不对称可能会产生这样的后果，这便涉及到同步性（synchronicity）问题 。同步的游戏是指在游戏过程中参与的双方同时发动自己的动作。\n原理2 A最大，鬼万能 通过在游戏中途改变定义的大小顺序，或是要求玩家根据自己或团队的目标来重新定义一张最大的牌。这样无需重新洗牌（重新分配资源），便可以改变特定结果。这就给游戏引入了多样性和惊喜，避免了过多的重复。\n改变某张牌的价值，总而组成一个更强力的牌组则为游戏增添了更多的复杂性。（赖子机制）\n原理3 巴特尔的玩家分类理论 理查德·巴特尔 将MUD（ Multi-User Dimension）玩家分为四个基本类型： 成就型玩家 、 探险型玩家 、 社交型玩家 、 杀手型玩家 。\n其用两条轴线分出的4个象限来分析这4种不同的玩家。\n原理4 合作与对抗 当与超过一个玩家一起玩游戏时，有两种可能的玩家类型：合作型和对抗型。\n在合作型的游戏中（co-op play），两个或多个玩家共享一个目标，并且通过共同努力去实现这个目标。 合作游戏通常是两个或两个以上玩家与人工智能选手的对抗。玩家可以交易物品，相互治疗，使用互补的游戏战略（如主战坦克与远程武器的联手使用），或更为动态的方式（如相互给予身体上的增强互补）以通过单个玩家靠自身能力无法通过的障碍物。\n对抗型游戏的概念很简单：一个或一组玩家与另一个（或一组）对抗去取得胜利。通常对抗的玩家中只有一个（或一组）能获胜，除非这个游戏能以平局结束。对抗性的竞争是很多多人游戏的核心，而也有很多单人游戏以之前的最高分为对抗对象。\n个别游戏机制和功能可能会起到鼓励或阻止玩家之间的合作或对抗的作用，有时候会是以意想不到的方式产生作用。\n原理5 公平 当游戏设计中的公平性也是一样——游戏对于玩家必须是公平的。换句话说，游戏必须不偏不倚，不对玩家作弊。（注：与人工智能相关理论中的思路辩证地去看待，换句话说，作弊也必须是为了使玩家获得更佳的反馈。）\n当玩家觉得游戏给了他们不公平的对待时，他们有可能会退出游戏。当玩家觉得其他玩家给了他们不公平的对待时，他们有可能会去惩罚其他玩家。在创建一个玩家会对公平性有要求的系统时记得考虑这个问题。\n在俄罗斯方块游戏中，玩家经常会将游戏中的随机行为看作是不随机的，他们认为游戏是故意给他们不想要的方块。事实上俄罗斯方块中方块的掉落确实是完全随机的，但是玩家会感觉有背后的行为模式，并把这些归咎于想象中的不公平。\n类似地，如果一个游戏的难度在逐步提高的过程中突然出现一个大的飞跃，会被玩家认为不公平——事实上这也确实不公平。游戏的难度应该平稳地逐渐上升，这样玩家才不会觉得被欺骗或受到不公正的待遇。\n第一，对于那些友好的人们，其他人愿意牺牲他们自己的物质利益。也就是说，如果在一个游戏中玩家们表现友好，那么一个独立的玩家会更容易表现出利他行为或是愿意为友好的玩家们牺牲一些自己的物质利益。\n第二，基本上可以认为是第一条的反面——玩家将会愿意损失自己的物质利益去惩罚那些不友好的玩家。如果一个玩家有意对其他玩家不友好，另一位玩家为了让他受到惩罚，将宁愿在一定程度上损失自己的物质利益。\n最后，第三条规则是，第一和第二条规则在物质损失越小的情况下越容易发生。换句话说，玩家需要放弃的物质利益越小，他们越容易参与到前面提到的那些利他或是惩罚行为中去。\n原理6 反馈循环 反馈循环有两种不同的类型。\n在一个正反馈循环中，达成一个目标能够获得奖励，而这让继续达成目标变得更容易。反馈循环的另一种形式是负反馈循环。其中达成一个目标会让下一个目标更难达成。 解决负反馈循环的难题其实很容易：为玩家完成游戏的目标提供奖励 。 我们可以考虑将正反馈和负反馈配合起来，或者是找到一个对玩家的实力不造成真正影响的奖励方式，比如新的皮肤或者动画效果之类装饰性的奖励。\n原理7 加德纳的多元智能理论 霍华德·加德纳（Howard Gardner）提出了多元智能理论，该理论认为，作为个体，我们每一个人在认知方式上都各有长处和短处。\n数理逻辑认知：通过批判性思维和逻辑来认知的过程，有时也被含糊地称为左脑学习。\n空间认知：通过想象将物体在空间中的情形视觉化来认知的过程。\n语言认知：以听觉或书面的方式，通过文字来认知的过程。\n身体-运动认知：通过身体或者周围的物理世界的移动来认知的过程。\n通过身体或者周围的物理世界的移动来认知的过程。这些人如果能站起来，走动走动，或者与他们正在学习的东西有身体上的接触，就能学得更好。\n音乐认知：通过各种和音乐有关的东西，包括音调、旋律、节奏和音色来认知的过程。\n通过各种和音乐有关的东西，包括音调、旋律、节奏和音色来认知的过程。这种类型的人能从童谣或任何以音乐形式呈现的东西中学习。\n人际交往认知：在与其他人的互动中来认知的过程。\n在与其他人的互动中来认知的过程。这类人可能非常有爱心或者是一位交际花。\n内省认知：自我反省和认知的过程。\n自我反省和认知的过程。这类人通常都很安静，一直从自己的内心寻找答案。\n自然探索认知：从周围相关的自然环境中认知的过程。\n如果设计师在设计游戏时考虑到这些不同的智能，他们可以让游戏适应无限多的玩家。\n原理8 霍华德的隐匿性游戏设计法则 霍华德的隐匿性游戏设计法则（Howard’s Law of Occult Game Design，隐匿性游戏设计法则，或称霍华德法则）可以用以下公式来表示：秘密的重要性其表面看来的无辜性完整度\n$$\r秘密的重要性 \\propto 其表面看来的无辜性 \\times 完整度\r$$$$\rSecret Significance \\propto Seeming Innocence \\times Completeness\r$$秘密的重要性，是与其表面上看起来无辜的程度及其完整度直接成比例的。\n原理9 信息 在一个游戏中的任何一个点上，玩家能接触到的信息数量和性质可以极大地改变其决定。\n和游戏相关的信息可以采取不同的形式以及分类呈现。\n游戏的结构 所有信息的类别中最首要的一个是游戏的结构，包括游戏的设定和规则。游戏环境本身也应该被视为信息。 如果一个游戏中的随机元素被作为参数而不是一个固定值来考虑，它也是一条明确的信息。\n游戏的状态 这类信息包括单位元素所处的位置、分数、资源的情况等。而它的含义比单个元素在地理上被放置在哪里这一点要更广泛一些。\n信息的利用 每个游戏利用这些原则的方式都不一样，但是一般的分类和分级对描述游戏设计师是如何处理这些信息是有帮助的。\n“完全信息”是游戏中一种最基本和限制最少的信息传达方式。在“完全信息”的环境下，所有的玩家都知道关于游戏的每一件事——环境，规则，当前位置，所有物品的状态，以及当前的游戏阶段。\n与“完全信息游戏”相对的，如果在游戏中一部分信息对某一个或更多的玩家是隐藏的，那么这个游戏是“不完全信息游戏”。\n原理10 科斯特的游戏理论 《游戏设计快乐之道》：所有游戏其实是低风险的学习工具，要让每一个游戏在某种程度上都是寓教于乐的。 这种“快乐”来源于“超游戏思维” 。\n如何在游戏设计中用到“组块化”，“组块化”是一个将复杂的任务分解成我们能够下意识地完成事情的过程。\n在我们的体验中，我们在一个不断变化的过程中参与并接受挑战就是“快乐”，特别是在学习中。\n原理11 拉扎罗的4种关键趣味元素 拉扎罗（Lazzaro）的4种关键趣味元素是一个设计工具，它能在游戏设计师设计新的游戏机制时激发其灵感，研究人员也能利用它来检验这些游戏机制的效果。\n简单趣味：玩家对一种新的体验感到好奇，他被带入到这种体验中去并且开始上瘾。\n困难趣味：游戏提供了一个可供追求的目标，并将其分解成一个一个可以达成的步骤。\n他人趣味：竞争、合作、沟通和领导结合在一起，增加参与度。“他人趣味”带来的情绪上的感受比其他3种加起来还要多。\n严肃趣味：玩家通过游戏来改变他们自己和他们的世界。游戏是一种对他们价值观的表达，而不是在浪费时间。\n最畅销的游戏通常能同时满足这4种趣味元素中的至少3个。游戏玩家对这4种趣味元素都喜欢，尽管在这其中他们有自己偏好。\n“简单趣味”是一个吸引好奇的玩家的并且促使他们加入游戏的诱饵。\n在某个时候，当这些新奇的感觉不再能持续获取玩家的关注时，他们会去寻找一些具体的事情来完成。“困难趣味”就是通过游戏困难度和玩家技巧间的平衡来做到让他们在经历挫折之后从史诗般的胜利中感受到“自豪” 。\n当与朋友在一起时，胜利的快感会让人感觉更好。围绕着游戏展开的社交互动能创造娱乐效果和社交纽带。\n原理12 魔法圈 游戏的一大特点是它是一种幻想（这是关于游戏的定义中一个主要的部分）。我们固有的假设是，游戏是一种独立于真实世界的存在。\n当“这只是一个游戏”不再只是一个游戏，魔法圈的界限就被丢诸脑后了。\n原理13 采取行动 游戏中的博弈，依据博弈各方做决定或采取行动的先后关系，可以被区分为“同步博弈”（Simultaneous game）或“序贯博弈”（Sequential game）。\n在同步博弈中，每个玩家同时也知道博弈中的每个人都面临着同样的问题。关键的信息对于博弈者在做自己每一步的决策时并不可见 （自己行动的时候不知道对方此刻的行动）。在序贯博弈中，每个博弈者能得到更多的信息。他们能通过其他人刚刚采取的行动，对其下一步行动进行可靠的预测（体现在自己行动的时候可以知道对方已有的行动）。\n同步博弈有可能是在时间上真正同步进行的，比如“石头剪刀布”；也有可能不是，博弈者各自在不同的时间进行自己的行动，只是他们在采取自己的行动时不知道其他博弈者的决策。\n序贯博弈要求博弈各方每一步都要轮流做出决策，同时他们对于其他人之前做出的决定至少是部分知情的。\n原理14 MDA：游戏的机制、运行和体验 游戏的机制、运行和体验（Mechanics，Dynamics，and Aesthetics，MDA）是一个系统化的分析和理解游戏的方法。\n游戏机制是整个系统的规则。它定义了这个系统如何处理玩家的输入，以及玩家能看到什么和做什么。\n游戏的运行讲的是在玩游戏的过程中整个系统的各个参与者的行为。游戏的运行是对游戏机制在真正运行时效果的展现。\n游戏的体验是在游戏运行的影响下玩家的情感输出。\n我们有两种不同的方式来实践MDA。\n第一种方式，游戏设计师以定义在游戏中想要达到的体验效果作为设计流程的开始，然后确定要达到这样的体验效果玩家需要参与什么样的游戏运行过程，最终再为这样的运行过程设置游戏的机制。\n第二种方式，玩家反向体验MDA的3个要素并且首先与游戏机制进行互动，这些机制会带来特定的游戏运行，而这又将让玩家产生特定的体验。\nMDA只是在游戏中达到创造特定情绪反应效果的一个方法，它有它的局限性。\n","date":"2019-11-09T15:50:57Z","permalink":"https://boiltask.com/notes/100principles-1/","title":"游戏设计的100个原理笔记(1) – 第1篇 游戏创新的一般原理（上）"},{"content":"阿里云发来了一条续费通知……\n这一个应该是ECS里跟了我最久的一台主机了吧，主要运行了酷Q机器人相关的服务。\n在网络编程课程设计和Java课程设计里面，用过他当做运行Java的服务器。这么久的日子了，人生第一个可以称得上作品的项目，QQ机器人也跟随了这么久。随着已经很长时间没有进行维护了，但是一直半死不活地运行着，后边也写了HPU小助手这种小工具。\n那么……说声再见吧，有缘江湖不散~\n","date":"2019-10-15T10:12:26Z","permalink":"https://boiltask.com/record/201910151/","title":"又一台跟了好久的主机到期了"},{"content":"记录 有道云笔记 Microsoft Todo Sticky Notes OneNote WordPress Typora 图像 Snipaste 树洞OCR ScreenToGif Captura OBS Studio 快捷 Quicker Everything Wox 读书 Calibre NeatReader 其它 ShadowsocksR PanDownload MacTray Scrcpy ","date":"2019-09-21T16:17:00Z","permalink":"https://boiltask.com/material/20190922/","title":"学习工作常用软件汇总"},{"content":"美术 教你画像素画：每一个像素都有意义\n虚幻4渲染编程：在虚幻4中学习图形编程\n设计 笔记：游戏设计\n社区 [Project1（66RPG）]（https://rpg.blue）\n","date":"2019-09-21T05:30:02Z","permalink":"https://boiltask.com/material/20190921/","title":"游戏制作学习资料汇总"},{"content":"前几天看到有个回答，关于程序员提升过程的说法。\n学习编程，开发软件，过程大抵如下：\n看书，看视频，看博客，听课等等 对着书敲代码 脱离书自己敲代码 自己实现一些小DEMO 进项目看代码 在别人指点下写代码 自己独立在别人搭建好框架内填写代码 自己独立负责别人设计好的模块的实现 自己独立负责一个软件模块的设计和实现 负责较大软件模块，拆分模块，分子任务给他人 负责一个小项目，设计，拆分，分派任务 做较大的软件系统的架构设计 作者：安晓辉\n链接：https://www.zhihu.com/question/297309123/answer/537836889\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n想想经过这么些年，也差不多在6~7之间徘徊了。而下面的评论也说，这个过程又是一个程序员提升过程中的瓶颈。能有所突破，未来便能继续稳步提高。\n想想人生和程序员有所关联，应该缘起于2006在小学生学习报上看到了跑跑卡丁车的广告。然后2007年在我姑父的带领下解除了泡泡堂，随后家里安装了电脑，又度过了一段难忘的游戏时光。随后，人生梦想就由画家转变成了游戏开发人员 （虽然画画也同样还很喜欢）。\n如今，也算是梦想成真了一部分。\n未来，还需要继续努力呀~\n","date":"2019-09-21T05:00:34Z","permalink":"https://boiltask.com/record/201909211/","title":"程序员之路"},{"content":"\r论贾宝玉的心路历程\r早便计划为《红楼梦》写点什么，特别是在上完第一次《红楼梦鉴赏》课后，又把红楼梦原著及一些周边作品（电视剧、书评等）看了一遍。但适逢近些日子自己的思想也有着很大的波动，而且随着课程的进行也有着新的体会。于是写一段感觉不满意或是又若有所思便断了下来，过些时间再看时，又感觉过往论点有所偏差，因此这一拖又是好久。不过，正是在这个过程中，我似乎又突然明白了贾宝玉的心路历程。\n——题记\r开辟鸿蒙，谁为情种？都只为风月情浓。奈何天，寂寥时，试遣愚忠。因此上演出这悲金悼玉的“红楼梦”。\n一曲红楼几多梦，《红楼梦》作为一部流传至今仍散发出文化内涵与思想底蕴的作品，其不光有着巨大的史料价值、文学价值，甚至还可以从中领悟到深刻的哲学思想。也因此，很多人对《红楼梦》的印象会停留在这是一本枯燥乏味、满载之乎者也的古代言情小说。然而细读下来，这本“批阅十载，增删五次”的小说，虽满载头衔，却平易近人；虽满纸荒唐，却引人深思。抛去其中对文学、文化的思考，只看对情节的把握与人物的塑造，也可堪称一绝。蕴含其中的，不光是老学究们的考证，也是一些“少年维特的烦恼”。\n“无才可去补苍天，枉入红尘若许年。此系身前身后事，倩谁记去作奇传”。以男主角贾宝玉的成长来看，很多人认为宝玉太过花心以至到处沾花惹草。在第二回《贾夫人仙逝扬州城冷子兴演说荣国府》中，我们便可以借冷子兴之口看出大多数世人对周岁抓阄便认准“脂粉钗环”，后又说出“女儿是水做的骨肉，男子是泥做的骨肉。我见了女儿便清爽，见了男子便觉浊臭逼人”的贾宝玉的一般看法——“你道好笑不好笑？将来色鬼无疑了！”。虽然后有贾雨村为之辩解，但终归逃不出“公候”二字。\n前段时间翻到高中的笔记，竟也提到了这一段。当时我的理解是贾宝玉认为世人对男子的要求较高，男人身上与生俱来便有着一些世故，换做女子去做同样的事反倒显得单纯。现在想来这还是片面的，宝玉所生活的时代恰恰是一个世俗对女子所偏见的时代。甚至在当今社会，我们对女子的要求虽无三从四德，却也绝谈不上平等。以一个大学生（高中生）的角度，可能对周围的女同学还体会不深，不过从生活与文化的熏陶之中，却也不难以发现这一点。举例说明，在大多数家庭，过年往往都是女方在婆家忙活。旁人若见一个女子出嫁后仍“赖”在娘家，恐怕不免传出闲言碎语。所以宝玉能发出此言，可能恰恰是由于弱化了女子与男子在世俗中地位的不同。当然，宝玉的行为虽似古怪，却终究是有其产生的道理的。\n可能受86版电视剧的影响，人们对宝玉的第一印象是与成人无异。然而尽管存疑，但我们探讨《红楼梦》时仍需明白，这是一部“少年少女那些事”。在这里需要特别指出的是，红楼梦中素有“真事隐去，假语村言”，甚至书中细节考究起来可能会略有矛盾，这也给我们探究红楼中人具体年龄带来了困扰。如今我们只能从脂批本和书中情节之间的关联来大致做出猜想。不过毫无疑问的，宝玉起初的行为绝不是一个成年人的思维，而是作为一个孩童式的表达。任何人都有一个生理和心理的成长和发展的过程，贾宝玉的人格形成也有着这样的过程。[2]因此我们是不能用太成人的眼光与看待他们的故事的，试想身边这些十岁的少年少女，恐怕我们会对这本书有着新的理解。考虑到这一层，我们便可以选取一些片段逐步来分析宝玉的其人其事。\n一、这个妹妹我曾见过的\n这句话出自原著第三回《托内兄如海荐西宾 接外孙孟母惜孤女》，是宝玉初见黛玉时言论。正是在这一回里宝玉初登场，作者也没吝啬笔墨，集大量辞藻去“批判”贾宝玉。作者称之为“纵然生得好皮囊，腹内原来草莽”与“天下无能第一，古今不肖无双”。能被如此形容的主角，想必也是古今也是鲜有。\n就是这个“潦倒不通庶务”的“混世魔王”，在见到黛玉的第一面说出了进人看到都为之经典的一句“撩妹经典”：“这个妹妹我曾见过的……虽没见过，却看着面善，心里倒象是远别重逢的一般。”之后两人闲聊之中，宝玉的一言“除了《四书》，杜撰的也太多呢。”，可谓是一语道尽其内心对功名文章的不屑。\n在这里我们重点来分析一下后面宝玉摔玉这一桥段，因为在往常看来，我们可能更倾向于这体现了宝玉对世俗的不羁态度。不过想想原文中年龄的描述，此时的宝玉应该是不满十岁的（由第三回可知其比黛玉大不几岁，而黛玉丧母之时原文中有具体描述为六岁，故而推知）。放在当今社会，一个几岁的孩子可能刚上小学没几年，偶然一次心里不高兴把自己的玩具摔了，我们会去联想到他对这个社会产生抵触情绪吗？恐怕我们也只会一笑了之吧。所以在我看来，宝玉摔玉这件事恐怕并不需要解读得太过严重。\n我们分析一下当时宝玉的心理。自己衔玉而生，家里人都引以为奇并无比珍重这块玉石。然而这块玉对自己又有何用呢？正像宝钗所言，“沉甸甸的，有什么趣儿？”。所以反倒宝玉自己并没有感受到这块玉有多么得重要，甚至某种意义上来说，家人对玉的关注影响到了家人对自己本身的关注，那就不妨找个理由闹上一场了。\n摔玉事件也着时吓到了黛玉，晚上还在闺房中伤心流泪，引得袭人安慰了一番。绛珠仙草以泪还恩，在这里也开始有所体现。\n二、到如今回头试想真无趣\n这是第二十二回《听曲文宝玉悟禅机 制灯谜贾政悲谶语》中宝玉在听过为宝钗生日所点的《山门》后，填的一只《寄生草》中的一句。在这一回中，我才第一次感觉到贾宝玉好像有点不一样的。在此之前，我对贾宝玉的直观感受是这是一个迷恋于姐妹之间的富家公子。但这一回画风突变，贾宝玉从一个整天耍着“精致的淘气”、“撩妹达人”的形象，突然转变成了一个悟道之人。人说世上存在由情入道，也是最难而最特别的一种方式，这也给后人推测的宝玉出家的结局作出了一定的解释。\n回顾本回，这一篇的内容不可谓不丰富，且不论本回后半部分的谶语，只单看宝玉悟禅机一事。先是宝钗给宝玉提到的“赤条条来去无牵挂。哪里讨烟蓑雨笠转单行？一任俺芒鞋破钵随缘化！”，再有黛玉对众人玩笑自己像戏子的不满，继而引起湘云的不快。作为宝玉，在心系黛玉又关心湘云的情况下，接连遭受到自己所珍视的两个妹妹的脸色，也难过自己会生出一些不一样的情绪来。\n在此之前，宝玉内心一直感觉自己是和众姐妹一起的，虽然和以父亲为代表的官僚作风为敌，但倒了内心还有所归宿。可是经过这一系列的事情，宝玉又发觉姐妹们也不是那么的团结友好。因此宝玉说出了，“什么‘大家彼此’？他们有‘大家彼此’，我只是赤条条无牵挂的！”。\n那作为一个富有诗书的文人难过时候应该怎么办呢？当然是奋笔写东西啦，把自己的内心所想变为高雅的文字，不仅能抒发自己的感情，也可以留下来一些情感的记录。想到这里，其实便意识到为什么有时候很理解贾宝玉，毕竟作为一名理工科的男生，还是很羡慕这种有话便可以寄托给文字的天赋。\n“从前碌碌却因何？到如今回头试想真无趣！”，有时候我也在想，如果宝玉在悟到碌碌却因何之后，选择不再沉迷脂粉，而是选择做一些“功名文章”，那么红楼梦还会是一场悲剧吗？可惜，贾宝玉终究是贾宝玉，离了姐妹，就能“真有趣”了吗？恐怕也不尽然。\n三、不知将来葬我洒泪者谁\n悟道之后，第三十六回《绣鸳鸯梦兆绦芸轩 识分定情悟梨香院》中宝玉的“不知将来葬我洒泪者谁”，则更是体验出了宝玉的孤独感。纵使周围玩伴看似众多，却不知谁在是真正与自己志同道合之人。\n在这一回中，我们见到了宝钗与宝玉的志不同不足为谋。甚至于宝玉说出了“好好的一个清净洁白的女子，也学的钓名沽誉，入了国贼禄鬼之流”，这种不顾及宝钗颜面的话，从而我们开始能切身体会到黛玉与宝玉的那种互为知己之情。\n而宝玉发出“不知将来葬我洒泪者谁”也是有所前因的。在这之前，因袭人与宝玉开玩笑说自己要走。二人谈论到“人活百年，横竖要死”，宝玉兴起便也发出自己的看法。古人常说“文死谏”“武死战”，这也是我们今人所为之京津乐道的。宝玉确认他们都是沽名钓誉，不知君臣大义之辈。继而宝玉表达出了自己对待死亡的看法：“比如我此时若果有造化，趁着你们都在眼前，我就死了，再能够你们哭我的眼泪，流成大河，把我的尸首漂起来，送到那雅雀不到的幽癖去处，随风化了，自此再不托生为人，这就是我死的得时了。”。可见宝玉对死亡的追高追求还是能收到自己所珍重之人的关心，然后能逃避自己所不屑之人的注意，这也就实现了宝玉的抱负。\n我们从中其实可以体会到宝玉的一种归属感，他其实也是想要“功成名就”，只不过他所希望更多的是身边的这些“脂粉佳人”。\n让宝玉又一次“怀疑人生”的是梨香院中十二女孩中的玲官，也就是那个前文所述被玩笑眉眼像林妹妹的小戏子。原文中也说过宝玉“因素昔与别的女孩子玩惯了的，只当玲官也和别人一样”，可以理解宝玉此时的心情，更何况这个小戏子还和黛玉长得相像。然而真的可以“和别人一样”吗？“玲官见他坐下，忙抬起身来躲避。”，又说“嗓子哑了，前儿娘娘传进我们去，我还没有唱呢。”。宝玉心里很显然是一种羞愧和紧张，“从来未经过这样被人弃厌，自己便讪讪的，红了脸，只得出来了。”而药官告诉宝玉，只等蔷二爷来了叫她唱便必唱得。从第三十回《宝钗借扇机带双敲椿龄画蔷痴及局外》中，读者可以发现玲官是心系贾蔷的。而后蔷二爷真的过来了，宝玉看二人的“打情骂俏”也“不觉痴了”。\n被一个在自己与林妹妹等人等同的女子拒绝，又见她与另一名男子关系如此和谐，也难过宝玉会心生惆怅。宝玉此时也难得同意了老爷的看法，承认老爷说自己“管窥蠡测”。宝玉也悟出了“昨夜说你们的眼泪单葬我，这就错了。看来我竟不能全得。从此后，只好各人得各人的眼泪罢了”。\n“不知将来葬我洒泪者谁”与黛玉《葬花词》中“侬今葬花人笑痴，他年葬侬知是谁”有异曲同工之妙。恰巧此时黛玉也在身旁，不过黛玉却没有把这话接过去，而是不便多问换了一个话题。我认为黛玉此时的反应正是表达了黛玉是很懂宝玉的想法的，不然若让黛玉接着这个话题聊下去，甚至说一句“我肯定心系于你”也不恰当。宝玉也没有继续谈论这个话题，我们还是可以体会到二人之间的小默契的。\n四、始信黄土隆中，女儿命薄\n晴雯是我个人非常喜欢的一位角色，虽说“晴为黛影”，但晴雯本身也有着黛玉不一样的色彩。晴雯比起黛玉更多了一份活泼，一幕晴雯撕扇，也让读者感受到这样一位女子的魅力。然而，“霁月难逢，彩云易散”，到底晴雯因为丫鬟身份而遭受诽谤，最终殒命怡红院外。\n贾宝玉生平最怕写一些有固定格式的文章，然而此次却出奇地写出了一篇精彩的诔文，这便是《芙蓉女儿诔》。文中最为人所熟知的，恐怕应属“岂道红绡账里，公子情深；始信黄土陇中，女儿命薄”。不仅是这两句直指“公子”与“女儿”，也因后文中黛玉与宝玉谈论过这两句。\n《芙蓉女儿诔》的出现已是红楼梦的第七十八回《老学士闲征姽媜词 痴公子杜撰芙蓉诔》（一说为《老学士闲征姽婳词　痴公子杜撰芙蓉诔》），我们知道目前公认原作为前八十回，此时已近尾声。除去一早便离世的秦可卿，晴雯之死，开启了《金陵十二钗》正册、副册、又副册女子的归宿。有人不理解为什么宝玉会为晴雯写下一篇《芙蓉女儿诔》，而当黛玉去世时却好像毫无作为。这当然一方面是黛玉去世之时已是后四十回，我们无从简单原作者如何安排。况且已经有了一篇为“芙蓉女儿”作的诔文，也无需再来一遍。但我们分析起来也可以理解，宝玉的《芙蓉女儿诔》可能更多的还是有一丝卖弄文采之意。尤其在后一回开始之时与黛玉探讨，宝玉也“笑答道”：“原不过是我一时的玩意儿，谁知被你听见了。”。后来二人又咬文嚼字，商议出“茜纱窗下，我本无缘；黄土陇中，卿何薄命”，这一句放在当时的情境下，也可以说是假若黛玉去世，宝玉用这一句来奠念。因此“黛玉听了，陡然变色”，可能黛玉也发觉这句话有所不妥吧。这时大概已经出了为晴雯祭奠的情感，而开始了二人的沟通。\n我们可以猜想宝玉此时是何种心情，面对一个自己所爱之人，他可能也不想黛玉看见自己为另一个女子太过哀伤。在失去众多姐妹以至怀疑人生之时，所幸宝玉终于意识到了黛玉对自己的意义。那是纵使离开群芳之后仍能有一人为伴的欣喜，那是世人皆不解我唯有一人能懂我之真心的感动，那是舍世界愿为伊人一生的希冀。可惜，个人的力量在世俗的庞然大物下略显单薄，更何况贾宝玉内心又太过软弱。\n可能很多人无法理解贾宝玉为何能“百花丛中过，片叶不沾身”（当然这属于广义的，和贾宝玉有实质关系的女子，甚至推测有过的男子也是存在的）。我认为这其中的本质原因是贾宝玉从始至终都不是为了色欲（甚至可以说是爱情）才去接近一个女子的。无论宝玉爱吃胭脂，或是喜爱与姐妹丫头们嬉戏玩耍，都源自于内心对美丽事物的向往。这也是我愿意相信宝玉与蒋玉函可能真的有一定关系的原因，因为琪官此时象征着美好，而无关性别。当抛开性去思考贾宝玉的所作所为，我们不难看出宝玉只是单纯地想接近于这些美好。只不过用后来人的眼光来看，宝玉并没有能力去保护这些美好。\n想起张爱玲平生所言有“三大恨”：一恨海棠无香；二恨鲥鱼多刺；三恨红楼未完。虽然广为流传的高鹗所续后四十回补完了红楼梦的结局，却被称之为狗尾续貂。确实，后文与前文的精妙之处可谓天渊之别。作为计算机专业的一名学生，也曾在网上看到一篇用人工智能与深度学习技术分析红楼梦前八十回与后四十回的论文。得出的结论就是，两者画风截然不同，可以预见的是如果前八十回按照后文一般撰写，那红楼梦也不可能传为经典了。\n红楼梦作为一本文学史上的重要著作，确是一本没有结局的小说。本来作为情节取胜的小说这一文体，能在缺少结局的情况下得到如此高的评价，也从另一方面体现了其内蕴的深厚。这可能就是一种残缺美吧，它把红楼这幅人生画卷带给读者，又把下卷的白纸留给读者自己绘制。\n不过话虽如此，到了我们无从得知宝玉的结局如何。可能作为计算机领域的一员，未来或许希望根据前文内容通过建立语法树，借由计算机推测出原版结局云云。但对每个人来说或许也不是那么重要了，因为每个人心中早已有了自己的“贾宝玉”。\n参考文献：\n[1]《红楼梦》，曹雪芹\n[2]《贾宝玉的年龄推断》，文哲\n","date":"2018-05-07T04:33:53Z","permalink":"https://boiltask.com/qzone/1525667602/","title":"论贾宝玉的心路历程"},{"content":"发现上个发的日志竟然已经是去年招新结束后发的，一年时间又过去了…确实似乎周围人发的日志也越来越少了，很多事情说说里发一下也基本够了。不过对于这种写之前就知道会写很多的来说，日志可能会更好一些，估计大概也赶不上2017最后一班车了，就当做2018的开端吧。\n再往前的一篇也是关于ACM的，本来今年之前的几场区域赛打完就想打个日志记录一下的，然而确实还有些遗憾吧，实在是提不出来兴致写东西。昨天的生日本来也准备做个总结，结果也是突然没有心情，感觉今年不趁着元旦写点什么，后面可能再也不会写了，所以能留下点什么还是留下点吧。\n先来看ACM吧，很遗憾并没有完成去年的目标，可见老天还是很公平的，好运不会一直眷顾。犹记得去年侥幸得到铜奖之后的欣喜，今年得到铜奖却毫无感觉。毕竟又是一年过去了，最终还是没能为我校拿到第一枚区域赛银牌，祝愿后面的学弟学妹们能继承历代学长学姐的遗志吧。\n其余的来说，自己在之前也订过一些20岁之前的小目标，本来阳历生日的时候还想还没20岁我还有时间。不过阴历生日也过了，就没办法啦得承认自己20岁了。\n首先说自己想要20岁之前靠专业知识挣得第一桶金，不知道算不算完成了。强行算完成的话，真能说是挣的就算是给谷歌当了一年的广告狗吧，也算挣了几十块美金，虽然一直没收到验证的邮件，不知道发到哪里去了。\n再来说想要做个游戏，嗯…QT消消乐不知道算不算哎。自己还是太懒，说要学unity，结果干了几天又不想动了。还是缺乏动力吧，没有人来逼迫一把，毕竟QT也是差不多的东西，被老师逼得也速成了。\n嗯…女朋友…那行吧…算是没毛病的完成一件事情了，立了一两年的flag了…\n平均一年发一篇日志哎，不过随着时间流逝，每一次写日志都有可能是最后一篇，谁能说得准呢。行啦，写着写着又不想写了，感觉这是好事，说明也没憋多少话吧，有地方倾吐总是好的。\n再立点2018年的flag呗，虽说在这种地方立大概率会被打脸。\n首先2018年又是人生中重要的一年，后面的好多事应该在这一年都会有所分晓。\n不行，不能立flag，悄悄想一想目标与希望就好了，说出来就不灵了。\n就这样吧，想到新的再来更新，虽然估计也不会更新了，前几年的还没补完呢，嘻嘻。\n总之，努力做好之前做得不是很好的那些事，尝试之前没做好的那些事，大家2018继续共勉。\n","date":"2017-12-31T16:33:45Z","permalink":"https://boiltask.com/qzone/1514738005/","title":"不知道是不是在空间的最后一篇日志呢"},{"content":"虽然这篇日志发出的时候，圣诞节已经过了，但总感觉在这个满世界苹果的节日配上小石榴很酷，虽然之前一直没用过这个称呼。\n圣诞节能在机房坐一下午，或许还很痛苦很焦灼地做题，想想也是个难忘的回忆。虽然是在群里讲题目出的有些难度，但我认为我内心最多把难度从简单升级为不难。毕竟，说的招新招新，从暑假一直说到了寒假。\n当看到一个作为C语言基础题的B题一半人不会的时候，尤其是看到隔壁友校新生赛几百个人规模的时候，当想到水平不够都没法和别人玩的时候，确实内心还是很难受的。\n记得大一临近暑假的时候，越发感觉到了ACM靠某一个学生是很难把一个学校的水平提升上去的。大概从那个时候就开始想，有机会的话我会好好带下一届学弟学妹的。\n暑假里面找时间研究OJ，经过几次通宵总算有了雏形，然后php js什么的一通乱学，也是把界面改的面目全非了（我应该是想表达褒义）。后来开学之后尝试搭建学校OJ，依照着hustoj的开源代码，也算是做出了一些不一样的东西。至于后来的solution什么的，那也算是对我个人的一点考验吧。\n记得从暑假还没结束时候起，虽然还没开学，但已经认识了一些学弟学妹。后来军训、国庆、百团大战什么的，一路走来也是建立了很大的友谊。时常说的事情也是，真要说踢掉谁的话我估计已经下不去手了。\n什么时候说明投入了很大精力，大概就是如果没有ACM估计我就废了。基本上所有的圈子已经围绕了ACM，但…那又怎么样呢，我又不后悔。\n人们常说，这世界有舍有得。就我个人而言，也确实是得到了很多，也失去了不少。或许是不接触这种东西的人很难体会的一种情感，或许刚开始是好奇，后来有趣，又或者是被虐的死去活来的痛心，但又很难割舍开来。\n因为，把一切都投注了其中。事业与情感，都注定了会把自己绑在上面。\n想想，这是招新后的鼓励与期待，不是回忆录，所以就这样子吧。\n上面有句话说得挺好的，\u0026ldquo;那又怎么样呢，我又不后悔\u0026rdquo;。\n","date":"2016-12-25T17:00:54Z","permalink":"https://boiltask.com/qzone/1482685222/","title":"招新之后写给圣诞节的ACM小石榴"},{"content":"(写完之后补充一句，如果这篇日志伤害到了一些身边的人，先说声抱歉)\n自从去年学习了这句话，每次想时都觉很有道理。差不多去年的今天，学长终于通知本周ACM协会招新，最终也没什么悬念的，成为了我大学唯一加入的组织。\n说起来这个没有悬念，我写下的时候还是纠结了一下这样说会不会被打，但想了想确实是没有悬念。这点自信还是要有，要不也对不起我这些年和我爸的“斗争”。想起来前几天为了准备今天写点什么，特意翻了翻六号群里的东西。很可惜，聊天记录是肯定找不到了，不过群文件里还有去年11月份初做的AC小助手。想来，那时候也还是一直想要做应用的。\nACM是什么？能吃吗？\n凌晨时候逛知乎，大概是一个有关家境的问题，问家境不好的人在哪方面会输给家境好的人。诚然，我应该不算家境不好的人，嗯。但如果有个问题叫做“什么时候你意识到家境不好”的话，我想，我心中还是有些答案的。\n当知道世界上还有OI这种东西的时候吧，或者说，当知道OI距离我如此近又如此之远。近到别人初中时打代码时我也在打代码，远到别人在打比赛时我在被我爸打。现在想想，因为计算机的事情确实有段时期“众叛亲离”(想了想还是加了引号，也没那么夸张)，只能无奈地说句，小城市毕竟还是小城市，虽然我依旧以她为荣。\n我爷爷常说，只有受教育的家庭才是有未来的家庭。很多事情，我不说，但越长大越沉思。至少，我爸走进了城市，自然而然地也要求一辈比一辈好。然而，计算机的到来，打破了信息流通的屏障，让我提前知道了，世界还有许多的东西。\n计算机再晚来十年会怎样呢，不知道，也不想做出假设了。\n羡慕那些由由信息学入门接触计算机的人，然而我的确和大多数人一样由游戏入门。中国的电子游戏，经过这些年的风风雨雨，也算坎坷崎岖，不过确实也造就了电脑等于游戏机的观念。\n这就很尴尬了，嗯。\n想想小学时候的微机课(很幸运的四年级是有微机课的，虽然还是爱上不上的课)，摆弄金山打字和金山画王。直接导致了后来，家里装上电脑，也是对这俩软件爱不释手级别。\n(说到画画，一直耿耿于怀还是五年级暑假扔下的画笔再也没能拿起来。理由是因为一百分的英语最多只能考八十多，拉去学新概念。暑假开学拒绝继续去学，被我爸打得现在对英语依旧有心理阴影。)\n后来初中，很幸运拷到了一份课本附带光盘的资料。(为什么要拷，因为书就一份直接留在机房的…里面是word的教程)至少，每一次微机课上机课(开玩笑，怎么可能每个星期都让上机)，都是我最开心的时候(毕竟这是一种你不教的我也知道的喜悦)。\n九年级，还是我每一次写东西都要说的事情(这篇日志只讲事业的好吧)。上学期，做flash,建九二联盟，搞事情。下学期又沉迷贴吧，无法自拔。然后那天看思品老师不爽，晚上偷偷把她上传到多媒体系统里的课件改了，第二天上课一阵骚动的时候成就感还是很高的。(这事似乎也就那几个人知道，都没敢往外说…)\n至于后来高中时候因为计算机的问题和家里边的人闹矛盾，我准备下一篇日志再写。\n这一年多的大学还是让我认识到一些事情的，很重要的一点就是，我心态确实爆炸了。虽然依旧能写代码写一晚上，但已经不止是只有写代码才能熬一晚上。\nACM带来了什么，前几天说到，让我找到了小时候心目中的大学感觉。这种感觉是在你看到神奇的课程安排、厉害的讲课态度和开一次机死机三次的机房电脑之后自然而然梦寐以求的感觉。至少，保护我了不用去纠结那些神奇的事情。\n——2016.11.12于北京\n下为2016.11.15补\n写了一半感觉没写完，后面两天也没找到感觉就没有继续写，所以也没有发出来。\n不过既然写了，那就不妨继续补充一些吧。\n去年的今天，星期日，ACM协会第一次招新结束了。回忆起这一年，确实比起很多强校，浪费了太多太多时间。或许，有朝一日我们学校不在需要以C语言知识来招新，那么协会才真正发展起来了吧。\n这次去北京，虽然号称是内心毫无波动，但对于一个第一次进入首都的小青年，还是依旧地难免激动。虽然已经尽量找北大的不好了，但…你懂得…确实没找到。\n比赛能获奖也很开心，虽然之前一直说有机会获奖，不过也一直说百分之十的概率…所以当最终一题一题AC，排名稳定在铜牌区的时候，还是有些难以置信到爆的。\n不过发现，确实没啥说的了，补充这几段也是为了在比赛结束之后补充一下比赛结果。想来，一个铜奖，弱校开心到爆，但对于强校巨巨来说，这根本还是没什么值得说的安慰奖。特别是当自己内心明白这种水平根本在强校连ACM队都进不去，不过…加油吧。\n比赛出发前，用港港的话录了个flag，爆零回来剃光头，看来头发是保住了，拿不了奖就不谈恋爱，现在奖也拿了。\n所以，总得来看，虽然鲜克有终，但还是希望，如果最后有句号，那么就让句号更圆满些吧。\n","date":"2016-11-15T14:13:30Z","permalink":"https://boiltask.com/qzone/1479219219/","title":"靡不有初，鲜克有终，ACM入坑一周年纪念"},{"content":"本篇文章讲解题目：小学求和1到n\n推荐先独立进行解题尝试，然后再阅读本篇讲解！\n注意观察这道题与上一个求和的差别。\n首先从一组数据变为了多组数据，但这一点在学习了循环之后应该已经不再是问题了。\n我们只需要读取一个变量T记录组数，然后使用语句：\n1 2 3 while(T--) { } 在大括号里写程序即可。\n这道题给的范围为$0 \u0026lt; n \u0026lt; 10 ^ 9$，所以如果依旧使用for的话循环最大要进行$10^9$次\n评测机一秒大概可运行$10 ^ 7 \\sim 10 ^ 8 $次 ，所以O(n)的复杂度是不行的\n(推荐先自己查阅时间复杂度相关资料)\n事实上，如果让小学生来解，这便是一道很简单的等差数列求和，所以可用求和公式直接算出答案。\n当然，还需要注意数据范围的问题。\n再次举这一题的例子也是想再次说明思维的重要性。\n一道题随着题目描述的不同，解答方式也许有着差异，所以不要局限于某一种解法，多加尝试才能处变不惊。\n","date":"2016-08-29T16:00:57Z","permalink":"https://boiltask.com/iwbtg/15/","title":"【愿成其身】[15]思维的优化 – 数学的魅力"},{"content":"本篇文章讲解题目：大学求和1到n\n推荐先独立进行解题尝试，然后再阅读本篇讲解！\n依旧是一道小学题目。\n本篇文章有过激言论，请谨慎阅读。\n这一题一般常用做初讲for循环的例题，而这道题也确实很合适，因为这标志着思考问题解决方案的可行性，由优先思考数学方法转变为思考时间复杂度。\n而有争议的地方，便是for循环的写法。\n首先是基本结构如下：\n1 2 3 for(/*起始语句*/; /*判断语句*/; /*修正语句*/) { /*循环语句*/ } 同样画出它的流程图：\n(参考文章《for,(do-)while的循环体执行》)\nfor循环比while好在它能清晰的操作循环变量，比如下面代码：\n1 2 3 4 int i; for(i=0; i\u0026lt;n; i++) { /*循环语句*/ } 这便是让循环语句循环n次的写法，同样的操作可写为while(n\u0026ndash;)。\n但是如果我们在循环中用到了i，比如我们想让奇数次时执行某一语句，偶数时执行另一语句，就可以写为：\n1 2 3 4 5 6 7 8 int i; for(i=0; i\u0026lt;n; i++) { if(i%2==0) { /*偶数时操作*/ } else { /*奇数时操作*/ } } 所以具体什么时候该用哪种循环，取决于哪一种可以使代码简洁、写起来方便，可以进行互相转换。\n上边代码就等同于：\n1 2 3 4 5 6 7 8 9 int i=0; while(i\u0026lt;n) { if(i%2==0) { /*偶数时操作*/ } else { /*奇数时操作*/ } i++; } 而至于for循环有争议的地方，便是for循环中的i=0。\n在C++中，我们可以在循环的初始语句里写成：for(int i=0; i\u0026lt;n; i++)，也就是把定义变量放在循环内部，这样的话变量作用范围就仅限于这个循环里面。如此做，可以防止循环与循环之间的干扰，特别是需要函数互相调用时，防止变量因为已被占用而发生错误。\n(关于变量的作用范围，可参考我之前写过的一些文章《for循环中的定义变量》《关于for循环中定义变量的后续讨论》)\n然而，在标准C中不允许这么写，可以尝试把代码保存为.c和.cpp来查看编译区别。\n所以如果需要使用在for中定义变量的形式，提交时需要选C++，事实上我认为最好以后默认选C++。\n这不是C语言课……\n这不是C语言课……\n这不是C语言课……\n所以我认为，只要自己在使用时清楚地认识到哪部分是C++特有的，那么我们大可放心使用C++。毕竟我依旧认为，我们不应该在语言层面纠结太长时间。\n这些问题需要在今后的学习过程中自己体会与抉择，这里不多说了……\n注意事项：\n多条循环语句不要忘了加大括号！\n不要忘了加大括号！\n加大括号！\n剩下的就没有什么了，在掌握了循环之后，已经可以开始尝试一些入门级水题了。\n这条路，长且艰……\n","date":"2016-08-28T16:00:46Z","permalink":"https://boiltask.com/iwbtg/14/","title":"【愿成其身】[14]for循环 – 另一种表达方法"},{"content":"本篇文章讲解题目：蜗牛爬树\n推荐先独立进行解题尝试，然后再阅读本篇讲解！\n一道小学数学题，但对于计算机来说，却是直接模拟这一过程更为简洁。\n很明显的一个思路是，对高度不断模拟上升下落的这一过程，然后统计次数，直到高度达到树的高度。\n简单的画一个流程图：\n分析可以发现，这里的循环是由一个条件控制的。如果满足某一条件则一直循环，否则退出循环。\n在C语言里，这种形式可以使用while语句表达，其基本形式为：\n1 2 3 while(/*条件*/) { /*语句*/ } 可以发现与if语句形式类似，也是很好理解，若满足条件，则不断执行语句，每次执行之后判断条件是否成立，然后选择继续执行或者跳出循环。\n有了上面的基础知识，我们再来思考这道题，发现上面的程序流程图对于一些情况是没有考虑到的。\n首先是Impossible不可能的情况，下降比上升的幅度还大，那么很显然是不可能的。但是有一种却要排除在外，也就是第一天白天就能够爬到树顶的情况，那么应该输出1。 考虑到如果白天就爬到，那么晚上就不用掉落，很显然我们在白天爬完之后应该判断，是否已经到了树顶，如果到了，那么就不需要晚上掉落这一部分了。 加上这些考虑，我们改进流程图如下： 有了这些思考，AC还是件难事吗-.-。\n嗯……似乎还有些问题。\n首先是对于输出不可能判定的条件有两个，在C语言里我们使用两个\u0026amp;号，也就是“\u0026amp;\u0026amp;”来表示并且，而用“||”来表示或者。这个条件就可以写为n\u0026lt;h\u0026amp;\u0026amp;n≤m。\n再来是循环内的判断，如何终止循环呢？我们可以使用continue与break来控制循环。\ncontinue的作用是跳过continue下面的部分直接回到循环条件那里判断是否需要进行下一次循环。\nbreak的作用就是直接跳出循环。\n测试代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include\u0026lt;stdio.h\u0026gt; int main() { int T=10; while(T--) { /* if(T==5) continue; */ /* if(T==5) break; */ printf(\u0026#34;%d\\n\u0026#34;,T); } return 0; } 这里还顺带写了while的一种常见用法while(T\u0026ndash;)，可先自己理解理解其中含义，在后面输入输出系列中会详细说明。\n写到这里，这一题就算告一段落了。\n事实上，while还有一种变形，do-while，其基本形式为：\n1 2 3 do { /*语句*/ } while(/*条件*/); 也就是判断循环条件是否成立之前，先执行一次循环体，这在解决一些问题的时候很方便。\n也许你可以自己尝试画出它的流程图呀~\n","date":"2016-08-27T16:00:42Z","permalink":"https://boiltask.com/iwbtg/13/","title":"【愿成其身】[13]循环结构 – 计算机的神奇"},{"content":"本篇文章讲解题目：交换输出\n推荐先独立进行解题尝试，然后再阅读本篇讲解！\n这也是一道经典问题，今天就从它谈起。\n$a \\rightleftharpoons b$\n首先分析题目，下面这种写法肯定是错的。\n1 2 3 4 5 6 7 8 9 #include\u0026lt;stdio.h\u0026gt; int main() { int a,b; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a,\u0026amp;b); a=b; b=a; printf(\u0026#34;%d %d\\n\u0026#34;,a,b); return 0; } 因为在a=b的时候，a的值已经被替换成b了。\n这个时候我们想，若把a的值提前记录下来便可以了。\n也就是int t=a;a=b;b=t;\n事实上，还有一种更为酷炫的不借助其它变量的写法如下。\n1 2 3 a+=b; b=a-b; a=a-b; 也就是直接把b的值存在a里面，然后a-b便是a的值——赋值给b，然后此时a-b便是b的值——赋值给a。\n同样按照这种思路，有依靠于二进制运算的更为酷炫的写法：\n1 2 3 a^=b; b^=a; a^=b; 因为对计算机来说二进制更为快速，所以这种写法也是更省时间的。\n下面还有一个最终版本。\n在前面说过，黑盒测试是给输入数据然后比较输出数据是否一样，而这一道问题的输出是a和b交换值之后输出a和b的值。\n那么我们便可以提交如下代码：\n1 2 3 4 5 6 7 #include\u0026lt;stdio.h\u0026gt; int main() { int a,b; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a,\u0026amp;b); printf(\u0026#34;%d %d\\n\u0026#34;,b,a); return 0; } 同样是符合题意的一种代码。\n在分析这道题的过程中。\n首先，根据最简单的题意我们写出了一份代码。 然后，根据数学知识做出了优化(所用空间减少)。 之后，根据同样地思想用二进制优化了计算过程(所用时间减少)。 最后，依照黑盒测试的特点写出了最简代码。 当然，对于这一题来说，即使是最初的代码所用的时间与空间也是非常少的，所以优化对这一题来说也许没必要。\n但是这种思想是我们应该学习的，正是在这种优化中，自身的编码能力及思考问题的能力会有显著的提高。\n而实际比赛中，我们也可以根据题意，在符合要求的前提下，选取那个最容易想出且容易写成的方案来实现。\n","date":"2016-08-26T16:00:45Z","permalink":"https://boiltask.com/iwbtg/12/","title":"【愿成其身】[12]从交换输出谈起 – 黑盒的漏洞"},{"content":"本篇文章讲解题目：比较字符\n推荐先独立进行解题尝试，然后再阅读本篇讲解！\n细想之下，计算机能储存字符是一件非常了不起的事情，毕竟它不同于数字。\n数字还可以使用二进制转换，而字符怎么办……\n为了解决这一问题，在C语言里，字符是被存储为数字的，其可像数字一样参与运算。\n我们可以使用类似于下面的代码来查看代表字符的数字是多少：\n1 2 3 4 5 6 7 8 9 10 #include\u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;%d\\n\u0026#34;,\u0026#39;A\u0026#39;); printf(\u0026#34;%d\\n\u0026#34;,\u0026#39;B\u0026#39;); printf(\u0026#34;%d\\n\u0026#34;,\u0026#39;C\u0026#39;); printf(\u0026#34;%d\\n\u0026#34;,\u0026#39;a\u0026#39;); printf(\u0026#34;%d\\n\u0026#34;,\u0026#39;b\u0026#39;); printf(\u0026#34;%d\\n\u0026#34;,\u0026#39;c\u0026#39;); return 0; } 所以这一题便可以方便的进行比较。\n字符的类型为char，格式化输入输出使用%c。\n1 2 3 4 5 6 7 #include\u0026lt;stdio.h\u0026gt; int main() { char c; scanf(\u0026#34;%c\u0026#34;,\u0026amp;c); printf(\u0026#34;%c\\n\u0026#34;,c); return 0; } 需要注意的是，小写字母ASCII值是大于大写字母ASCII值的，而题目定义为小写字母小于大写字母，所以对于这种情况应该特殊判断。\n","date":"2016-08-25T16:00:15Z","permalink":"https://boiltask.com/iwbtg/11/","title":"【愿成其身】[11]字符的本质 – ASCII的作用"},{"content":" 君甚屌,令堂可知？\n第十篇文章，能看到这里，说明已经基本上踏入了这道大门。虽然路还很长，但是已经走在了路上。\n所以这一篇文章讲一个虽然不影响解题，但是熟练运用会让代码看起来很酷炫的小知识点：问号表达式。\n其基本形式如下：\n1 (/*条件*/)?(/*语句1*/):(/*语句2*/) 当条件1成立的时候，表达式的值取决于语句1，否则取决于语句2。\n例子：\n1 printf(\u0026#34;%s\\n\u0026#34;,a\u0026gt;b?\u0026#34;A\u0026#34;:\u0026#34;B\u0026#34;); 具体的如何运用，还是需要自己在实践中多多尝试。\n如果能运用的非常自如，那么说明对程序的结构把握的很好，也有利于进一步的学(zhuang)习(bi)。\n练习题：\n三个数的最值\n","date":"2016-08-24T16:00:02Z","permalink":"https://boiltask.com/iwbtg/10/","title":"【愿成其身】[10]问号表达式 – 酷炫的利器"},{"content":"本篇文章讲解题目：两数的距离\n推荐先独立进行解题尝试，然后再阅读本篇讲解！\n由数学知识得，两点在数轴对应点的距离为$\\left| x_{1}-x_{2}\\right|$。\n相减没什么难度，所以这一题实际上在于求绝对值。\n事实上，这是一个逻辑问题，也就是如果a\u0026lt;0，那么应该输出-a，如果a\u0026gt;0，那么应该输出a，如果a=0，那么应该输出0。\nC语言对于分支结构有两种常用表达：\n是if-else、switch，其中前者因为便于理解而更为常用，今后也将重点使用if-else，switch在可以方便使用时再讲解，可以自行百度。\nif-else的大概结构如下：\n1 2 3 4 5 6 7 if(/*条件1*/) { /*语句1*/ } else if(/*条件2*/) { /*语句2*/ } else { /*语句3*/ } if顾名思义，是如果的意思，这段代码的意思也就是：\n如果条件1成立执行语句1；如果条件2成立执行语句2；否则执行语句3。\n若条件下只有一条语句，则大括号可以省略。\n若一个条件下有多条语句，则大括号不可省略(因为如果省略，编译器便把它当成只有一条语句在该条件下)。\n所以这道题的代码就很好写了。\n数据范围很小，用int型就足够了，然后就是进行判断求解。\n","date":"2016-08-23T16:00:14Z","permalink":"https://boiltask.com/iwbtg/9/","title":"【愿成其身】[9]分支结构 – 程序的魅力"},{"content":"本篇文章讲解题目：愿成其身A÷B\n推荐先独立进行解题尝试，然后再阅读本篇讲解！\n我们知道C语言中用\u0026quot;/\u0026ldquo;来表示相除，整数的除法是采用的舍尾的方式。\n$5 \\div 2 = 2 \\ldots \\ldots 1$\n$5 / 2 = 2$\n所以对于这一题来说，题目要求输出A÷B的结果并保留到整数位。\n如果写成A/B，A,B都是整数的话，那么会得出结果的整数部分，小数部分会被舍弃，而这一题应该四舍五入。\n所以如下面代码是错误的。\n1 2 3 4 5 6 7 #include\u0026lt;stdio.h\u0026gt; int main() { int A,B; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;A,\u0026amp;B); printf(\u0026#34;%d\\n\u0026#34;,A/B); return 0; } 为了表示小数，我们可以使用double(float因为精度问题一般不使用)。\n提到了精度问题，请百度double的注意事项，应重点关注double的表示范围与计算误差。\n在这里暂时不对这一问题进行深入研究。\n声明一个double型变量依旧类似。\n1 double a; 在格式化输入输出里用%lf表示(有些标准对于有些情况使用%f，但一般统一写作%lf)。\n那么如何表示精确到整数呢？\n我们可以使用printf(\u0026rdquo;%.lf\\n\u0026quot;,a);\n可以注意到在%与lf中间加了一个点，这个便表示四舍五入到整数输出。\n这也是格式化输出的一种运用，在后面会再细讲。\n类似的还有：\nprintf(\u0026quot;%.2lf\\n\u0026quot;,a); 四舍五入到小数点后两位数字输出。\nprintf(\u0026quot;%.3lf\\n\u0026quot;,a); 四舍五入到小数点后三位数字输出。\n等等……\n还有一点需要注意：\n此题的的输入数据描述，由两个整数变为了两个数。\n所以输入数据有可能为小数，这个时候便不可以用整数来读取。\n","date":"2016-08-22T16:00:47Z","permalink":"https://boiltask.com/iwbtg/8/","title":"【愿成其身】[8]实数的运用 – 整数化作的实数"},{"content":"本篇文章讲解题目：最后一位\n推荐先独立进行解题尝试，然后再阅读本篇讲解！\n在C语言中，除了加减乘除运算之外，还有一个较为常用的运算，取余\u0026quot;%\u0026quot;。\n$$5 \\% 2 = 1$$由数学知识得，一个整数对10取余即可得到最后一位数字。\n$$12345 \\% 10 = 5$$这一题便可使用这一种方法轻松得出答案。\n从上一篇文章中学到，这里如果计算A×B的话，依旧应该使用long long，然后对结果进行取余运算即可。\n1 printf(\u0026#34;%d\\n\u0026#34;,(A*B)%10); 因为最后一位数字肯定是int范围内的数字，所以可以直接以int型输出。\n对于这一题来说还有一种避免使用long long的方法。\n我们想到，对于乘法，其结果的最后一位只取决于A和B的最后一位，所以我们可以先分别求出A与B的最后一位，然后求出最后一位相乘的最后一位。\n这种把$\\left( A\\times B\\right) \\% 10$转变为$\\left[ \\left( A\\% 10 \\right) \\times \\left( B\\% 10 \\right) \\right] \\% 10$的思维，对于ACM来说很重要，因为通过各种转化，我们可以突破题目的一些数据限制，从而得到正确答案。\n思考，若题目的数据范围是$0 \\leq a,b \\leq 10^{18}$，那么我们便不能使用第一种方法，而使用后一种方法便可以轻松得到正确答案。\n这才是这一题的意义！\n","date":"2016-08-21T16:00:32Z","permalink":"https://boiltask.com/iwbtg/7/","title":"【愿成其身】[7]整数的魅力 – 数字的最后一位"},{"content":"本篇文章讲解题目：愿成其身A×B\n推荐先独立进行解题尝试，然后再阅读本篇讲解！\n对于这一题，因为C语言中用\u0026quot;*\u0026ldquo;号来表示乘法，所以我们很容易写出以下代码。\n1 2 3 4 5 6 7 #include\u0026lt;stdio.h\u0026gt; int main() { int A,B; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;A,\u0026amp;B); printf(\u0026#34;%d\\n\u0026#34;,A*B); return 0; } 提交发现wrong answer答案错误。\n分析题目数据范围：$-10^9\u0026lt;a,b\u0026lt;10^9$。\n我们知道int类型在电脑中的范围是$-2^{32}\\leq int \\leq2^{32}-1$。\n大概约为2147483648～2147483647(PS：可以自己想办法求求看哦~)\n而很显然a,b是在int范围内的，那么为什么会出现答案错误呢……\n计算A×B的范围是$-10^{18}\u0026lt;a,b\u0026lt;10^{18}$。\n超出了int范围了！\n我们可以试着输入测试数据：\n100000000 100000000\n上述程序输出了错误答案……\n怎么解决呢？\n有一种比int类型范围更大的数据类型long long(__int64)类型。\n写成两种形式是因为C语言的标准不同，导致不同的编译器版本可能有不一样的规定，具体使用哪一种类型，需要查看OJ的FAQ，一般都会特别说明(此题所使用的OJ采取long long)。\nlong long的范围大概为$-2^{64}\\leq long long \\leq 2^{64}-1$。\n使用时与int类似，声明写为：\n1 long long a; 代表声明一个名称为a的long long型变量。\n在格式化输入输出函数里，正如%d代表int型，我们用%lld代表long long型(%I64d代表__int64型)。\n所以此题即可使用long long解决。\n因为若非必要，应该优先使用int型，所以若感觉此题可用int读取a,b，则也可进行解题。\n但输出时需要注意！\n如果写作\n1 printf(\u0026#34;%lld\\n\u0026#34;,a*b); 测试发现依旧会出现错误，因为编译器计算时，a与b都是int型，则a*b就会以int型计算，这样写只不过是把这个int型以long long型输出。\n而实际上，在a*b时就已经超过int型了，所以会出现错误答案，这就属于中间结果溢出。\n那么应该怎么写呢？\n我们可以使用类型转换写为：\n1 printf(\u0026#34;%lld\\n\u0026#34;,(long long)a*b); 此语句表示把a转换为long long类型，然后与b进行乘法运算，并且结果以long long型输出。\nlong long型与int相乘，会把int型先转换为long long型，然后变成两个long long型相乘，从而得到正确结果。\n","date":"2016-08-20T16:00:01Z","permalink":"https://boiltask.com/iwbtg/6/","title":"【愿成其身】[6]A×B的学问 – 较大数的处理"},{"content":" 凡邦之有疾病者，疕疡者造焉，则使医分而治之，是亦不自医也。\n― 清·俞樾, 《群经平议·周官二》 0000|0000|0000|0000\r上次提到了C语言中的数据类型，这部分应该是比较难讲有趣的，为了防止沦落成为教学文章，只好强行引用了一句“分而治之”。事实上，我认为这也能很好地理解数据在计算机中的存储。\n首先我们应该知道，计算机是不知道怎么存储数据的，所有数据在内部都会表示成二进制\u0026quot;0\u0026quot;\u0026ldquo;1\u0026rdquo;。所以C语言中的数据结构，也便是给这些数据一个划分，比如4个一组(0000~1111[0,15])，8个一组(00000000~11111111[0,255])。这也方便理解为什么可以“自定义类型”。\n原理就讲这么多，再往深层次的讲就跑题了。-.- 事实上，这种知识也没办法投机取巧，只能在学习中进行记忆。所以我认为一个比较高效的方式就是：“用到哪里学哪里”，这就要求自己多找机会去用，否则的话便容易跟不上进度。\n了解了各种数据类型，我们也知道格式化输入输出函数。\n那么在格式化输入输出函数中的参数便可以随心所欲的使用了，比如%d代表int型，%c代表char型等。\n后面还是以例题来从使用出发讲解各个常用的类型。\n参考文章：\nC语言基本数据类型简介 - onedime\nC语言基本数据类型详解 - woods2001的专栏\n","date":"2016-08-19T16:00:49Z","permalink":"https://boiltask.com/iwbtg/5/","title":"【愿成其身】[5]数据类型 – 装数据的盒子"},{"content":"有人说：“程序员总难免开始于A+B。”\n说了这么多，我们还是停留在“定量”阶段。前面说过，黑盒测试应该是根据系统给的输入数据来进行输出数据的比较。那么，如何获取输入数据呢？\n在stdio.h中，与格式化输出printf()相对的，有格式化输入scanf()。\n对比一下两者的标准格式。\nprintf(格式化文本,参数1,参数2,……);\n其中格式化文本控制了输出的格式，在其中可以使用如\u0026quot;%d\u0026quot;这样的格式说明来替换后面的参数，第几个%d便可以指定使参数几替换它。\n这样说有点绕……\n例如：printf(\u0026quot;%d\u0026quot;,1); 的输出结果便是 1\n如果参数是个变量，比如提前建立一个整型的变量a=5(int a = 5 ;)。\n那么：printf(\u0026quot;%d\u0026quot;,a); 的输出结果便是 5\n1 2 3 4 5 6 #include\u0026lt;stdio.h\u0026gt; int main() { int a=5; printf(\u0026#34;%d\\n\u0026#34;,a); return 0; } 同理，对于scanf()函数。\nscanf(格式化文本,参数1,参数2,……);\n格式化文本代表输入的格式，参数1、2……代表变量的地址。\n-.-好 什么叫地址？暂且理解为门牌号吧。\n同样的建立一个整型的变量a，然后从键盘读取一个数赋值给他。\nscanf(\u0026quot;%d\u0026quot;,\u0026amp;a);\n好，\u0026amp;是什么意思？\n\u0026amp;a也就是取a变量的地址，这句话的意思就是从键盘读取一个数存储到a的地址。那么很显然，a变量的值也就变成了从键盘读取的值。\n1 2 3 4 5 6 7 #include\u0026lt;stdio.h\u0026gt; int main() { int a; scanf(\u0026#34;%d\u0026#34;,\u0026amp;a); printf(\u0026#34;%d\\n\u0026#34;,a); return 0; } PS：试一试从键盘输入1234567890987654321会出现什么结果，思考为什么。\n了解了如何读取数据，就可以尝试完成这道A+B问题了。\n每个OJ都要有A+B\n同样的，还是请先尝试之后再继续阅读。\n对于这一题……\n没什么说的-.-科科\n","date":"2016-08-18T16:00:36Z","permalink":"https://boiltask.com/iwbtg/4/","title":"【愿成其身】[4]从A+B谈起 – 一切的开端"},{"content":"本篇文章讲解题目：打印键盘\n推荐先独立进行解题尝试，然后再阅读本篇讲解！\n题目要求按照顺序输出键盘上的字符。\n这一道题并非难题，然而确实好多人都容易被坑到。\n其中的原因就是涉及到了转义字符的知识，所以当输出 \\ 和 \u0026quot; 时，如果不注意的话便容易出现问题。\n错误代码示例：\n1 2 3 4 5 6 7 8 9 10 11 12 #include\u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;`1234567890-=\u0026#34;); printf(\u0026#34;~!@#$%^\u0026amp;*()_+\u0026#34;); printf(\u0026#34;qwertyuiop[]\\\u0026#34;); printf(\u0026#34;QWERTYUIOP {}|\u0026#34;); printf(\u0026#34;asdfghjkl; \u0026#39;\u0026#34;); printf(\u0026#34;ASDFGHJKL:\u0026#34;\u0026#34;); printf(\u0026#34;zxcvbnm,./\u0026#34;); printf(\u0026#34;ZXCVBNM\u0026lt;\u0026gt;?\u0026#34;); return 0; } 这段代码编译会发现报错。\n为什么呢？\n在C语言中，输出时为了表示如换行，缩进等普通字符无法表示的字符时，引入了“转义字符”这一概念。\n因此如果直接输出\\，便会把它与后边字符加在一起理解为转义字符，如果想输出\\则可表示为\\。\n同理如果直接打\u0026quot;，则会认为是提前把\u0026quot;\u0026ldquo;结束了，如果想输出字符\u0026rdquo;，则需要表示为\u0026quot;。\n所以按照这个表进行改动。\n这个时候运行发现还是和结果不相同，因为所输出的字符全部在同一行。\n而我们想让它们一行输出一行，也就是“换行”。不过，多个printf是无效的，因为它只会“忠实”地执行你的代码。所以对于每一个printf来说，输出结束，它的“光标”是在输出之后的字符后面的。\n现在我们回忆起来，当我们自己输入完一行之后，我们会按回车键来使光标移到下一行。那么再看上面的表，发现换行键的转义字符为 \\n 。\n所以便可以完整的写出正确代码，就是在原代码的基础上，每输出一行便在后面加一个 \\n 即可。\n","date":"2016-08-17T16:00:52Z","permalink":"https://boiltask.com/iwbtg/3/","title":"【愿成其身】[3]转义字符 – 格式化输出"},{"content":"你听说过黑盒测试吗？\nOnlineJudge就是一个黑盒测试系统，也就是不管程序内部是如何运行的，它只判断你的程序的输出是否与输入相对应。当然，为了检测程序的效率，OnlineJudge也会加入运行时间、占用内存等评判标准。\n所以对于一道程序设计题目，我们以上一篇文章中提到的“I wanna be the guy”为例，介绍一下OJ的基础使用方式。\n在开始之前，先进入一段日常题外话。\n有没有见到过这个提示呢：\n也就是提示少了一个\u0026quot;;\u0026quot;，我们发现C语言中，每一个语句之后都有一个\u0026quot;;\u0026quot;，这是因为在C语言中，多余的这些空格、空行等是无效的(我说的是“多余的”)，所以如果不加分号，计算机编译时也不知道你这一句已经结束了，从而会报错。\n少分号错误也是新手常见错误，而且最无奈的是把中文分号当成英文分号，这个时候一般还不容易检查出来，所以在刚开始的时候就应该注意。\n言归正传(1/1)\n对于一道题，它应该有题目描述、输入描述、输出描述、样例输入、样例输出等几部分。\n题目描述：提供了这道题的背景说明，一般会讲述一个故事来吸引做题者兴趣。\n输入描述：提供了输入数据的格式、范围等信息。\n输出描述：提供了输出所要求的格式，内容等信息。\n示例输入、输出：一般会给几组测试用的数据，也就是程序把示例输入数据输进去，输出结果应该和示例输出相同(SpecialJudge也许不同)。\n提示：包含出题人对这一题的提示。\n就这一题而言，因为是一个简单的示范，所以没有输入数据，直接进行输出即可。\n从上一篇文章中学到，输出语句printf()，在这里就可以使用。\n现在假设你在本地编译器中写好了代码。\n1 2 3 4 5 #include\u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;I wanna be the guy!\u0026#34;); return 0; } 那么接下来，点击“提交”，出现提交页面，只需要把代码复制进去，进行提交即可。\n之后便会进入运行状态页面，我们可以看到程序的评判结果。\n具体结果是什么意思-.-自己探索吧。\n系统帮助 \u0026amp; FAQ\n杭州电子科技大学(hdoj)FAQ\n剩下的就是自己动手，先完成这个简单的题目吧。\n【愿成其身】I wanna be the guy\n","date":"2016-08-16T16:00:51Z","permalink":"https://boiltask.com/iwbtg/2/","title":"【愿成其身】[2]有趣的练习方式 – OnlineJudge"},{"content":" 子曰：“工欲善其事，必先利其器。居是邦也，事其大夫之贤者，友其士之仁者。”\n看到这里，想必是对ACM感兴趣的。而想要“善其事”，则必然要先了解必要的工具。对于ACM，我指的自然就是编程语言。就目前看来常用的语言有C/C++、JAVA、PASCAL等，其中C/C++就个人而言更为常用，也广泛应用于其它领域，所以这里重点以C/C++作为入门讲解。\n然而，正文却依旧不能继续，有一点非常重要。\n“语言毕竟只是算法竞赛的工具——尽管这个工具非常重要，却不是核心。”这是刘汝佳《算法竞赛入门经典(第2版)》前言中的一句话。我感觉对于ACM入门者来说非常重要，这也是很多人半途而废的原因之一。可能很多人认为ACM便是研究编程，但是我不得不说，语言入门之后离真正的算法程序还有一段距离。或者说，如果只是为了学习语言，那么ACM可能会让你失望，因为这并不是ACM的本意。甚至于在ACM中的一些常用写法，在做应用项目时可能会进行避免，因为这是两种不同的编程要求。\n但我相信，在ACM都能学好，其它领域怎么会学不好呢？\n所以人工重要的事情重复三遍。\n但我相信，在ACM都能学好，其它领域怎么会学不好呢？\n所以人工重要的事情重复三遍。\n语言毕竟只是算法竞赛的工具——尽管这个工具非常重要，却不是核心。\n语言毕竟只是算法竞赛的工具——尽管这个工具非常重要，却不是核心。\n语言毕竟只是算法竞赛的工具——尽管这个工具非常重要，却不是核心。\n我个人对C语言的看法，所谓一门“语言”，它有自己的“语法”与“单词”。我们要做的，就是遵循它的语法，用它提供的单词组合成自己“文章”。\n而作为一门实用性的学科，我主张还是“学以致用，以用促学”，所以先来看一篇“文章”。\n1 2 3 4 5 #include\u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;I wanna be the guy!\u0026#34;); return 0; } 这段简单的代码展示了C的一些基础结构，下面逐句分析。\n第一行“#include\u0026lt;stdio.h\u0026gt;”按照我们的语法喜欢，很明显这句话要分成两部分来看“#include\u0026lt;\u0026gt;”和被尖括号括在里面的“stdio.h”。这一句代表声明一个“stdio.h”的头文件，什么叫头文件……继续看下面。\n按照同样的思路，很显然下面是一个 int main(){ }和被大括号括在里面的一些句子。这里的main被称为主函数，程序的开始便是从main()函数为起点的。\n什么叫函数？-.-||\n数学里的函数见过吧……$f(x)=x+1$ 这个函数是什么意思呢，我们给这个函数一个“参数”x，那么它便会给我们一个“返回值”x+1。比如我们给个参数3，那么它便会告诉我们4，这就是函数。\n同样的，对于C语言来说，这些函数我们可以给它们传递参数，它们也会有返回值，而返回值具体是什么，自然也是可以有我们来控制。这就是编程的魅力，就是那种，“想显示什么结果，你说的不算，要看我怎么写”的霸气。\n言归正传，对于main()函数而言，我们看到它前面有个int，这就是代表的它的返回值的类型，而具体是什么类型，这将在后面数据类型中详细讲。(PS：int又被称为整型哦~)\n那么main()←这个括号呢，就如$f(x)$，这个括号自然是让你传递参数用的，而main函数作为一个特殊的“主”函数，它的参数可以省略不写。\n那你想写……那么它的参数形如“int argc,char *argv[]”……\n这都是啥啥啥……\n-.-所以我不是很想提前说这么多的嘛，你先默认把它理解为空好了。\n这样参数的问题也解决了，怎么控制返回值具体是什么呢。看一看main函数括号里面，以小学英语水平，可以明显发现一个单词“return - 返回”，那么就是翻译为返回0。\n-0是啥？\n-整数嘛。\n-所以是什么类型？\n-整型嘛。\n-所以返回值类型怎么写？\n-int嘛。\nC语言就是这么简单。 -.-\n接下来就只剩下最后一句话了“printf(\u0026ldquo;I wanna be the guy!\u0026quot;)”，很明显也是printf()与“I wanna be the guy!”组合。上面学习了函数的基本结构，那么这个printf后面也是有个括号，它与函数有没有关系。很显然我这么说了，它必然是有的。\n按照刚才的理解，括号里面的\u0026quot;I wanna be the guy!\u0026ldquo;也就是它的参数了，那么这个函数有什么用呢。\nprint-f继续按照小学英语理解，明显和印刷、打印有关系，所以这个函数也是就把它的参数“I wanna be the guy!”“打印”到屏幕上，这叫格式化输出。当然，具体怎么用，还需要进一步学习。\n我们知道，你如果想要用一个函数，你应该先把这个函数定义好。\n还是比如你输入x，想让函数返回给你x+1，那么这个函数就应该定义成$f(x)=x+1$。 可以这个printf在哪里定义的呢，为什么写上这一句话，计算机就知道把它的参数打印到屏幕上。这个时候我们再来看程序开头的那一句“#include\u0026lt;stdio.h\u0026gt;”，突然意识到了什么.jpg。\n没错，这个被叫做头文件的东西就包含了C语言一些默认的“标准库”，需要的时候只需要先声明你想要用哪些头文件，然后在你的程序里就可以调用它的函数啦(当然不只是函数，还有其他的一些东西)。\n声明方法就是#include\u0026lt;头文件名\u0026gt;。\nstdio.h就是包含了标准输入输出的一个头文件，也是常用到作为模板的一个头文件。\n更多的头文件在后面接触到的时候会继续说。\n下面就可以再来重新看一下这个代码了，很显然，这个程序可以完成把“I wanna be the guy!”这句话输出到屏幕的这个任务。\n-.-好，问题来了，怎么运行。\n这一部分我不是很想详细说，毕竟我感觉讲太详细是件不负责任的事情，因为剥夺了自己探索的乐趣。\n所以这里只提供一个下载链接，其余的……\nDev-C++(C++开发工具)V5.11.0中文免费版(不可调试)\nDev C++ V5.9.2 绿色中文版(可调试)\n接下来，怎么知道自己的程序标不标准，怎么训练自己的编程能力。\n这里涉及到ACM常用的一个训练工具，OnlineJudge。\n下面是这一个程序的题目，在题解里会详细介绍OJ的用法：\n【愿成其身】I wanna be the guy\n","date":"2016-08-15T16:00:19Z","permalink":"https://boiltask.com/iwbtg/1/","title":"【愿成其身】[1]工欲善其事，必先利其器"},{"content":" I wanna be the guy - 愿成其身\n昨天想写文章时突然想起来了这个游戏，原因却不是清楚太多……想了想，大概是这个标榜难度巨高无比游戏的背景也是个励志故事吧，所以当人物一次次的死亡时，你就会心生敬佩(虽然应该是敬佩那些能把这游戏死上一万次来通关的人)。\n其实ACM大概也是这个道理，虽然明知道一路上布满坎坷，明知道自己也许坚持不到关底，但自己也愿意去尝试一下。我很遗憾直到去年的今天都还不知道ACM是什么东东，虽然从小就标榜喜欢计算机，但却也是因为种种原因而胡乱摸索不得要领。所以，当大一时进入这个大门，人生中第一次有一群人愿意和你交流这些你喜欢的，表演真正的技术，内心才会产生出一丝激动。\n爱上ACM，大抵也就是如此。\n我以为在有一个教师老爸的前提下，在有一个万般告诫我不要当老师的老爸的前提下，在自己自认为对当老师完全不感兴趣的前提下，自己应该是对教东西不感什么兴趣的。然而慢慢发现，自己虽然对当老师不怎么感兴趣，但是对于能把自己所知道的知识讲给别人这件事，我确实还是很痴迷的。\n这也就是我想写这个系列的原因。\n与此同时，我感觉到自己也需要有所提高，所以写下这篇前言，也算是告诫自己吧。\n这个系列的文章，我的定位是作为一个餐后读物，特别是在已经看了很多专业性书之后来看，也许会更有感觉一些。强调的是“共鸣”，而非教学，所以大可把它当做一篇“ACM——我刚开始就是这么想的”。\n如果在看的时候偶然发现，“哎呀，我也是这么认为的。”，那么也算是我的荣幸了。\n点此查看本系列导读目录\nPS：\n因为文章内可能大量使用Katex渲染数学公式，所以请使用新版浏览器阅读。\n如果遇到加载失效，请刷新页面重试。\n","date":"2016-08-14T16:00:19Z","permalink":"https://boiltask.com/iwbtg/0/","title":"【愿成其身】I wanna be the guy"},{"content":" 本系列文章中涉及到的图片与链接因为年久可能出现失效，有需要可联系作者交流。\n====入门导读===== 电子科技大学CDOJ：\n【Step-By-Step】\nhttps://acm.uestc.edu.cn/\n南阳理工学院NYOJ：\n【进阶计划】\nhttp://acm.nyist.net/JudgeOnline/step.php\n====愿成其身===== 【前言】 I wanna be the guy\n【入门】 工欲善其事，必先利其器\n有趣的练习方式 – OnlineJudge\n转义字符 – 格式化输出\n从A+B谈起 – 一切的开端\n数据类型 – 装数据的盒子\nA×B的学问 – 较大数的处理\n整数的魅力 – 数字的最后一位\n实数的运用 – 整数化作的实数\n分支结构 – 程序的魅力\n问号表达式 – 酷炫的利器\n字符的本质 – ASCII的作用\n从交换输出谈起 – 黑盒的漏洞\n循环结构 – 计算机的神奇\nfor循环 – 另一种表达方法\n思维的优化 – 数学的魅力\n未完待续……\nPS 因为文章内可能大量使用Katex渲染数学公式，所以请使用新版浏览器阅读。\n如果遇到加载失效，请刷新页面重试。\n公式显示测试\n这是公式f(x)=x+1 : $f \\left( x \\right) = x + 1$\n如果显示不全请刷新页面或者更换浏览器\n=====若无意外-三日一更===== 很显然，大概有很大的意外……\n可使用rss阅读器订阅\nrss订阅地址如下\n/categories/iwbtg/index.xml\n推荐使用一览阅读订阅\n","date":"2016-08-13T16:00:25Z","permalink":"https://boiltask.com/iwbtg/introduction/","title":"【愿成其身】导读目录"},{"content":"关于题目~\n嗯……吐槽二字致敬宇神\n然后…咖啡二字 本来想写汗水，结果发现似乎写代码的也流不了多少汗吧，所以换个词语~(虽然咖啡也没大喝的说)\n刚看了几期最强大脑，还是因为郭魏撕逼大战引起的，这个节目似乎以前也听说过，不过因为高中也没什么时间看，所以没大关注，这次来看其实从节目内容来说，其实设计的还是挺不错的，不过因为其它一些原因搞得乱乱哒。\n不过这也承认了-.-我白天确实又颓废了，虽然按照设想我现在应该是两耳不闻窗外事的，不过我想我要承认现实了，这么些年，确实已经把我的热血磨灭的差不多了。或许有段时期我确实是有些天赋的(真是到现在也不愿完全承认我没天赋啊)，不过现在来说，我确实注定无法成为世界顶尖了。\n《最强大脑》这种节目展示的，其实到最后总要面对的，是人与人的天赋确实有一定差异，更何况有天赋也要挖掘啊(还是不愿承认-.-)。自小我自以为是一个挺傲的人，对于失败，或者不如别人的地方，总是想要找出各种理由。小时候看这些挑战，是想着我这方面没什么天赋但不见得其它地方没天赋，更何况那还是因为我没有练过。那现在彻底18了，也没办法在这方面骗自己了，就大脑来说，我自认为还是属于一般的。\n再加上，十多年的人生经历与生活环境，注定我的感性思考还是非常丰富的，文艺风确实会干扰我在很多地方的决定，理性的东西终究没有完全占领我的大脑。这点从到现在都有的排版强迫症什么的都可以看出来，日常生活中也是挺容易感动的一个人，对情感的捕捉也是很敏感。这明显与我心目中的牛逼程序员不符，虽说技术牛逼不一定就是完美，但能力确实是应该被钦佩的东西。嗯……刚删掉了一个最，毕竟还有其它很多也值得钦佩。\n没办法了，无法成为世界上最牛逼的程序员，或许也开创不了一个新高度，但我同样还是热爱这一行业，这是我坚信不疑的。所以，这条道路，在下还是要走，毕竟每一个行业，有标竿，也注定要有基石，我会努力缩短与标杆的差距，嗯……删掉一个努力成为标杆。\n天赋不够，咖啡来凑呗。在下自认天赋现在已经肯定不是顶尖的，估计再过段时间连中等偏上都骗不了自己，要被证实最多一般。但是，为了能做出点什么，也是要在内心告诫自己啊。\n很简单的道理，如果这几年努力了，我今后的日子还有继续努力的机会，如果这几年颓废了，可能今后连努力的机会都没有，能做什么呢？网管？修电脑的？或许最好的结果，真做了一名不起眼的写代码的。到那时候，可能真的想努力都没机会了，没时间了，没精力了。写下这篇文章，若是以后努力了，可以拿来解解闷，要是颓废了，也可以看看来回味从前啊。\n","date":"2016-01-29T15:47:13Z","permalink":"https://boiltask.com/csdn/50609642/","title":"【吐槽】天赋不够 咖啡来凑"},{"content":"嗯…有几件事情要先写一写\n感觉不说点什么不是我的风格 所以我决定写写这个系列日志~标题我考虑再三还是用这一个啦 毕竟这是绕不开的话题\n其实写这篇日志的时候已经彻底步入18了…话说这么晚了写日志会不会突然睡着…-_-|| 其实阳历生日是12月12 虽然早就过了 但心中还有点不舍嘛 所以强行拖到了农历生日才这么珍重\n我都说了 我这辈子最在乎的关于生理上的一是…呃…不说了 二便是年龄 感觉我有这种心态和@冀丹妮是抹不开的毕竟逼我发说说逼了一天 而且既然都不介意我说说了那我就不介意@出来了啊 完蛋了…感觉又要HOLD不住我要说些什么了…\n算啦算啦 我就顺便说说吧 省了再发说说了 标题都这么取了 不聊妹纸真是毫无意义啊\n想想现在QQ里 经常出现的身影 除了小学同桌…嗯…幼儿园也同过桌吧~那时候没分那么清就属于@冀丹妮认识时间最久了吧 哎…话说这篇日志要不要设置阅读权限-_-||\n算了 任性 设置权限不是我的风格 今生最讨厌任何形式的权限狗╭(╯^╰)╮\n我靠…忍住不好意思写的感受强行写！\n丹妮~嗯 我向来是不介意别人知道有这个人的 我感觉这已经成为我的一道坎了 我不喜欢删说说删日志 我承认我是个看重回忆的人 我觉得那些东西都没用 什么IT男 我对网上的一些数据看的其实并没有那么神圣 所以往往放在那里就懒得动了 谁愿意看就去看好了 换句话说 人家都愿意花时间去了解你的过去了 你还有什么理由拒绝呢？\n说起IT男 我认为我似乎又并不是个严格的IT男 我一直认为我是有文艺青年的气息的 这种感觉在初三下学期到高一表现的特别强烈 也许 没有计算机我真的能成为徐志摩呢哈哈哈 虽然我现在并不认为徐志摩是个什么好男人 那就是个禽兽啊所以我感觉现在还好 唉~虽然现在估计离开了计算机也不行了啊 智商明显下降 情商…感觉好久没正式试过了 不好说\n多想回到那遥远的从前啊 至少 我还有许多没干的事情可以去做 我曾经想 18岁之前我要这样这样这样 然而现在基本死完了\n我在想我为什么还没找女朋友呢 ……我说了 我对爱情是有洁癖的 …呃…我不相信我这么屌没妹纸喜欢\n只不过…不敢了…\n我觉得但不是我存在什么走不出来什么的 毕竟有没有在谈恋爱 这么长时间了该看开的早就看开了 只是 心好累 或者说 我已经没有信心再对另一个人做这么多了 如果我不能 那么 我认为这对于妹纸是不公平的 那我良心上是会受谴责的\n本身不想再提的嘛\n但既然都说了\n我的语言组织能力竟然实在是绕不开 不知道怎么说 这么长时间 想想对我说过的 最深入脑海的竟然是 抱歉和对不起 也是醉了\n话说我现在还这么矫情不合适吧…毕竟…醉了 醉了…不想写了…\n啊呀…好难啊 算了 反正设的所有人可见 任性 正如有牛逼的人说 我不是针对你一个人 我是说在座的各位 都是垃圾…那么~我不是针对你一个人 我是说 在看的各位 真认真看到这里的也是不容易…\n我为什么整天喊着要妹纸啊~因为从内心深处已经觉得 对我谈恋爱感觉非常不自然…妹纸是拿来护着的 不是拿来谈恋爱的…感觉再这样发展下去真成中央空调了…\n其实空调就空调嘛…从小受到的是什么教育…妹纸就是天生要被守护的 我妈本身就是个可爱的女孩~就不多说了 下一篇日志再说吧 就连我爸都表示 最起码的 出去吃饭不能让人家女生付钱…对于这一点…非常惭愧的是在下有时候确实穷啊\n但从小就是…培养所谓绅士风度嘛 你懂得\n看红楼梦的时候我不知道其他人对贾宝玉这个人 包括他的行为 包括他的名言“女人是水做的 男人是泥做的”是怎么理解的 我起初迷迷糊糊的只是仿佛感觉挺有道理 虽然带有一丝玩笑…但现在我确实有这个感觉 就是…一个开朗的女生会给人感觉很单纯 一个男生…嗯…禽兽？哈哈 其实我一直的意见都是 如果你觉得一个女生的行为是坏的 那也一定是被身边的男生带坏的 所以我轻易是不会去讨厌一个人的 特别是妹纸\n那么…不讨厌就是喜欢？\n我有时候在想 如果对每一个妹纸都好 那么…对女朋友呢？更进一步 对妻子呢？我仔细想…答案是…有点不知道？所以我并不想谈恋爱 说了 恋爱这种状态 特别是高中 更甚者初中 一定是要有人出来拒绝的 否则对两个人还是弊处无穷 所以…我对被发好人卡并不是特别难受…呃…虽然当时有点 但想想其实还好 但…\n我靠 不谈恋爱就和谁也别谈啊…给我发好人卡 我还能自我安慰 但…我勒个去 你让我怎么办嘛 所以在那之前的一段时间我不断缠着…我有预感的…但…骗不了自己的…虽然我可以一本正经的胡说八道到让人家都觉得很有道理 但…骗不了我自己啊！\n我知道 发觉到了…已经渐行渐远…所以当我知道…那个什么…我无奈 我失望 但我不意外…毕竟…距离是很重要的 有些事情虽然我自认我有空间条件我也能做 还做得可以更好 但我没有…而且我的一些东西不足以超越空间…\n知道吗…前几天做那个相册的时候 我是边吐槽边骂边灌水做出来的 为此还麻烦了萌萌哒苏贺听了我一晚上的槽 最日了狗的…我做好了不理我了╭(╯^╰)╮ 然后我就在那一遍一遍的循环那个小视频 7.14…前一天我们去唱的歌 那次唱歌其实真不是我约的 是小圣博自作主张举办的 他请客我掏钱-_-||因为我知道当时的情况 叫你你肯定不去…话说这不是一篇第二人称的日志！！！人称还改不回来了…\n无所谓╮(╯_╰)╭啦 反正看到这里的基本也是真爱了 都不知道日志能不能发这么长的字数…\n当时我吐槽说…这一去 估计要出事…啊…哈哈\n圣博是知道我好多事情的…问我值吗 我一直在表示闲着也是闲着 或者~我才不承认我还在联系 然后现在想想…我真不知道怎么搞了…特别是在我发了这篇日志之后…\n哈哈哈 我是个相信每个人都有故事的人 大学生啊特别是优秀的 没被人惦记过说出去我都不信所以…什么是洁癖呢 也许在我还相信真爱之前 我一直都会有吧…所以我内心是不希望看到分手啊什么的 看了爱情观是要受打击的…所以年轻不懂事…那么就坚持到年老吧\n嗯…说这话是不是有点没良心…哈哈哈\n就我个人来说 我不介意坦白~或者 我更希望在和我接触之前便了解过我 这样才更深刻的了解我 毕竟爱情面前 人是可以展现的淋漓尽致的 至少我还是这样 或者说 人是应该展现的淋漓尽致的…\n爱情观这种东西…我认为我还是基本成熟着的…正如开头我说 我不知道我还能不能再用心去呵护一个人 或者说 比起呵护爱情 我现在也确实愿意陪伴计算机 前几天发的说说 代码是最好的伙伴 它忠诚的执行你的命令 所谓秘之BUG也大都源自自己 所以…我现在还是感觉计算机更靠谱…爱情 是奢侈品 我这屌丝心态奢侈品应该是享用不起了但又真心不想让爱情掉价…所以就不如放在那里吧 每天 我要妹子我要妹子 也挺好 有限的经历还是要投入到无限的为人民服务中去啊~\n对了 关于那个如何对女朋友如何对妻子得问题…我勒个去…又忘了想要说什么了…要不谁来帮我回忆回忆 来个情景模拟好啦~哈哈哈\n两点了哎…明天还有太极拳…明天想说就再接着说吧~祝我自己明天考试超神 18岁的正式第一天过得开心(∩_∩)\n","date":"2015-12-23T17:57:45Z","permalink":"https://boiltask.com/qzone/1450893451/","title":"18岁的那些事——关于爱情"},{"content":"想一想 似乎好久没写过日志了……\n确实是，毕竟平时想说点什么都直接发说说了，而且还没法判断字数到底有多少，于是导致了经常出现一些长段说说……这次本来也是想发说说的，但想想似乎大学以来都没写过日志，而且今天写了挺多篇的博客了，有手感，所以还是来写成日志了。其实……最关键的……我有预感，我会说的挺多的……\n当时为了情怀建立了www.BoilTask.com这个网站 但并没有想好怎么做 搞得并没有什么卵用\n关心一下我的应该知道我在搞ACM这方面的东西 然后其实感触挺多的\n三个多月了，也许不算特别长的时间 但当我们在讨论寒假啦 怎么回家啦 期末考试啦什么的 才发觉……大一上学期这就要结束了。我做了什么呢？好像并没有干什么事情……颓废了一个学期，其实想想也是挺难受的。\n这两天在写博客http://blog.csdn.net/u011493189;\n也是在填之前挖出的坑 然后自然也是翻了翻学长的博客，真正让我决定写点什么的导火索 是宇神的博客 确实看着挺有感觉的\n这是学长2014年12月28日写的一篇博客……有句话我觉得说的 挺……\n“我不是一个学霸，我也不想去做一个学霸。如果为了那些爱我的人和我爱的人，我必须要成为所谓的学霸才能让他们欣慰，我也心甘情愿去承受这一切。即使再苦，再累，我也不会后悔，更不会在这条我选择的路上给自己回头的理由。即使泪流满面，我也会笑着走完自己的路。”\n学长的博客名便叫做了笑着走完自己的路……\n我注意到学长第一篇博客是发在 2014年12月21日00:41 也就是去年今天的晚上\n然后直到今天学长也是上传了几道我并不懂得题\n一年时间学长传了一千多篇博文，很不容易的……我不知道自己一年之后能不能做到这样……确实不知道……虽然牛还是要先吹为敬，但真正想想，确实是不容易的……\n我喜欢计算机 喜欢编程 这是毋容置疑的，但同时，我也是有文艺青年的多愁善感和二逼青年的蹉跎时日，也就是，我能写一天一夜代码不停，也能写一天一夜文章不停，同时也能玩一天一夜游戏不停，这都是有可能的……所以，我现在确实是不知道未来会怎样。\n这次的周练内心是崩溃着的，之前的周练布置下来，没灵感 放放 再看看，循环几次也就好了，这次……没灵感 放放 再看看 还是炸，总结下来就是自从吃了18岁的蛋糕智商明显下降，有必要考虑考虑农历生日重新吃一遍……\n嗯……我还想说什么来着……不知道……忘了……想起来在再水吧~\n周练我还要去挣扎挣扎……\n但愿一年以后有人来看我 也能有点感触吧~\n至少 我看着学长及学长的学长还是有些被感染的\n学计算机的 适当傲一点我认为还是必要的\n扶我起来 我还能继续WA\n","date":"2015-12-20T09:29:19Z","permalink":"https://boiltask.com/qzone/1450603741/","title":"【震惊哭】竟然决定用日志水了"},{"content":"终于想明白了博客的意义\n嗯……至少\n帮忙记录下自己AC的总题目数啊~\n算是个计数器吧\n没事还能吐吐槽 回忆回忆\n本分类下的题目时间都比较早\n可能写的描述文字就少点了\n以后尽量写代码和写博客放在一起吧~\n","date":"2015-12-19T08:47:04Z","permalink":"https://boiltask.com/csdn/50358873/","title":"写在正式写博客之前——博客的意义"},{"content":"程序的魅力也体现在解决问题的方式往往有很多\n下面这个手机短号已经做了好多遍了……\n估计以后整理时还要再写一遍……\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include\u0026lt;stdio.h\u0026gt; int main() { int n; int i; char m[12]; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); while(n--) { scanf(\u0026#34;%s\u0026#34;,m); printf(\u0026#34;6%s\\n\u0026#34;,m+6); } return 0; } 这便是计算机的精彩~不是吗？\n","date":"2015-12-19T08:40:54Z","permalink":"https://boiltask.com/csdn/50358847/","title":"初识ACM——活泼的精灵"},{"content":"最经典的例子\n0\u0026lt;a\u0026lt;100\n便需要写成\n0\u0026lt;a\u0026amp;\u0026amp;a\u0026lt;100\n这便是要求思维的转换与用法的规范\n每一个地方都有它的规则\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include\u0026lt;stdio.h\u0026gt; int main() { int n; while(scanf(\u0026#34;%d\u0026#34;,\u0026amp;n)!=EOF) { if(n\u0026lt;=100\u0026amp;\u0026amp;n\u0026gt;=0) { if(n\u0026lt;60) printf(\u0026#34;E\\n\u0026#34;); if(n\u0026gt;=60\u0026amp;\u0026amp;n\u0026lt;70) printf(\u0026#34;D\\n\u0026#34;); if(n\u0026gt;=70\u0026amp;\u0026amp;n\u0026lt;80) printf(\u0026#34;C\\n\u0026#34;); if(n\u0026gt;=80\u0026amp;\u0026amp;n\u0026lt;90) printf(\u0026#34;B\\n\u0026#34;); if(n\u0026gt;=90\u0026amp;\u0026amp;n\u0026lt;=100) printf(\u0026#34;A\\n\u0026#34;); } else { printf(\u0026#34;Score is error!\\n\u0026#34;); } } return 0; } 话说现在看这样的题……这题也出？-.-\n","date":"2015-12-19T08:37:15Z","permalink":"https://boiltask.com/csdn/50358835/","title":"初识ACM——这是程序的世界"},{"content":"在写代码时被一学长看见在南阳OJ上做题\n于是被夸了两句~当时心情好激动哦\n于是摸到了求绝对值的题秒写代码！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include\u0026lt;stdio.h\u0026gt; int main() { double n; while(scanf(\u0026#34;%lf\u0026#34;,\u0026amp;n)!=EOF) if(n\u0026gt;0) { printf(\u0026#34;%.2lf\\n\u0026#34;,n); } else { printf(\u0026#34;%.2lf\\n\u0026#34;,n=-n) ; } return 0; } 话说我起这个题目就放这个代码合适吗……\n-.-\n","date":"2015-12-19T08:31:12Z","permalink":"https://boiltask.com/csdn/50358816/","title":"初识ACM——崭露头角"},{"content":"渐渐的……\n我也能写出来一些当时看很复杂的代码了……\n这是一个奇偶数分离的程序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include\u0026lt;stdio.h\u0026gt; int main() { int i,k,n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;i); int a[i] ; for(k=0;k\u0026lt;i;k++) { scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[k]); } for(k=0;k\u0026lt;i;k++) { for(n=1;n\u0026lt;=a[k];n++) { if(n%2==1) printf(\u0026#34;%d \u0026#34;,n); } printf(\u0026#34;\\n\u0026#34;); for(n=1;n\u0026lt;=a[k];n++) { if(n%2==0) printf(\u0026#34;%d \u0026#34;,n); } printf(\u0026#34;\\n\\n\u0026#34;); } return 0; } 虽然现在看能改进的地方挺多的\n但是…当时看…已经很不错了好吧 ！\n","date":"2015-12-19T08:28:02Z","permalink":"https://boiltask.com/csdn/50358804/","title":"初识ACM——渐入佳境"},{"content":"当时遇见的5个数求最值的问题\n鉴于当时并不会排序\n发现这个问题可以不用排序而是直接寻找就行了\n真的很庆幸啊！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include\u0026lt;stdio.h\u0026gt; int main() { int n,m[5],min,max; for(n=0;n\u0026lt;5;n++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;m[n]); max=min=m[1]; for(n=0;n\u0026lt;5;n++) { if(m[n]\u0026gt;=max) max=m[n]; if(m[n]\u0026lt;=min) min=m[n]; } printf(\u0026#34;%d %d\u0026#34;,min,max); return 0; } 呃……虽然好像现在来看……你懂得~\n","date":"2015-12-19T08:26:55Z","permalink":"https://boiltask.com/csdn/50358795/","title":"初识ACM——幸好不用排序"},{"content":"为了探究for循环的用法\n需要编写一个求前n项和的程序\n在完成基本的程序之后\n我又写出了下面这个鬼……\n1 2 3 4 5 6 7 8 9 10 11 #include\u0026lt;stdio.h\u0026gt; //求前n项和 int main() {int shouxiang,qianjixiang,he; shouxiang=1; he=0; for (qianjixiang=1;qianjixiang\u0026lt;=3;qianjixiang++) {he=shouxiang+he; shouxiang=shouxiang*2; } printf(\u0026#34;%d\u0026#34;,he); } -.-完全没问题的代码\n虽然这个强的怨念似乎毫无意义啊……\n","date":"2015-12-19T08:23:45Z","permalink":"https://boiltask.com/csdn/50358781/","title":"初识ACM——中文的信仰"},{"content":"当时最大的感觉就是……\n九九乘法表只需要这么少的代码就能打出来？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;stdio.h\u0026gt; int main(){ int i,j,n; for(i=1;i\u0026lt;=9;i++){ // 将下面的for循环注释掉，就输出左下三角形 // for(n=1; n\u0026lt;=9-i; n++) // printf(\u0026#34; \u0026#34;); for(j=1;j\u0026lt;=i;j++) printf(\u0026#34;%d*%d=%2d \u0026#34;,i,j,i*j); printf(\u0026#34;\\n\u0026#34;); } return 0; } 后来据说九九乘法表是刘可学长的入ACM的题\n","date":"2015-12-19T08:19:28Z","permalink":"https://boiltask.com/csdn/50358768/","title":"初识ACM——九九乘法表"},{"content":"学长讲解输出及数据类型\n代码是这样的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;cstdio\u0026gt; int main (){ char c; char d; int a = 1234; float f = 3.141592653589; double x = 0.12345678987654321; c = \u0026#39;\\x41\u0026#39;;//十六进制 d = \u0026#39;\\101\u0026#39;;//八进制 printf(\u0026#34;a = %d\\n\u0026#34;, a); printf(\u0026#34;a = %6d\\n\u0026#34;, a); printf(\u0026#34;a = %2d\\n\u0026#34;, a); printf(\u0026#34;a = %-6d--\\n\u0026#34;, a); printf(\u0026#34;a = %06d\\n\u0026#34;, a); printf(\u0026#34;a = %02d\\n\u0026#34;, a); printf(\u0026#34;f = %f\\n\u0026#34;, f); printf(\u0026#34;f = %6.4f\\n\u0026#34;, f); printf(\u0026#34;x = %lf\\n\u0026#34;, x); printf(\u0026#34;x = %18.16lf\\n\u0026#34;, x); printf(\u0026#34;c = %c\\n\u0026#34;, c); printf(\u0026#34;c = %d\\n\u0026#34;, c); printf(\u0026#34;c = %x\\n\u0026#34;, c); printf(\u0026#34;d = %c\\n\u0026#34;, d); printf(\u0026#34;d = %d\\n\u0026#34;, d); printf(\u0026#34;d = %x\\n\u0026#34;, d); return 0; } 我的内心是崩溃的-.-\n但现在看看其实还好 也是开始向C语言探索迈步\n","date":"2015-12-19T08:17:23Z","permalink":"https://boiltask.com/csdn/50358750/","title":"初识ACM——这都是啥-.-"},{"content":"无聊的时候 根据经验\n让自己感受到趣味是最好的事情\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #define N 100 //这个程序的关键部分是借鉴了学长展示的 I love U 那一段代码 //所以我个人认为还是没什么实际意义的 //主要是上完课了，光AC题也比较枯燥 //所以写下这个打字机效果巩固巩固学到的知识 //需要说明的我会在下面代码中进行注释 HANDLE hConsole; void gotoxy(int x, int y) { COORD coord; coord.X = x; coord.Y = y; SetConsoleCursorPosition(hConsole, coord); } //这个函数是直接复制的 I love U 那一段函数 int main() { int i,j,k; char *title[9]= {\u0026#34;简\u0026#34;,\u0026#34;单\u0026#34;,\u0026#34;的\u0026#34;,\u0026#34;书\u0026#34;,\u0026#34;写\u0026#34;,\u0026#34;文\u0026#34;,\u0026#34;字\u0026#34;,\u0026#34;效\u0026#34;,\u0026#34;果\u0026#34;}; //这一段本来可以直接用多个frintf函数来写 //单因为想巩固一下数组的知识，所以用了数组和一段循环语句来实现 //但必须承认我对C语言中的数据类型还是有太多没理解的 //所以也是百度了许多资料 //这个写法貌似用到了“指针”，我 百度一下还是没太理解 //所以只是这么写出来了，但具体的真正含义还是一知半解的 //而且导致编译时下面出现[Warning],但没看出影响运行 //所以我也没改进 ,待掌握更多时再改吧 hConsole = GetStdHandle(STD_OUTPUT_HANDLE); //这一句应该是句柄相关的,不是很懂,也是直接复制的那一段源码 while(1) //这一个while控制无限循环 { gotoxy(15,2); for(i=0; i\u0026lt;9; i=i+1) { printf(\u0026#34;%s\u0026#34;,title[i]) ; Sleep(150); } //上面那个就是提取一个字一个字的输出了 //不是特别懂,我是基于易语言中提取文本型数组的思路写的 //不知道理解的对不对 Sleep(750); gotoxy(30,3); printf(\u0026#34;——BoilTask \u0026#34;); Sleep(1000); printf(\u0026#34;(欧阳天)\u0026#34;); Sleep(1000); printf(\u0026#34; 计算机1504\u0026#34;); Sleep(1000); j=9; for(k=0; k\u0026lt;3; k++) { for(i = 0; i\u0026lt;9; i ++) { gotoxy(j,7+i); printf(\u0026#34;*\u0026#34;); Sleep(N); } j=j+11; } j=53; for(k=0; k\u0026lt;2; k++) { for(i = 0; i\u0026lt;7; i ++) { gotoxy(j,7+i); printf(\u0026#34;*\u0026#34;); Sleep(N); } j=j+11; } gotoxy(12,18); Sleep(1000) ; printf(\u0026#34;猜猜这将形成什么文字？\u0026#34;); Sleep(2000); for(i=0; i\u0026lt;21; i++) { gotoxy(33-i,18); printf(\u0026#34;\\b \u0026#34;); Sleep(N); } //这里的一个字一个字删除用了\\b+空格来实现 //因为没想到好的思路…… //还是对好多东西不理解 gotoxy(11,11); for(i = 0; i\u0026lt;8; i ++) { printf(\u0026#34;*\u0026#34;); Sleep(N); } gotoxy(33,7); for(i = 0; i\u0026lt;6; i ++) { printf(\u0026#34;*\u0026#34;); Sleep(N); } gotoxy(40,8); printf(\u0026#34;*\u0026#34;); for(i = 0; i\u0026lt;2; i ++) { gotoxy(41,9+i); printf(\u0026#34;*\u0026#34;); Sleep(N); } gotoxy(40,11); printf(\u0026#34;*\u0026#34;); for(i = 0; i\u0026lt;6; i ++) { gotoxy(38-i,12); printf(\u0026#34;*\u0026#34;); Sleep(N); } gotoxy(54,14); printf(\u0026#34;*\u0026#34;); gotoxy(55,15); for(i = 0; i\u0026lt;8; i ++) { printf(\u0026#34;*\u0026#34;); Sleep(N); } gotoxy(63,14); printf(\u0026#34;*\u0026#34;); gotoxy(25,20); Sleep(1000) ; printf(\u0026#34;祝河南理工走向辉煌~\u0026#34;); //没什么亮点的一句结束语 Sleep(8000); system(\u0026#34;cls\u0026#34;); } } //说点题外话 我在学习C语言的过程中 //从小以来计算机是对我来说称之为梦想的东西 //其实想想在很多方面都下过劲 //html flash AE PS Au 等等…… //易语言是其中我研究成果中最靠谱的一个 //因为完成了能拿的出手的一些成品 //现在我仍旧觉得,其实以前学的这些知识并不重要 //关键是学习的方法和学习的态度！ //这也是我想和那些对计算机充满热情的同学们说的 //为了梦想,大家共勉！ 这个貌似是开学之后一段时间写的\n然后正好提到了那个 I❤U 所以一块放上来吧\n注释……嗯……写的还好\n哈哈哈哈\n","date":"2015-12-19T08:12:46Z","permalink":"https://boiltask.com/csdn/50358715/","title":"初识ACM——学习与趣味"},{"content":"还是学长为了展示C语言的趣味\n放了一段C语言写的生成 I❤U 效果的程序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #define N 50 HANDLE hConsole; void gotoxy(int x, int y) { COORD coord; coord.X = x; coord.Y = y; SetConsoleCursorPosition(hConsole, coord); } int main() { int i,j,k; hConsole = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleTextAttribute(hConsole, FOREGROUND_RED|FOREGROUND_BLUE|FOREGROUND_INTENSITY); for(k=0;k\u0026lt;3;k++) { gotoxy(4,6); for(i = 0;i\u0026lt;11;i ++) { printf(\u0026#34;*\u0026#34;); Sleep(N); } for(i = 0;i\u0026lt;12;i++) { gotoxy(9,7+i); printf(\u0026#34;*\u0026#34;); Sleep(N); } gotoxy(4,18); for(i = 0;i\u0026lt;11;i ++) { printf(\u0026#34;*\u0026#34;); Sleep(N); } gotoxy(36,10); printf(\u0026#34;*\u0026#34;); Sleep(N); gotoxy(25,10); printf(\u0026#34;*\u0026#34;); Sleep(N); gotoxy(47,10); printf(\u0026#34;*\u0026#34;); Sleep(N); gotoxy(34,8); printf(\u0026#34;*\u0026#34;); Sleep(N); gotoxy(38,8); printf(\u0026#34;*\u0026#34;); Sleep(N); gotoxy(30,7); printf(\u0026#34;*\u0026#34;); Sleep(N); gotoxy(42,7); printf(\u0026#34;*\u0026#34;); Sleep(N); gotoxy(27,8); printf(\u0026#34;*\u0026#34;); Sleep(N); gotoxy(45,8); printf(\u0026#34;*\u0026#34;); Sleep(N); gotoxy(25,11); printf(\u0026#34;*\u0026#34;); Sleep(N); gotoxy(47,11); printf(\u0026#34;*\u0026#34;); Sleep(N); for(i=1,j=1;i\u0026lt;6,j\u0026lt;6;i++,j++) { gotoxy(25+i,11+j); printf(\u0026#34;*\u0026#34;); Sleep(N); } gotoxy(32,17); printf(\u0026#34;*\u0026#34;); Sleep(N); gotoxy(34,18); printf(\u0026#34;*\u0026#34;); Sleep(N); for(i=1,j=1;i\u0026lt;6,j\u0026lt;6;i++,j++) { gotoxy(47-i,11+j); printf(\u0026#34;*\u0026#34;); Sleep(N); } gotoxy(40,17); printf(\u0026#34;*\u0026#34;); Sleep(N); gotoxy(38,18); printf(\u0026#34;*\u0026#34;); Sleep(N); gotoxy(36,19); printf(\u0026#34;*\u0026#34;); Sleep(N); for(i=0;i\u0026lt;11;i++) { gotoxy(59,6+i); printf(\u0026#34;*\u0026#34;); Sleep(N); } gotoxy(61,17); printf(\u0026#34;*\u0026#34;); Sleep(N); for(i=0;i\u0026lt;11;i++) { gotoxy(63+i,18); printf(\u0026#34;*\u0026#34;); Sleep(N); } gotoxy(74,17); printf(\u0026#34;*\u0026#34;); Sleep(N); gotoxy(76,16); printf(\u0026#34;*\u0026#34;); Sleep(N); for(i=0;i\u0026lt;10;i++) { gotoxy(76,15-i); printf(\u0026#34;*\u0026#34;); Sleep(N); } system(\u0026#34;cls\u0026#34;); } while(1) { gotoxy(4,6); for(i = 0;i\u0026lt;11;i ++) { printf(\u0026#34;*\u0026#34;); } for(i = 0;i\u0026lt;12;i++) { gotoxy(9,7+i); printf(\u0026#34;*\u0026#34;); } gotoxy(4,18); for(i = 0;i\u0026lt;11;i ++) { printf(\u0026#34;*\u0026#34;); } gotoxy(36,10); printf(\u0026#34;*\u0026#34;); gotoxy(25,10); printf(\u0026#34;*\u0026#34;); gotoxy(47,10); printf(\u0026#34;*\u0026#34;); gotoxy(34,8); printf(\u0026#34;*\u0026#34;); gotoxy(38,8); printf(\u0026#34;*\u0026#34;); gotoxy(30,7); printf(\u0026#34;*\u0026#34;); gotoxy(42,7); printf(\u0026#34;*\u0026#34;); gotoxy(27,8); printf(\u0026#34;*\u0026#34;); gotoxy(45,8); printf(\u0026#34;*\u0026#34;); gotoxy(25,11); printf(\u0026#34;*\u0026#34;); gotoxy(47,11); printf(\u0026#34;*\u0026#34;); for(i=1,j=1;i\u0026lt;6,j\u0026lt;6;i++,j++) { gotoxy(25+i,11+j); printf(\u0026#34;*\u0026#34;); } gotoxy(32,17); printf(\u0026#34;*\u0026#34;); gotoxy(34,18); printf(\u0026#34;*\u0026#34;); for(i=1,j=1;i\u0026lt;6,j\u0026lt;6;i++,j++) { gotoxy(47-i,11+j); printf(\u0026#34;*\u0026#34;); } gotoxy(40,17); printf(\u0026#34;*\u0026#34;); gotoxy(38,18); printf(\u0026#34;*\u0026#34;); gotoxy(36,19); printf(\u0026#34;*\u0026#34;); for(i=0;i\u0026lt;11;i++) { gotoxy(59,6+i); printf(\u0026#34;*\u0026#34;); } gotoxy(61,17); printf(\u0026#34;*\u0026#34;); for(i=0;i\u0026lt;11;i++) { gotoxy(63+i,18); printf(\u0026#34;*\u0026#34;); } gotoxy(74,17); printf(\u0026#34;*\u0026#34;); Sleep(100); gotoxy(76,16); printf(\u0026#34;*\u0026#34;); for(i=0;i\u0026lt;10;i++) { gotoxy(76,15-i); printf(\u0026#34;*\u0026#34;); } gotoxy(25,22); Sleep(1000); system(\u0026#34;cls\u0026#34;); } } (话说这个代码还是我从网上搜到的……学长又没及时传播)\n话说之后我根据这写了一个屌屌的程序呢~\n","date":"2015-12-19T08:05:06Z","permalink":"https://boiltask.com/csdn/50358687/","title":"初识ACM——C的love"},{"content":"何家欢学长为吸引同学们兴趣\n展示了一个C语言程序如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { int a,n; printf(\u0026#34;1.关机\\n\u0026#34;); printf(\u0026#34;2.崩溃！\\n\u0026#34;); printf(\u0026#34;\\t——BoilTask\\n\u0026#34;); printf(\u0026#34;你的选择:\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;a); if(a==1) system(\u0026#34;shutdown -s -t 120\u0026#34;); else if (a==2) { for(n=0; n\u0026lt;10; n++) system(\u0026#34;start\u0026#34;); } else { printf(\u0026#34;你输入的格式有错误哦~\u0026#34;); }; return 0; } 然后提示如果把关机或者崩溃的参数修改便会给用户带来麻烦\n(这个代码是我自己根据效果写的……学长才不会没节操的传播呢)\n然后坏坏的我写下了一个真的有麻烦的代码……\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; int main() { int a,n=0; printf(\u0026#34;1.真关机\\n\u0026#34;); printf(\u0026#34;2.真崩溃！\\n\u0026#34;); printf(\u0026#34;\\t——BoilTask\\n\u0026#34;); printf(\u0026#34;你的选择:\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;a); if(a==1) system(\u0026#34;shutdown -p\u0026#34;); else if (a==2) { while(n\u0026lt;1) system(\u0026#34;start\u0026#34;); } else { printf(\u0026#34;你输入的格式有错误哦~\u0026#34;); }; return 0; } 话说那段时间关机都直接帅帅地运行这个程序来关机-.-\n","date":"2015-12-19T07:57:59Z","permalink":"https://boiltask.com/csdn/50358657/","title":"初识ACM——伪病毒与真崩溃"},{"content":"(今天来找时间写写播客吧~)\n随着入学及军训期间的对ACM及C语言的了解\n我决定了国庆节假期提前回校两天参加ACM协会举办的C语言基础培训\n何家欢学长讲何谓语言：\n编程语言\n1.机器语言\n101010101010\n2.编汇语言\n1 add 2\n3.高级语言\n——面向过程——\nC\n——面向对象——\nC++\nC#\nJava\n数据类型：\nPrintf\n%x 16进制输出\n%d 10进制输出\n%c 字符\n%lf 小数输出\n0x 16进制\n08进制\ne-2 10的-2次方 科学计数法\n‘A’ 单引号里只能有一个字符\n“ab”双引号里可有字符串\n数组:\nA[10]\n一个10个元素的数组\n其中元素为 A[0]、A[1]~A[9]\n开启ACM之路！\n","date":"2015-12-19T07:49:17Z","permalink":"https://boiltask.com/csdn/50358599/","title":"初识ACM——2015国庆培训"},{"content":"写在前面的\n其实这篇日志酝酿好久了,空闲时候就在那里想,到真要写日志的时候就不想动手了,再加上最近我对这种事情是比较拒绝的,毕竟不是特别熟的人,都会觉累不看,况且因为这发出来心里也就过瘾了嘛~\n不过也是适逢七夕,内心有点小波动,于是还是写个日志说一说吧,大家尽量看完呗~\n毕竟以后的机会也恐怕不多了,一是有高四的同学,二来我的网站煮梦空间也需要内容丰富,建好之后这种东西我尽量放在那边了。\n首先…选择复读的亲们\n从内心讲，我佩服你们…因为面对现实，你们还能继续奋斗，而我还是想定义为选择了逃避…\n或许我的大学是你们的目标，但我们面对的性质都一样，都没达到自己的理想。\n一年前的这个时候，我还依旧没把郑大放在眼里。\n这是实话，以致去年顺道去河南工业大学的时候，我完全是按照看笑话的想法去的。何曾想到填志愿时唯一靠谱的郑州的大学正是它…想想完全没考虑它的原因还是我依旧有些傲的…其实，填志愿时，我对郑州还是挺向往的~因为…嗯…知道真正原因的人我猜已经看不到这里了…所以开玩笑似的第一志愿填郑大嘛\n本来我是做好二本的准备的，但…一本河南理工大学可怜我，要我了…那你看我也不能对不起他吧…只是在焦作有点偏了…但焦作还有云台山呢环境不错嘛去玩可以找我当导游~\n欢迎志愿填报河南理工来当我的学弟学妹吧哈哈~\n至于今年去大学的同学我只说声不要辜负曾经的梦想！\n哎呀~又是打着打着不想发了…这耐心大学怎么办…\n虽然这个七夕还是单身…但我希望……\n大学四年还是单着吧~我是要追求事业的男人！嘻嘻~\n话说高中开学了我要去老城玩耍耍耍耍！\n…………check point………2015.8.20………\n","date":"2015-08-20T15:07:49Z","permalink":"https://boiltask.com/qzone/1440083241/","title":"关于未来——致亲爱的兄弟姐妹们"},{"content":"天朝上国，有一奇人，世人称之为煮任。笔者思其十数年尚且单身，然众女不知如何下手，故写此攻略以飨读者。\n1.可先加其QQ，从头翻看说说，我们可以知道煮任一路走过来的心路历程(煮任也曾经自书一篇注解日志，可作参考)，对煮任进行了解，鉴于说说数量较多，可与下文方法穿插进行。\n2.进行初步接触，可通过观看相册与说说（据笔者所知，煮任的全部相册皆没有设置密码，且所有人可见），对精妙处进行点赞操作并进一步了解煮任的内心。\n3.进行互动，可对煮任空间进行留言，大概率可获得回复，对说说内容也可进行评论，若合一契，则对下一步有巨大好处。\n4.此步较为关键，进行到这一步，煮任理应将对我们产生好感，于是我们便可以在QQ上发聊天消息。笔者认为煮任若在工作之外的时间，定会极快给予回复的。在这，笔者就不得不提到煮任的生活规律了，一般煮任在电脑前时的活动可分为工作（制作、构思、学习……）、游戏（单机、小游戏、网游……）、空闲（观视频、看文章、聊天……）。此三类回复率依次增加（意外情况除外），事实上，我们进行前期的铺垫也是为了让煮任在游戏中也能认为值得打开QQ去进行回复。至于聊天内容，也几乎可以尽情发挥，推荐聊聊理想，尽量不要谈及学习成绩，煮任有阴影。经笔者调查，善于倾听的人，煮任对其好感度可呈直线上升。\n5.这步往后，便大多取决于上一步聊天所能取得的成果。此因人而异，笔者便不进行赘述，如果进行顺利，我们与煮任必定已是极好的朋友，甚至有一定概率可引起煮任的反向追求。\n到这里，我们便要慎重的思考自己的最终目的是什么。本篇攻略将假定为最高级——把煮任推倒，故有其它考虑的同学，可以视自身情况，作为参考。\n6.笔者认为，此步重在“理解”二字，我们要去摸索煮任的内心。笔者在此提供几点，可作为大家的突破口。\n①外表。在此我们便又要回到前文中观赏相册一步，我们可以发现煮任的形象是经历过一些质的变化的。总结下来，十岁自身煮任的日志里我们是发现不了忧郁的成分的；后来在十五岁之前，我们便可以看到煮任的眼神里多了一分成熟，但外貌还基本保持十岁的状态；再往后，我们便可以看到一个大的跨越，由之前的小于实际年龄到了超越实际年龄。据采访，笔者得知，这是由于煮任在这一时期遭遇到了身体与心理的巨大变革。煮任认为年龄小便有众多事情无法处理，于是强行提升心理年龄，结果遭到反噬而身心憔悴。所以，我们便必须理解煮任在现实中的形象，这是煮任能因我们而改变的前提。注：头发问题是绝对的禁忌，在此点上煮任认为有一票否决权。笔者当初也曾经被煮任当时的状态吓到，事后感到煮任确实在此处心理是有些变态了。但我们却也能理解他，让煮任这种性格从小到大在那种环境下成长，心理没有问题才怪。好在如若不提及此事，煮任为人还是较为正常的。\n②电脑。笔者认为要想真正的走近煮任，我们对电脑的态度纵使不着迷也定不可有排斥。前文讲到煮任工作时是不会轻易回复消息的也可见一斑，据笔者所知，煮任工作时一般会关闭大多数运行的程序，而QQ一般也会进行去图标与锁定处理。这也是笔者回推荐与煮任谈理想的原因所在，煮任的自尊心与荣耀感是很重的，若是轻视则必定会被记恨一辈子。笔者调查所知，煮任异常记仇，只不过很少见他有过爆发，但想要彻底弥补也是难上加难。煮任曾和笔者聊过，表示他心目中最幸福的便是能有人在他辛苦过后有个赞扬和鼓励。\n③略……笔者实在是想不明白都做成这样了，煮任还有什么理由不被拿下。当然，实际操作过程中可能因人而异，还是需要大家见机行事。\n7.破心魔。\n祝愿大家早日成功，笔者也会感到欣慰，看完要留言哦~\n","date":"2015-05-10T16:34:57Z","permalink":"https://boiltask.com/qzone/1431275688/","title":"〖教学向〗论如何从网络入手追求煮任"},{"content":"一缘手中牵 青丝断一半\n一缘梦里念 方刀头上悬\n一缘寻不见 孤冢欠一点\n源自心意坚 却怎肯并非今生缘\n现于梦境前 却怎断虚幻红尘线\n恰如白藕折断游丝亦连\n恰如细雨流过水痕未干\n苍天尚怜 错断今生缘\n江河空叹 何处归洋海\n","date":"2015-04-09T15:04:51Z","permalink":"https://boiltask.com/qzone/1428591846/","title":"今生•缘"},{"content":"君可见 夏日寒\n曾经繁星今日孤月悬\n黑夜黄灯白纸黑线\n君可闻 夏日寒\n曾经嘈嘈今日独切切\n一室一人一笔一页\n君可嗅 夏日寒\n曾经清莲今日为牡丹\n凝视闭目颔首哀叹\n君可知 夏日寒\n曾经锦绣今日谁人穿\n一念一年两年三年\n我听闻\n红稣手 晓风干 泪痕残\n我听闻\n黄藤酒 角声寒 夜阑珊\n君曾道\n往昔笑容填心窝\n我却知\n明日嘴角恐下落\n君曾道\n无人街上快乐做自己最好\n我却知\n喧嚣世间怎能避他人目光\n君曾道\n犹记一起玩耍的地方\n我却知\n堪怜共同面对的高墙\n夏日寒\n又想起冬风吹扬\n冬风烈\n却如春花在旁\n春花美\n希冀伊人模样\n伊人入秋\n果香又充满忧伤\n夏日寒 意弥漫\n再望明月高悬 共婵娟\n——2015#04#08/09\n为什么是夏日……嗯……我猜的……\n","date":"2015-04-08T17:09:26Z","permalink":"https://boiltask.com/qzone/1428512997/","title":"夏日•寒"},{"content":"\r有那一花一草一叶\r让人印象深刻的，往往不是大树耸立，而恰恰是那不起眼的一花一草一叶。\n——题记\r早春的天气还带着几分清寒，阴冷的空气还弥漫着冬日的气息，使人呼吸间不禁暗暗发颤。悠久的小城中一座庄严的学校，笼罩在一片紧张忙碌的氛围之下。有一群学生在班里奋笔疾书，亦或是在那食堂道路上奔走的身影与窗前门外大声朗诵的声音，也唯有高三可以是一群青春的少年少女压在学习之中，而我便也是其中默默无闻的一员。\n社会却是残酷的，纵使每个人都竭尽全力，也终有那排行榜上的状元与榜尾。高考临近，成绩较差的想要提高，成绩较好的想要更好，于是便陷入了那通向重点名校的高考独木桥。我是平凡的，做不到从小到大的一如既往，也不会呆坐发愣的虚度光阴，于是结局或许只能是与名校无缘，那么我的梦想何在？\n难得一个高三的假期，妈妈不愿我闷闷不乐地在家中，便打发我到外面走走。那便走吧！人生或许只能这样了。因为没有目的，便只是在一处偏僻的小路上漫步。\n寒风吹过，忍不住把身子缩了缩，不禁皱了邹眉。放眼望去，两旁树木枝头尚且枯萎，一片灰色，与白茫茫的天空相衬，我的心大概也是如此。而这时，有一抹鲜艳进入我的目光之中。那是不远处的一块草地，如今只有零星几簇小草与几朵不知名的小花。在寒风之中，小草微动，小花似也发抖几片叶子有些蜷缩。这一花一草一叶带给了这白茫茫的世界一处不一样的精彩，他们在发抖，但他们在寒风之中也勇敢地站了出来，我不禁痴了。\n一花，虽无高大伟岸，却能暗香流传。\n一草，虽无色彩斑斓，却能生机盎然。\n一叶，虽无名声彰显，却能结伴向前。\n我仍在风中漫步，脑海里却忘不掉了那一花一草一叶，这便是细微之处的美吗？ “创造新陆地的，不是那滚滚的波浪，却是他底下细小的泥沙。”是的，小人物也有他们的价值，纵使不能成为最闪耀的那颗明星，我也能令自己展现出独特的魅力。\n一花一世界，一叶一菩提。高考又怎样呢？确是应当拼搏，却无需故作病态忧郁，我有梦仙便定当远航！\n春风依旧，在那细微之处，仍有一花一草一叶……\n（此文后记正在编辑中……）\n","date":"2015-02-05T13:28:49Z","permalink":"https://boiltask.com/qzone/1423142922/","title":"一篇43分的作文"},{"content":"　我认为标题可以翻译为:This is the true senior high!唉呀没办法,这两日习惯性地研究英语,看见一句话就想译译\n这两天学案什么的写的很爽，全部搞定的那种，所以说，这才是高中啊！高一时就这样来，何至于此啊！唉呀~把高二当高一过，想着哥高二时就高考了，我骄傲！\n开学两天了,决定来说一说新的学期,话说为什么选择今天呢理由很简单,两天来能把很多问题都摸清了所以说这种东西老师不要求我也会写一写啦,习惯了嘛~\n首先说班长问题,啊！终于让我逮到了一个愿意当班长并且很胜任的男孩！两天下来感觉不错大概也就是我心目中理想的状态了:该说时说该笑时笑,该逗时逗该严时严,该谦时谦该管时管也是所谓“整体比较圆润”那种,挺帅的一个小伙子啊！嗯,其他几个班委也不错,这个学期应该不会因为这种事情不爽了！\n但是我重点要说的班主任,非常满意,这个评价很高了,很好很好,是属于那种挺让人服气的，至少我服了，下面我来说说为什么。\n25号,也就是交钱那天,上午时候班主任同志就找了几个同学把教室收拾了一下,然后晚自习时对班级的环境印象就很好（当然,鉴于我已经在此地待了一学期了，所以对我影响不大）。其实这倒没什么，很多老师都会这样搞，所以这点倒是加分不大。\n晚自习来到，见到了班主任，不得不说，鉴于其是体育老师，人站在那里就是有一种严肃的样子……另外，让我欣慰的一点是……班主任是个男性！不是我重男轻女，更不是大男子主义，只不过我一直认为，这种活本来就应该男人来干嘛！\n于是照例是讲话，为我们讲了两个词语四个字：认真、学会，说的很好，当然，还有一些“光荣的历史”。而后让我们每人写了一张纸条，既擅长什么（“说话也算，我倒要看看你到底多能说”）、理想中的班级、能为班级做什么，之后每人一分钟的自我介绍。\n所以说班主任很聪明的，几个安排就巧妙的解决了很多事：让同学们不要轻视体育老师做班主任，而后了解同学们的介绍，听听同学们对老师的意见，最重要的，通过台上的自我介绍，也知道了哪些同学适合当班长来领导同学们。Good job！\n第二天一早就到了教室，至少我到时班主任就在了，定下了时间方面的“早上比学校要求的提前五分钟”“中午和学校保持一致”“晚上也累了，比学校的时间再推迟五分钟进班”。中午吃饭时要求12:40，于是30就到班里等着，最后昨天有十多个迟到的，于是进行惩罚阶段。\n时间一到，迟到的同学站在外面，等所有人到了，进来把名字写在黑板上，并说说迟到的原因，照做了，虽然我看出很多不情愿。值得一提的是，一些抱怨性的话班主任并没计较，没说什么，说完就回座位，其实这点很好，你不说也就争不起来！而后班主任统计，今天有××位同学迟到，其中×个说时间太短,×个说去买东西,×个说吃饭本身出现的问题（我记得有位同学是这么说的：我无能，没插队，所以晚了……）……是的，班主任自己统计了，记忆是种能力吗？不！记忆是种态度，它证明了班主任确实在听！这很重要！他让人感觉到自己承认错误不是好像放屁一样没人在乎！\n于是，今天中午没有一个人迟到！\n当然，很多细节问题就不说了，许多许多塑造了这么一个形象，比如今天说班主任自己的手机号时，自称手机号是四万零七（尾号40007）。对了，这两天班主任没说不拿手机的问题，这才应该是正常嘛！难道因为班主任的一句话就把手机摔了不要啦?该带还是会带的嘛！高二了！倒不如不说了，至少，这两天我没有发现上课玩手机的。\n今天晚自习时班主任同志还带着我们回忆了一下今天讲得内容，虽然就五六分钟，但不得不说班主任挺有方法的，给个优秀啦！\n曾经接触了很多反例，现在给我了一个范例，感觉不错，剩下的就看我的啦！（知道为何不怎么提我如何如何不？我了个去，反正说也没意义看表现吧）\n正如现在学会了为读者着想的分段搞格式，人总是会进步的嘛！\n对了，你也要加油哦，不用找了，你就是在看这篇日志的人，希望你是能全部看完的吧~嘿嘿！\nCome on！\n","date":"2013-08-27T16:02:29Z","permalink":"https://boiltask.com/qzone/1377619350/","title":"这才是真正的高中！"},{"content":"\r《陨星记之江流传》-引子\r如果让后世的史学家看到这个本子里的内容，那么就算再严肃的老学究也会忍俊不禁。\n这个本子就是当时“二江”中的“北一江”幼年时期的物品，它记录了一些不为人知的故事……\n让我们先看一看这个本子中究竟写了什么吧！\n（此文照原文同步录入，尽力不进行任何修改，如有解说必要在括号中注明）\n一、光明军团\n从前，宇宙中有许多星球，其中有颗美丽的星球，叫地球。地球上的人幸福地生活着。地球上还有一只维护和平的队伍，叫光明军团，他们保卫着地球不受侵略。\n除此，宇宙中还有邪恶势力，叫黑暗军团，他们常常入侵别的星球(此处原为国家，后被划掉),但经常被光明军团阻拦。\n光明军团的光明司令有三个儿子，大儿子随父亲一起保护地球，另外两个儿子到外星球去修行。（这里与上一段有一个交换符号，小作者的意思大概是想要先把光明军团的事讲清楚，然后再说黑暗军团吧，调整的可以）\n黑暗司令也有一个儿子，他法力高强，武功也很好，几乎快超过了父亲。\n黑暗司令想击溃光明军团(原来错写成了黑暗军团)，一次，他带领黑暗军团中的大多数人，想一举击垮光明军团。光明军团的战士奋勇反击，渐渐取了上风。黑暗司令吸取了部下的力量，准备用力量把地球毁灭。\n光明司令为防止这一切的发生，与战士们合体，与黑暗司令同归于尽。\n光明司令临死前，对他的大儿子说，让他重建光明军团，接下保卫地球的重任，大儿子忍泪答应。把兄弟招来，告诉他（应该是他们）这个消息，他们安葬了英烈们后，去寻找人才。\n于此同时，黑暗司令的儿子也接任将军，准备报仇。\n（全章的“司令”这一职位，原为“将军”，应该是小作者为了区别人物而所做的修改，用心良苦啊！）\n二、重建军团\n现在，大儿子成为了光明将军，二儿子和三儿子分别为二将军、三将军。望着军团的废墟，光明将军决心要完成父亲的遗愿，重建一个更强大的光明军团。\n三兄弟决心（应该是决定）先在地球上走走，找到能助他们重建军团的人才。\n正走着，突然他们听到一阵警车声，他们随车走到一家银行，原来是一次抢劫，劫匪劫持人质，光明将军正要去救，突然有一个人影出现，劫匪随之倒地身亡。他们跟着这个人影走到一片空地时，人影停下来说：“你们是什么人，为什么跟着我？”光明将军说：“我是光明军团光明司令的儿子。”随之又把军团的结果说了一遍，“我看你刚刚身手不凡，请问尊姓大名。”“我叫××，是从游戏星球（原来写成游戏王国）来的，原来你们是光明军团的人。我小时就被带到了地球，可以放射出实体化的战士为我战斗。”“我们希望你能加入我们，助我们重建军团，共同维护正义。”“可以，我愿帮你们一臂之力。”\n他们找到了第一位战士，又在游戏王子的帮助下取得了基地，之后又收了十四位有不同本领的战士。光明将军还用石头、木头等物品变出了许多士兵。光明军团已初具规模。\n三、首次交战\n……\n是的，这就是这篇“光明军团与黑暗军团”的故事的开头部分，我想很多人看过之后都会莞尔而笑。其实我当初看的时候也是情不自禁，那稚嫩的笔法、那单纯的想象、那维护正义的使命感，这些品质在复杂的社会中是难能可贵的。\n那时候，小作者只有十岁的“芳龄”。\n据记载，在土也星的文学辉煌的时期，有“一军一巫一冥王，一剑一仙携二江”七位有名的作家，而我们现在重点讲述的人物，就是那“二江”中的“江流儿”，我想他的人生，也足以成书……\n","date":"2013-08-23T01:43:06Z","permalink":"https://boiltask.com/qzone/1377222200/","title":"《陨星记之江流传》-引子"},{"content":"\r《陨星记之江流传》-自序\r事实上直到目前为止，这可能是由煮任我执笔最多的部分了，追其原因，是我发自内心的尊敬与仰慕。\n《陨星记之江流传》，这就是我为这一部分所做的题目，没错，这也是出自上官龙的记录，但是我又进行了再加工和整理。“江流传”作为一本传记，它记录的人物自然是“江流”了，“江流”是一个人，是一个值得敬佩的人。\n“江流”其实是一个笔名，准确的写法是“江流儿”，当年的我第一次认识他，是在我从《陨星记》中找到的一本名为《笔魂》的书，我很喜欢作者的思维方式和其表达的思想内涵，更感慨作者的知识之广阔。是的，这本书的作者就是“江流儿”。\n之后的时间中，我又接触到了很多江流儿的作品，我越发的喜欢上了这个人，结合上官龙给的江流儿的生平履历，我也清楚的认识到，我是应该把江流儿介绍给大家的，更要把他的作品推广给更多读者，这也是我编此书的目的。\n我一向很讨厌写序言，因为我确实不知道怎么写，至少现在是这样，所以说……就这样吧，大家多看书中的内容，序言什么的，不用太多。\n——煮任\n","date":"2013-08-23T01:42:22Z","permalink":"https://boiltask.com/qzone/1377222151/","title":"《陨星记之江流传》-自序"},{"content":"\r电脑坏了就要修——一篇由七个故事串起来的小说\r第一个故事：作家最讨厌的事\r事情发生在那天……\n星期六，因为高中的学习压力颇大，一个星期只有这星期六短短的几个小时的短暂休息，次日便还要踏上去学校的道路，我到五点多时才赶回了家。回到家中，才发现家中竟是空无一人，不免有些疑惑，却倒也没有什么太大的反应，毕竟也不是牙牙学语的孩童，我不需要大人的看护也能过活。\n身为一个兼职作家，记得那次我一整天都在苦苦思索着怎么才能拿出一份令自己满意的作品。终于，暮色逐渐降下，我的思路也渐渐的一抹一抹的浮现出来，终于，伴随着夜的来临，一个完整的框架体系建设完成。于是，我自然的看了一下时间……\n虽然都已经晚上九点了，但灵感这件事也没办法，说不准哪天才能出现，我一定要趁着这个时候把它写出来！但我的爸爸今天怎么还没回来呢？\n不管那么多了，我打开电脑，静静的等待着，一抹蔚蓝浮现在我的眼前，在欢迎页面之后，我运行了记事本。\n忙碌，在键盘的敲打里，在跳舞的指尖中，我看着面前一个个黑色的精灵浮现出来，看到那密密麻麻的小家伙，我心中也感到了一丝的欣慰。准备收工！我又看了一下时间……\n十点了，我也感到了一丝的倦意，在这时，门外楼梯上传来了一阵有些蹒跚的脚步声。眨眼间，伴随着脚步声在门外歇息，砸门声也是接踵而至，同时还伴随着一串带着醉意的秽语。不用说，是我那老爸回来了，我只得暂时放下手头上的活去开门。\n打开门，我看那老爸满含酒意的身体，无奈道：“你这是又去哪里喝酒了啊？”\n不理会我，我爸踉跄着走向放着电脑的房间，看见亮着屏幕，大怒：“你到这时候还不睡觉，想干什么，整天就知道守住电脑玩游戏！”于是，竟然想去拔那电源的插头。\n我见到这情况，不由大惊失色，我的文件还没有保存！然而，终究还是慢了一步，看着那瞬间黑下的屏幕，一抹凄凉充斥着我的身体，同时携带着的，是我那怒气。\n“你干什么！”我声嘶力竭的吼叫道，同时固执地去插上插头，按下的启动按钮。\n也似是恼羞成怒，我爸也展现出了滔天的怒火，飞奔过来再一次的把插头拔掉，狠狠地打了我一巴掌，“滚！”，叫道。\n我一气之下，却又想起后悔已晚，只能忿忿地奔向我的床上蒙头痛哭。\n作家最讨厌的事，莫过于自己好不容易拿出的作品，却因为自己的失误麻痹与大意而毁于一旦，朋友们，这是多么令人痛心啊！ 第二个故事：灵感来时囿于胸\r转眼间，又是一个星期来临。\n今天是星期五，今天我在学校漫步之时，突然感到一丝的惊异，一抹灵气也就汇涌而来，很显然，这又是灵感来时的征兆。而心中又想起今日是某大网站的征稿活动截止日，这个活动我是关注的好久的，十五日的活动日期，我本想早早参与，却又每次都因为种种原因而未能如愿。“这下可好了。”心中不免有些窃喜，回家把稿子一投，如若幸能成就，今后的仕途可谓是坦坦荡荡坦坦啊。\n上完晚自习，我回到家中，心中也感叹幸好我是走读生，每天可以回家，那些住宿生能有这好的条件，大夏天烤得什么样子。到家已是近十点，但无奈今日是活动最后一天，也只能快步前去打开电脑，在等待开机的时间里，我回客厅喝了杯水，“这夏天。”叹道，然后与爸妈简单聊了几句。\n回到电脑前，我却惊愕的发现，这电脑并未成功的启动，而是显示出来一句英文，大概就是引导文件丢失之类的，我当即目瞪口呆，怎么回事！\n向妈妈询问，回答我说：“这电脑都坏了快一个星期了吧，你爸都调了好几次都不行。”顿时，一抹绝望的感觉涌现在我心头，怎么办？我的人生呢？说好的仕途呢？\n灵感来的时候，无处释放，光憋在心里的感觉可真心不好受啊！ 第三个故事：两元钱难倒英雄汉\r电脑坏了就要想办法修啊，很自然的，我自认对电子计算机还是有些本事的，所以，我拿来我妈妈交话费送的智能手机搜索起有关信息来。\n不得不感叹当今互联网的高速发展，也同时必须赞扬那些无名的热心网友，很快群众们纷纷支招。\n上至“重新去买台电脑吧”，下至“你按‘这个’‘那个’还有‘这个’”，我从这如海的信息中倒是提取出来一项看起来颇为不错的——“用其他方式启动电脑，别从硬盘启动”。我在详细一搜，这“用其他方式启动电脑”一般的建议都是说，“放入买电脑时带的装机光盘，在主板页面设置好”。\n于是一阵翻箱倒柜，光盘倒是找到了不少，我看到这些圆形的碟片，凌烈的的反射出璀璨的光芒。虽然有些晃眼，但这些光在我眼中却犹如珍珠般夺目。\n按下光驱的开启键，却在一颤一颤中没有反应。“咦？”有是一丝疑惑，但很快就消散了，“切，这还难不倒我！”，我去寻了一支牙签，细心修了修，然后插在了光驱按钮下方的一个细小的洞里。“呲……”光驱缓缓打开，我满怀期待的把光盘放了进去。\n尝试，尝试，却是连一张有用的都没有，不免心中有些气馁。再次，细细品味网友的指导，心中的期望却还没有放弃。\n终于，网友的一个关键词落入了我的眼中，“装机光盘”，这东西，大家都是说随机附赠，供以后调试机器的。但……我怎么没有啊！坑爹呢！万恶的电脑店，一张光盘都舍不得给我啊！\n虽说网上说这东西在地摊上也就值两块钱，事实上，我认为连两块钱都不要。但是！你给我去找个地摊啊，在这个美丽的国家，地摊是不合法的，是要被城管追的满城打的！但那万恶的盗版商呢？没见几个被抓去坐牢！于是乎，现在卖光盘的地方也算是一个奇葩了。但这朵奇葩还没有绽放在我这居住的小城，然后，两元钱难倒英雄汉啊！ 第四个故事：有钞票都没处使\r没办法，事情只得作罢，我呆坐在沙发上，一夜无语。\n次日还是要去学校，重复那没什么意义的生活。但我心中却也做好了打算，今天星期六了，记的我家楼下有一店维修电脑，放学去找人修一修吧。想到这，我心中却也坦然了。\n时间流逝，一天的学习已经结束，我踏出校门，登上那拥挤的公交车，又换乘了两腿间的十一路行了数千米，终于是快到家了。\n但沿着马路走啊走，我却诧异的觉察出了一种别扭——啊！原先的电脑维修哪去了！\n这下惨了，但却也不能在马路上做什么，只能回家“以头抢地而”，虽然家里没有人也不能拦着我。\n唉，这年头，修电脑的看来也不好混哪，但我这也悲剧啊！钞票不是很厉害吗，但有钞票没处使的感觉真别扭。 第五个故事：条条大路通罗马\r别人不能帮助自己了，但我能放弃吗？不能啊！\n但终究是要怎么办呢？个人在绝对的压力面前又能做什么呢？这不是小说！\n不过脑海中却猛然想起“用其他方式启动电脑，别从硬盘启动”，“用其他方式启动电脑”，“其他方式”是什么？顿时想到了一点，光盘储存数据，U盘也储存数据，那么U盘能不能用来启动电脑呢？心中摸了下口袋中的U盘，心中顿时再次掀起波澜。\n说干就干，把U盘插入调试好，期待万众瞩目的一刻吧！\n进度条一点一点跳动，字符串一行一行滚起，突然，一行熟悉的英文浮现在眼前，又失败了……\n不行吗？\n嗯……\n我不能放弃！\n看来只能去那个地方看看了，沿着靠马路的窗户望了望那边的一座建筑。\n“苗子佳缘”，进门，一股烟气扑面而来，忍着去柜台开机，调试了许久方打开，这破电脑，于是继续搜索解决办法。终于，有一条信息浮现在我的眼前，“制作U盘启动盘”。我点开，原来如此，如想用U盘启动电脑，还需进行一番制作，而这所需软件，仅一“老毛桃”尔。\n于是插入U盘，嗯？怎么没显示啊？哎？USB的插口怎么这么松弛啊！啊！坑爹啊！这电脑的USB口竟是坏的，亏了大门口还宣扬的顶级配置，于是换台电脑。不是吧，还是坏的？再换，坏，再换，还坏！啊！这……\n没办法，在人家的地盘也没法发火，只得默默寻找，最终，终于找到了一个紧绷些的插口，插入，OK！其它的倒也没什么说了。嘿嘿，不论如何，这U盘总算是弄好了，这下，总是可以了吧，只是可惜了U盘中的原有数据，格式化啊！\n第六个故事：遇挫折又怎怕\r飞奔到家中，虽然夜色已再次出现，但还是没有人在家。\n打开电脑，插入U盘，这下总该解决了吧！\n纳尼？又是那种情况，又是那句熟悉的英文，失败！\n怎么会？\n我心中感到一丝烦躁，正欲爆发时，猛然想起，哦，呵呵，忘了调设置了……\n于是设置好属性，看着那同样是英文却只是给人以希望的选项，准备开机吧！\n第七个故事：终于能开机了\r啊，经历了太多太多，众多的磨难也难以阻挡我前进的信念！\n啊！成功！欢迎界面，我来了！\n看着成功的开机，我笑了……\n失去的……\n感叹道：“这两天的经历也很有意味，让人颇有感触灵感迸发文思泉涌啊，很值得改编成小说！”\n又看了一下时间……\n虽然都已经晚上九点了，但灵感这件事也没办法，说不准哪天才能出现，我一定要趁着这个时候把它写出来！但我的爸爸今天怎么还没回来呢？\n","date":"2013-06-24T16:43:21Z","permalink":"https://boiltask.com/qzone/1372092226/","title":"电脑坏了就要修——一篇由七个故事串起来的小说"},{"content":"　今日的心情很糟糕，准确说是近日的心情很糟糕，再准确的是近日的心情糟糕透了。原因也不说了，懂的人自然会懂，虽然我仍认为没人能懂，或许有人是希望能满足一下好奇心的，可惜，我做不到。\n本来照我上次说说中说，这些想说的话是不会发到这个号上的，但……我大概还是想能为未来可能的观众们留下一个完美的形象吧——一个虽落魄却永不言弃的形象。可惜，这个形象是“煮任”的，我不是，我只是欧阳天——一个自封的演员。\n煮任与我之间的微妙关系，煮任这个角色也很无奈，但他也有能陪解忧之人，有心机有抱负。我突然又迷茫了，我是谁呢？煮任是以我自身为原型塑造的，一定程度上我希望他是个完美的角色，在困难时能有人拉他一把，在不爽时能有人听他的倾吐，在迷茫时，能有人指点迷津引出方向，但……是的，我还没有能力去表现这些，是的，我也希望我能享受这些殊荣，但……我不敢想，这是奢望。\n记得别人说我变得很沧桑，不是吗？我的生理年龄和心理年龄已经越来越悬殊，为什么呢？现实。可是，谁不渴望无忧无虑呢！我也想自由自在，不去想未来发展，但是，我能吗？\n我现在的性格大概很微妙，这也是这十余年的产物，来这世间十五年有余，我经历的太多太多，上至榜上首位下至倒数有名，上至清华之苗下至高考无望，上至师之骄傲下至父之忧伤，上至人皆乐道下至无一知音，上至红袖作伴下至挊然心碎，上至富裕常足下至穷困艰苦，上至无虑黄白下至节丝省毫……\n最让人蜕变的，就是现实的差异，这些恐怕还与脑后的银丝有关，是的，虽然这不是我的错。小时候，因为这个与人不同，我排斥出门，放弃与伙伴玩耍的机会，然后被父母扣上一个内向的帽子，逢人即说，此子哪都好，就是太老实。内向就内向，老实就老实吧，我没有和父母抱怨过这个事，一次也没有，也自然没有说不爱出门的原因，一次也没有，直到如今。\n记得曾经我出门时总是走在熟悉的人之前，避免视人，虽然不会有什么实际意义，但对一个十一二的少年，大概也只能做到如此了。秋衣处长等人曾笑，与我并排走时我总爱耍S型路线跑到别人前面，这大抵也就是那时养成的习惯。以至于我不喜欢背后有人，直到今天也如此，这恐怕也是我钟爱最后一排的理由，坐第一排时浑身无法动弹，非常不自在，虽然……我不说，谁能想到？继而自然的就会自卑，恐怕当时，包括现在，对一些事情怯手怯脚，能三年都鼓不起勇气说一句话，这个原因，直接占一大半，间接占去另一半。\n不过现在倒也不太在意了，为什么呢？不知道，只是知道我不能去介意，于是只能不去想这件事情。现在你大概能理解我为何从小到大对发型一直就没什么要求了。发型？有这个资本吗？\n等等等等，虽然可能没谁能知道。写到这里，突然想到，不说一句一句，如果你能一段一段看到这里，我觉得也是很不错的了，谢谢，我现在也只能这么说了。\n不知道能有几人啊！随着对社会认知的加深，对新世纪的看待，对一些不纯洁的感慨，渐渐的，我似乎已经越来越排斥他人，包括……用一句网络语就是，我再也不相信爱情了！\n刚刚拿我妈妈的手机发这篇日志时，心中想的是非常多的，正如刚开始打的日志的标题，但写了这么多，也过了一个多小时，渐渐的倒也释然了，这也就是这篇日志的意义吧，不过……还是把之前想到的发完吧。\n能用文字抒发心中的情感，我无疑是幸运的，正如今天语文学案所检讨的《说明书》中写到的“……因为爱语文，我可以把检讨书写成内心的倾吐；因为爱语文，我可以写数千文字而不觉懈怠……”，为什么要提到今天的事呢，你也懂得。\n我从来不会因为学习上的事而过感心伤，至少现在是这样的，今天的直接原因，还是近段时间老提到的——钱呐。\n我其实一直想要通过自己的双手来获得自己想要的东西，毕竟，都也不小了。但……贫富的差距是我一双手能填补的？\n现在经常听见有同学抱怨社会，但说实话，其中有几个切身体会的？唉……如何能不老？\n一千多块钱，拿出去比上不足比下有余，处处今天笑说，你这省吃简用一个月省出来的钱恐怕还没有一些同学一个星期的零花钱多。唉，当时我是笑的，但其实当时我心中真的很想哭。\n有人拿父母的钱去泡女孩把妹子，而我能这么干吗？一千多，玫瑰买不了999，买99还富裕很多吧。然而……\n咿嘘唏，命运呐，命运。\n大概也是如此了，呵呵，有好多话打着打着就忘了，想不起来现在憋着也难受，唉，睡吧，忘了一切，以后有幸忆起再来补充。\n——欧阳天201306142200~ 201306150037\n","date":"2013-06-14T16:37:45Z","permalink":"https://boiltask.com/qzone/1371227841/","title":"活不下去了（又名：所感所悟）"},{"content":"外面阳光明媚\n我在写\n外面雷雨交加\n我在写\n回到家中\n我在写\n打开电脑\n我渴望不再写\n之后却要更大量的写\n我在写\n为了以后不写\n","date":"2013-05-31T14:05:58Z","permalink":"https://boiltask.com/qzone/1370009110/","title":"写"},{"content":"剧本—“成王败寇”专辑作品编号：BT首部\n开头动画：雨中BTS\n场景布置：门前、阴暗色调屋内\n人物：\n神秘人（煮任）～配音～煮任\n神秘士（家族）～配音～煮任（变调）\n雨中BTS→标题→门前→暗屋内→字幕→宣言\n（门前，摄像头第一人称，神秘人内心忐忑，一双小手在门前蠕动，紧张不安焦虑）\n（门锁响动）\n（开门，神秘人进，摄像头变焦效果\u0026lt;第一人称\u0026gt;，神秘士模糊人影）\n神秘人：你来了？哼（冷笑），你还好意思来，现在倒是想起我。当初呢？你不是挺厉害的吗？现在怎么也落到如此地步了？你来了也有十多年了吧，自觉醒之日算也有一段日子了，怎么？失败了？堂堂的Allah也会失败？当年不挺呵呵的吗？沦落至今，你能有什么作为？你看看你自己，再看看你来时还默默无闻的那些人！一个土木工程师，改行当导演拍广告赚钱去了\n一位由知名大学培养的大学生拿起耳麦分享小游戏了\n一个纯纯的小青年，把自己脸整变形当喷子骂网游去了\n一个挺帅的哥们非不愿意露脸而学某人开起网络课堂脱口秀了\n又有一个愿意露脸的整天开着软件让别人看他怎么打枪\n还有一个玩游戏不过瘾于是给大家分析里面的深层哲理去了\n就是连一个养鸡的现在也过的比你强啊\n你看看你自己，十几年了，一无所有，孑然一身，生活还挺拮据，哦，那次还搞了次“归来”是吧，哈哈，结果呢？嗯？三年之约？给你三十年又怎样呢？还不是什么都没有？啊？\n煮任？嘿嘿，志气倒还不小\n你以为改个名字就能成事了？\n该失去的总会失去！\n多少时间了，到你这一代，我看也是没希望了……\n（渐黑）\n（片尾字幕\u0026lt;BTS出品\u0026gt;背景音雨声）\n神秘士（煮任）：我一定会成功的！\n（未完待续……）黑屏带字幕）正所谓：神秘人会见神秘士 不羁者发下不羁誓（方言）\n屏幕中央：本系列其它作品请关注ID 煮任BoilTask\n","date":"2013-05-08T15:50:02Z","permalink":"https://boiltask.com/qzone/1368028232/","title":"＜BTS＞第1集-神秘人会见神秘士"},{"content":"舞台布置：夜晚一条幽暗的小巷\n人物：某男、群女\n道具：手机一部\n（夜晚的道路上驶来一辆大巴车，在街道某处停下，一男缓缓下车）\n某男：（对手机）喂？\n一女：哎……（被嘈杂声打断）\n某男：干嘛呢？\n女：（群女嘈杂声）刚到……\n男：我刚下车……（欲继续说电话传来另一女的声音）\n其女：你是谁？\n男：呃…我是……（被嘈杂声打断）煮…（传来断断续续一群女生的声音）\n其女：你干什么？\n男：我……（再次被打断，脸上露出不满色）\n（手机里继续传来嘈杂的女声，男头上一群乌鸦飞过）\n女（第一个）：你先挂吧，待会再说。（并伴随着嘈杂声）\n男：这个……这个……这个！\n（脸上表情由尴尬转为激愤）\n男：你们欺负我！啊！变身！超级塞亚人！不要小瞧我们卡卡罗特的后代！\n（全身斗气高涨，头发伸长变为金黄色，一蹬脚飞翔东北方）\n……………………………………………………\n某男：欺负我不能变身嘛！\n","date":"2013-05-03T14:36:26Z","permalink":"https://boiltask.com/qzone/1367591764/","title":"剧本《无语》"},{"content":"（前段时间写的一篇检讨文学，放假又翻出来了，发上给大家解闷吧）\n～～～～～～～～～～～～～～～～～～～～～～～～～～～～\n序\n一日，余与H行足于食堂，食毕，欲返……\n忽感灵光一现，仙气游丝于校园间……\n故与H行至校园小道，作此篇。\n且说那日中午，照常例，我与H、潜、秋共四人同往食堂而去。途中，秋告知我们，他于某日见数生于校园西南角池塘，手持石块以害鱼。我等四人闻之，不由感叹当今某生之素质。\n常言道：物皆有灵。\n又语云：愤泄于畜愤绕身，怒迁于人怒焚心。\n进而谈及其缘由。\n秋言，这帮小子看来是对学校有点意见嘞。\n潜答，所谓学校，既你自己一天骂八遍，而又不许别人骂的地方。大爱隐于无形哎，无形则踪，这些少年倒也不是不爱校啦，生活无聊而已。求学无望，其又有何事可做？人之初，性本善，没有谁天生就想行恶，出生就变成坏蛋的，也只有国产动画里能见到喽。\n四人笑。\nH道，国产动画，没啥说的，看以后煮能把国产动画救出来嘛。\n抬头，则食堂已到。\nH言，先去占个位啦。\n遂转身迈步走至东北，我与潜、秋紧跟之。端碗而走，不更摇晃，迈小步而前移，寻一桌以放。放下，H与我等四人则喜。\nH曰一言，任务完成。\n而问我三人可曾带纸，无所得而云，Shit！\n进而去寻所食之物，路过一长桌，凳上放四纸，盖同学放之以占座，H拿之擦手，四人狂笑。\n待食毕，行事终，与H去买笔纸，待购得，已寻不到潜秋之影，遂叹道，这二货恶劣！\n故只二人回班，放眼左瞟，见宿舍立于所处，巍巍然有耸立之影，与天上白云招相乎有飞意，盖云动而楼固也。\nH言，我们宿舍昨又停水了，这楼真是……好似大山压着人喘不过气。\n笑答曰，好歹人家也是山喽。\nH笑，芒山吧，不过……好吧，那也是山啦，话说人言地震常发生在山区，你说，我们这咋的不震一次嘞？\n坏笑道，地震了你就谁？\n先救那个离自己近的，括号，女生，男生救不救没关系啦。\n你不优先救那谁啊？\n我相信其能自己跑出来的！你嘞？\n我？嘿嘿，你懂的。\n转眼间，已穿篮场，过跑道，越操场，至于校园东方小道。\nH问，你说，我们学校搞些土干什么？\n答，我的某同学说：“坑挖好了，排好队，跳进去，填上土，完工。”正所谓，“挖个坑，埋点土，数个一二三四五，人民的土，人民的地，一切为了好成绩！”\n二人笑。\n至南门，H云，我们去看看犯罪现场吧。\n于是走至西南角，见一水管穿石砌小道伸于池中，管上连接处有一小口，不断滋出晶莹的水珠，把小道铺上了一层水帘。\nH言，这阵势快赶上水漫金山了，太客气了，来一趟不至于专门铺个毯子吧，很浪费水的哎。这倒是与食堂节约制度下的回收利用不相配啊！也难怪秋力顶食堂了，哎，对了，学校和食堂不是一个系统管的呀！\n于是快步穿过，H身上还溅了些许水花。\nShit！H骂。\n绕池而走，见几条小鱼游于池中，池水清澈而见底，却见淤泥垃圾堆于池底，与鱼水构成了一幅奇特的风景。\nH乐道，看来大鱼都被人砸死了哎，就这几条小鱼……很孤独啊！\n然后又弯眉眯眼而笑，你说人家都是一男一女来这转转，我们两男在此处，很别扭哎。\n屌丝没法啦！，所以每次在食堂和操场上就想玩连连看，看到一对的……啊！消掉！嘿嘿。\nH无奈状，转身弯腰以手打腿上泥土，又瞅了一眼身上的水渍。道曰，学校不是严禁早恋的嘛，其实要我说这也不算早啦，有喜欢的女孩也正常的啦。圣人云：“有挂念方有动力，有动力方能学习。”学校恐怕也懂这个道理，要不然，这随便一望就能看到的一对对，不也没有什么事嘛。\n这时，见远处角落一男一女做亲密状。方与H道，非礼勿视。\n消掉。\n然后转身向北方小道走，路过栏杆上一处，H见二塑料饭盒放于上面，遂用手指弹掉，曰，你看这女生太浪费了，这男的也不管管，正所谓：谁知盘中餐，粒粒皆辛苦啊！\n后继续前行，见一树上白花开放，乳白色的花中夹杂着淡黄色的花蕊，与旁边一棵枯死的小树行成鲜明的对此。\n这花，挺好啊，香气直扑脸颊。\nH道，还说的挺押韵的，我们学校从上空看也挺漂亮吧，可惜在教室里坐着完全感受不到呀。\n答之，这就是所谓的绿地绿化面积与室内绿化面积，加到一起叫绿化面积，我们学校的这个数据倒也挺大的。\n走到了楼内，方转至楼梯处，上二楼。道，你说这教室的楼层布层设计的，我们要把文科生踩在脚下！话说，文科也有加强班――20，人家也是加强班哎，享受不了楼层放于五层的爽快感嘞！\n这社会重理轻文的，一些事情从小的细节就可以看出！\nH笑，潜都说了，国家机器是一条火车，理科生是添煤的，而文科生是司机。\n嘿嘿，准确说是司机候补啦。潜倒是毫不犹豫选了文，可惜他的个字嘞！现在都算好点了，想当年那字真是没法看了，他老师不都说了吗？――你的字能对得起你的文采不！\n说话间，至二楼，我笑道，H，你向右转头了哦！\n笑，二人笑，嘿嘿的笑，呵呵的笑，沧海一声笑！\nH到班，推门而进。\n我也到班，推门而进。\n看了下时间。\n还好，时间还够……\n卍卐卍卐卍卐卍卐卍卐卍卐卍卐卍卐卍卐卍卐卍卐卍卐卍卐卍卐\n◎一游已终，感却良多\n静坐思之，似有所得\n正所谓：\n一文追灵记\n却把游校提\n无情录空谈\n中味谁能忆\nH乃谁？\n潜秋何人？\n本欲细谈\n然思所虑\n有缘再见\n附：\n原稿照片\n","date":"2013-04-28T13:33:06Z","permalink":"https://boiltask.com/qzone/1367156004/","title":"追灵记——游校小提"},{"content":"〖本章提纲：煮任之言引出话题，陨星落下被BT前辈看到，石巨大而不能挖出，次日被人们见到所无视，欲毁之，BT前辈奋力挽留，石感动而裂，露出其中精要部，BT族众人解之，煮任读所解之部分，又观其石，携石至地球，一边发书，一遍解石之迷〗此书非煮任之作也。\n煮任语云：列位看官，想来大家能有一阅此书的闲情雅致，已然让我感觉是莫大的荣幸，所以在正文开始之前，我想不妨先与各位谈一谈此书的前世今生！众所周知，在当代的文学海洋中，小说这一自明清就流行的文体借助网络这一平台，愈发的壮大。而作家这一物种就类似于不搞计划生育似的遍地开花，以至于他们中的许多有了一个新的称号――写手。当然，更多的连写手都算不上。写作的人也不再局限于那些高级知识分子，幼儿园毕业的、小学毕业的、初中毕业的、高中毕业的、想毕业又毕不了业的、不想毕业又偏要毕业的、打工的、扫地的、搓澡的、乞讨的，不管你是高富帅，还是矮穷挫，只要你愿意，都可以参加“写小说”这一活动——当然，最好还要有设备。\n于是乎，在网络漫漫书海中，可谓良莠不齐，鱼龙混杂。倘使未能发现精品，如若遇到一个尚有节操的人还好，假如遇上一千年老妖，那就真是菊花不保了！漫漫书海文字路，我寻你在灯火阑珊处。在概率学上，如果你是随性乱找，你看到此书的几率小于亿分之一，既随机事件中俗称的小概率事件。所以，我只想说：“缘分呐！”\n那么，现在你可能会问我开篇的“此书非煮任之作也”是何意思，这点我倒是可以解释一下。\n认识煮任的人知道，煮任的专业是视频，那么为何也要来小说界呢？\n一是煮任感觉对一些事物而言，表现力方面文字甚至可能还要超过画面。这一点可能是我之前无法理解的（对一个十几岁的身体大家要理解），直到我看了古典名著《红楼梦》一书才恍然大悟。我惊叹于中华汉语文化的博大精深，又沉醉在缕缕的墨香之中，于是我认为，文字同样是一种表现手法，虽然我还是倾向于视频，但文字也不可忽视，一些视频不好表现的，不妨用文字来说明，也挺好的，不是吗？　二来呢，还有一条重要原因。嘿嘿，你会认为以我的文学底蕴可能写出一部精妙的小说吗？其实吧，我手中有一本祖传的《陨星记》，那可是万分珍贵之物，经历过我家前辈层层批阅，现在放于我的手中。我认为以这本书弘扬“煮任世界观”倒也不是不可，所以我发布给大家一阅，也可解苦闷之感。\n这正是“此书非煮任之作也”的奥意！\n煮任与此书可谓颇有渊源，遥想当年未至此处之时，常有此书作伴，甚欢。其乃家中先辈高人所传，但又并非本家所著，然相传此书的由来，倒也是值得一番考究。\n据说前辈得此书时，并非所谓线装本，而是以一种数据的形式，其中所含内容甚为丰富，而记录的文字又甚为迷惑，以至虽吾家前辈竭其一生，尤不可全然了解，此文字并非以往我家中所知道的任何一种。\n吾亦尝终日而思矣！却说煮亦乃“愚顽怕读文章”之人，何故方能使其着迷？此中缘故，一是煮任当是时终日无所事事；二是煮任感此书虽晦涩难懂，但却有前辈的注释讲解，又不乏精彩之处，因此常以其为友。\n刚才说到，得此书时并非以墨书之，而其中经历，倒也值得一叙。以故先言此书出处，读者亦可了然不惑。\n此事源自煮任之乡，发生于某年伊始，想来定然也是极为久远。\n方该日，城中正值一年一度的“Boil”，自白天，正值天阴，而至夜时，光愈发昏暗。乌云交错遮星辰，光束照天不见月，而朦朦胧又有雨象，行人归宿，客家扯帘，天地重演寂静。\n忽然有一光漏层云而下，继而百光万光齐下，数万光束又似乎围绕着一圆球状物体，盖好似一陨石也，只光芒异也。\n此石破空而贯大地，划过天际，留下一道光痕。当是时，只闻一惊雷而起，电光苍穹，其石砸地面而轰，雷破空气而隆。一时撞击声，雷鸣声混杂，众生只感：轰隆隆。正所谓，石破而天惊，石落而天静，一惊世之石匿于雷声中，不为世俗之人察觉。然而煮任之乡岂无英杰乎？非也，故方有下文。\n城中有一梦周公者，与其相谈甚欢，忽感一阵嘈杂之声，一时扰了思绪，乱了言语，飘飘乎如入异世。进而翻身覆被，埋头于枕中，口中呓语，复寻周公。\n又有一君方望天而解忧，见一陨星突现，光彩犹如神迹，遂动容，叹道：此星好生奇怪。于是逐星而去。\n眺而见远方有些许虹光，故走进视之。这才是细见到陨星真容，后辈有诗词二首描绘其状，道：　◎曾是天迹繁辰，今归地边凡世。犹像神界仙石，却似人间遗掷。彩光欲冲云霄闭，乐音欲演心虑急。无奈入红尘，残余星辉欲掩匿。\n◎珍奇本胜琼露，宝玩亦赢商都。仿佛莹光碎篦，恰如明镜染污。愚人只识鸡狗彘，圣明言语皆作迟。感有泪光闪，嗟叹人生空悲泣。\n此石高经十米，宽则十丈，盖有余光闪耀，烨然若神物。遂叹道：噫！此石定然不是凡物，观今夜天象，倒也是有神兆，今得此石，星之幸，族之幸，众生之幸啊！哈哈哈哈哈！\n一时间，其人竟作痴狂状，用手掘石以搬之。呜呼！想如此之巨石，安能以一人之力移之？又过一时三刻，终瘫倒于石旁，口中喃喃自语，不省人事。\n方次日晨，日出西方，天大晴，阳光普及众生，万物又迎来了新一个黎明，晚归的工者尚正酣，早宿的儿民已出门。\n城已从夜里走出，街道又恢复了市景。忽有一人喊道：“你们！那是什么？快看！”于是众多看客蜂拥而至石下，众说纷纭。\n又见一人躺于石边，看客皆相视而望，疑此人乃谁。某人为一中年妇女叫嚷：“你们快别在这傻站着了，都来救人啊！”继而叫救护车于石前，医师护士之人抬其痴狂之人至医院，治其病，诊其症。\n","date":"2013-04-21T11:25:30Z","permalink":"https://boiltask.com/qzone/1366543520/","title":"《陨星记之星海梦》-第一章 忆前世煮任传奇录"},{"content":"楔子\n我是煮任\n现时在地球\n吾本飞龙\n昨刻住中州\n一个嗟呼今世\n一个梦忆前生\n若时空虚化\n泪作陨星\n身照天空\n安得喟叹钟声\n响彻苍穹\n――竹印\n〖本书大纲：煮任得奇石，童年上官龙，穿越到未来，经历新科技，开始游星海，他星遇知音……〗\n","date":"2013-04-19T21:47:24Z","permalink":"https://boiltask.com/qzone/1366408043/","title":"《陨星记》——发给真心愿意看得人"},{"content":" 写在前面：\n“煮任世界观”过于宏大，远非常人所能理解。我也是出于敬畏之心，才勉强可以梳理起一些关系网，现在先把我的研究总结一下，以方便后来人更好的去理解。――“我”\nMy Card\n艺名：煮任\n昵称：BoilTask\n笔名：竹印\n洋名：BambooSeal\n全称：Allah BoilTask\n邮箱：BoilTask@qq.com\n（签名、头像、全身照略）\n平凡之者\n四脚踏实地既当煮\n世俗之人\n一心胸宽广方为任\n我的观点，是人的一生只创作一个作品，因此我的视频也好，小说也好，每一个之间都有着联系。（保密需要，恐不能详细介绍）现小附各本小说之间的关系：\nBT传→\n陨星记之星海梦\n陨星记之黑龙星\n―星龙传说\n陨星记之\n—指尖跳舞\n陨星记之流涌星\n—风流水涌\n……\n视频？小说？\n――其实都一样！\n众所周知，煮任同志对视频其实是抱有浓厚的兴趣的，这是时代与性格使然。但是为何煮任忽然对小说起了兴趣了呢？答曰：被钩的。\n老湿把我钩上了视频创作之路，跳舞把我钩上了小说创作之路。此二人皆大神级，受众人所膜拜。\n但是！煮任说过，视频创作是一项值得奋斗终生的事业，如今绝不可喜心厌旧！所以，小说嘛，只是作为对煮任视频的补充，完善现阶段视频还难以表现的画面。\n因此，视频、小说，其实都一样，他们都是为完善“煮任世界观”所服务，最终得出一结论——视频、小说，其实都一样！\n同志们！期待吧！\n","date":"2013-04-19T21:40:14Z","permalink":"https://boiltask.com/qzone/1366407604/","title":"竹印之言——我的小说创作之路"},{"content":"◤　煮　◥　◤　鹭　◥\n↑　↓　↓　↑\n↑　■ ■ ↓　↓　→ → ↑\n↑　◇ ↓　↓　◇ ↑\n↑　□ ↓　↓　▽ ↑\n◣　◢　◣　◢\n◢　◣　◢　◣　↙　♂↘　↗　♀↖\n注：开始有标“※”的地方为视频尚未拍摄\n注：详细根据情况再行调整“MRTV煮任”时期\n第一次の尝试 煮任归来\n[煮任调味料]第1期\n[煮任厨房]第1期-小评猫版玛丽随机版\n[煮任调味料]第2期-猫版玛丽史上最强解读\n[煮任厨房]第2期-煮任猥琐讲说蠢爸爸叫兽小星\n[煮任菜谱]智慧球2\n[煮任菜谱]跳吧！愤怒的小鸟\n[煮任菜谱]史上最难小游戏\n[番外]喵喵の忧伤\n\u0026laquo;[煮任の三年之约]\u0026raquo;~ “煮任BoilTask”时期\n高一 ※【B·T·S】第1集-神秘人会见神秘士(不羁者发下不羁誓)\n※成王败寇之高考作文之后\n※成王败寇之若在中国\n※【B·T·S】第2集-曾败寇安拉难相守(欲成王煮任苦寻鹭)\n※成王败寇之学校不准玩手机\n※成王败寇之上课请睁眼\n※成王败寇之检讨而书 输于检讨\n※成王败寇之班长斗\n※成王败寇之当爱留在QQ\n※成王败寇之黄炎的幸福生活\n※成王败寇之微机课\n※成王败寇之人生成王或败寇\n※【B·T·S】第3集-昨日苦缘得叹红袖(一曲终演奏新起点)\n※【B·T·S】第4集-神秘人痛诉生平事(小棋子揭开血泪史)\n※【B·T·S】第5集-忆前世终将化今生(喟昨日抒情挥现时)\n……(根据情况再行删减)\n高二※【煮任全席】总校最后的毕业生高三※【煮任全席】搞中结束高中正式の开始 ※煮任再归来\n※〖煮任调味料〗＜新＞第1期 ※\n※〖煮任厨房〗＜新＞第1期-猫版玛丽随JB\n※〖煮任调味料〗＜新＞第2期-猫丽小岛上不为人知的故事……\n※〖煮任厨房〗＜新＞第2期-再说叫兽\n※【煮任调味料】煮任教你画图画-第3期\n※【煮任调味料】黄炎的幸福生活-第4期\n※【煮任调味料】我不想说我是狗狗-第5期\n※【煮任厨房】煮任纯洁讲说女流姐姐-第3期\n※【煮任菜谱】\n※【煮任菜谱】\n※【煮任菜谱】\n※【煮任厨房】煮任　讲说金面佛老湿-第4期\n※【煮任厨房】伤不起的《三毛历险记》-第5期\n※【煮任厨房】各种版本的动画西游记-第6期\n※【煮任厨房】煮任　讲说砖家同学-第7期\n※【煮任厨房】煮任　讲说敖厂长-第8期\n※【煮任调味料】三国无双真·一日游-第6期\n※【煮任厨房】外挂城与掉线勇士-第9期\n※【煮任厨房】煮任憧憬讲说群星璀璨-第10期\n※【煮任厨房】炫迪与蓝猫不得不说的那些事-第11期\n……\n※【煮任全席】煮任是怎样练成的\n……\n","date":"2013-01-17T01:41:13Z","permalink":"https://boiltask.com/qzone/1358386891/","title":"煮任视频目录"},{"content":"提示：把下列字符按正确顺序排列就是我的名字！\n①│┌╯ ╯│╯ ││├──┤ └──┼─┘\n②└─╯ └╯┘ ╰ └──╯ └──╯─┘\n③│┐┐ │││ │││ │ │\n④┌─┐ ├─┐ ┬┐┌──┐ ┌──┬─┐\n⑤│││ │││ │╯│ │ │\n⑥│┘└ │ │╯│ │ │\n你也可以把字符复制到文本文档里慢慢的组合一共也就Ⅴ×Ⅵ〓⊰◎种组合\n(^__^) 嘻嘻……\n右键全选看提示！\n答案如下，只要你能看懂^_^：\n（答六个问题，按答案顺序排字符）\n①Ⅹ/2.5 ②Ⅳ-Ⅰ ③Ⅵ┤ ④Ⅷ╳⑴/捌 ⑤陆※Î ⑥⊱⊰﹣⊰┤-Ⅱ\n","date":"2010-12-11T19:39:00+08:00","permalink":"https://boiltask.com/qzone/1292067567/","title":"字符游戏：My name is……"}]