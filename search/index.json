[{"content":"似乎自从空间开始流传开来，博客这一事物就有着被淘汰的趋势，似乎只有些专业人士愿意坚持这一交流形式……\n不管怎么说，博客还是有它的优点与可取之处了，比如我非常喜欢的这个代码标注功能，太赞了……\n想法和目标\r既然博客创建了就不能让它没有什么卵用~\r记录一些学习道路上的所见所想吧，虽然在这里可能并没有什么人来看-_-\n但也╮(╯_╰)╭无所谓嘛~留给自己的礼物吧 毕竟怀旧并且有旧可怀是件非常爽的事……\n作为一个个探讨技术的博客~第一篇随便写写代码吧……\n想想那时候小的时候，我还是喜欢这种非正规字体时，我惧于C语言的英语性，也加上爱玩的心态，所以选择了一阵乱学，最有卵用的还是号称中文编程的易语言……于是……\r1 标签1.标题=“你好世界！我就是不写英文” 那时候甚至都没用过 调试输出 这种东西……因为感觉没什么卵用……\n但……\n既然选择了计算机专业，化成灰也要随风往前飘！\r这个大一学期开始，才第一次用心看C语言……写下了:\n1 2 3 4 #include\u0026lt;stdio.h\u0026gt; main(){ printf(\u0026#34;Hello World\u0026#34;); } 妥协了……于是耐心研究……到现在 我又更喜欢写……\n1 2 3 4 5 6 #include\u0026lt;stdio.h\u0026gt; int main(){ printf(\u0026#34;Hello World\\n\u0026#34;); printf(\u0026#34;我还是喜欢中文！\\n\u0026#34;); return 0; } ╮(╯▽╰)╭ 心中要有目标嘛\n中国计算机要继续努力啊！\n加油加油！\n心得和体会 以后慢慢来谈吧~\n网站的问题也还要继续研究！\n煮梦空间——www.BoilTask.com\n","date":"2015-11-18T05:21:05Z","permalink":"https://boiltask.com/record/first-blog/","title":"📌第一篇正式文章 随便聊聊吧"},{"content":"整理之前文章的时候，发现有一些题目的源站点已经不在了，找寻题目也挺费劲，因此在思考能不能有什么方式做一下备份。\n并且自己在文章里附带题目描述的时候，也能有个更优雅的引入方式。\n站点：Online Judge Problem\n","date":"2025-04-10T21:40:08+08:00","permalink":"https://boiltask.com/record/oj-problem/","title":"做了一个采集OnlineJudge题目的站点"},{"content":"前端在生成index时加密内容，提供一个JS根据输入的密码解密内容，根据得到的解密内容中是否包含指定信息来判断是否解密成功。\n由于是前端加解密，需要考虑如何选择合适的加密解密算法，使得暴力破解的成本提高。\n参考zip加密技术，当暴力破解的成本足够高的时候，可以认为内容是安全的。\n","date":"2025-04-09T12:43:51+08:00","permalink":"https://boiltask.com/knowledge/hugo-encryption/","title":"Hugo文章加密的一种设想"},{"content":"之前制作事件插件上传到Fab平台时遇见了一些麻烦，在这里记录一下。\n","date":"2025-04-06T12:23:15+08:00","permalink":"https://boiltask.com/knowledge/fab-ue-plugin-publish/","title":"UE插件上传Fab的一些心得"},{"content":"突然想开个新坑，要不fork一下hugo-theme-stack自己魔改一下？\n可能也就是说说……\n不过Hugo的主题管理方案挺方便的，可能会逐步添加一些想要的功能，要是量级足够的话，开个新主题好像也不是不行……\n参考：\nGitHub - CaiJimmy/hugo-theme-stack: Card-style Hugo theme designed for bloggers GitHub - hugo-fixit/FixIt: 🔧 A clean, elegant but advanced blog theme for Hugo 一个简洁、优雅且高效的 Hugo 主题 ","date":"2025-04-05T03:21:08+08:00","permalink":"https://boiltask.com/record/fork-hugo-theme-stack/","title":"突然想开个新坑做个主题"},{"content":"之前一直是Notion的拥趸，不过随着又有好久不用Notion，又重新起了笔记软件挑选的念头。\n之前一直觉得Obsidian作为一个本地存档的笔记软件，功能也没有Notion强大，还需要自己处理同步等问题，应该是没什么优势。\n不过上次折腾起来Hugo之后，越发感觉笔记这种东西，还是返璞归真比较适合我，要不太容易忙于折腾样式、排版什么的问题而分心。到最后发现，除了设计好的模板，其实真正的内容没有多少。\n下载下来Obsidian之后，发现他和Hugo的工作流意外的搭。使用Obsidian来管理工作区，比用专注编码的IDE要更适合文档类的整理工作。虽然这样以来又有些浪费“重金”买的Typora，不过总算也是能物尽其用吧。\n说起来作为Typora刚出付费方案就首发入手的用户，好像自从买了就没大用过……反倒是之前免费的时候，还拿来写过一些东西。\n使用Obsidian打开Hugo的文件夹，正常在content路径写内容，然后把一些不需要上传到博客上的文章，还有一些Hugo不支持的文章放在单独的文件夹中即可。\n","date":"2025-04-03T21:40:08+08:00","permalink":"https://boiltask.com/record/try-obsidian/","title":"尝试Obsidian与Hugo结合"},{"content":"之前经常纠结中英文混排时的排版问题，因此引入了pangu.js来优化排版效果。\n官方仓库：vinta/pangu.js: Paranoid text spacing in JavaScript\n调用pangu.autoSpacingPage()即可将页面转换为美化之后的结果。\n由于JS的加载与处理需要时间，直接这么写的话，体验上是用户会先看到处理前的页面，然后短暂停留后刷新为新内容，这就导致体验上很奇怪。\n解决思路的话，可以考虑先隐藏页面，等DOM加载完，先进行pangu.js的处理，完毕后再重新显示页面。\n为了避免第一次加载较久，还可以加一个Loading效果。\n需要注意autoSpacingPage函数会异步处理，可以改为阻塞版本的spacingPage。\n参考代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 \u0026lt;div id=\u0026#34;loadingOverlay\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;loader\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;p\u0026gt;加载中...\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;style\u0026gt; #loadingOverlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255, 255, 255, 0.9); z-index: 9999; display: none; justify-content: center; align-items: center; flex-direction: column; } .loader { border: 8px solid #f3f3f3; border-top: 8px solid #3498db; border-radius: 50%; width: 60px; height: 60px; animation: spin 1s linear infinite; } @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } } \u0026lt;/style\u0026gt; \u0026lt;style\u0026gt; /* 初始隐藏页面内容，避免显示未经处理的文本 */ .main-container { display: none; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; let isShouldLoad = true; setTimeout(() =\u0026gt; { if (isShouldLoad) { const loadingOverlay = document.getElementById(\u0026#39;loadingOverlay\u0026#39;); if (loadingOverlay) { loadingOverlay.style.display = \u0026#39;flex\u0026#39;; } } }, 200); // 0.2秒如果还没有加载完成就开启Loading \u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34;\u0026gt; import pangu from \u0026#39;https://jspm.dev/pangu\u0026#39;; document.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, () =\u0026gt; { isShouldLoad = false pangu.spacingPage(); const elements = document.getElementsByClassName(\u0026#34;main-container\u0026#34;) for (let i = 0; i \u0026lt; elements.length; i++) { elements[i].style.display = \u0026#39;flex\u0026#39;; } const loadingOverlay = document.getElementById(\u0026#39;loadingOverlay\u0026#39;); if (loadingOverlay) { loadingOverlay.style.display = \u0026#39;none\u0026#39;; } }); \u0026lt;/script\u0026gt; ","date":"2025-04-03T09:06:12+08:00","permalink":"https://boiltask.com/record/hugo-pangu/","title":"给Hugo博客引入pangu.js"},{"content":"简介 在排查一些内存问题（野指针、越界访问等）时，可以使用AddressSanitizer（ASan）工具。\n比起修改为Stomp分配器的方式，ASan的实现以性能降低约一半的代价，也能扫描出来很多问题。\n性能指标参考：AddressSanitizerPerformanceNumbers · google/sanitizers Wiki\nLinux下DS使用 基本流程 考虑开启 ASan 对流程和性能的影响，一般需要单独部署一些炮灰环境。\n在原有的打包参数之后添加-EnableAsan标识，用来开启ASan相关的编译参数 启动时通过设置环境变量ASAN_OPTIONS来控制ASan的相关配置 在原先的启动参数之后加上-ansimalloc标识 当遇见异常时，检查stderr的输出 可以选择配置log_path来指定异常时的输出文件 堆栈获取 通过指定ASAN_SYMBOLIZER_PATH可以使得输出的信息里自带堆栈，使用了llvm- symbolizer ，性能比起addr2line可以有较高的提升。\n详见：AddressSanitizerCallStack · google/sanitizers Wiki\n会使得输出日志稍微慢几秒，目测可以接受。\n可以使用格式文本设定stack_trace_format：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // %% - represents a \u0026#39;%\u0026#39; character; // %n - frame number (copy of frame_no); // %p - PC in hex format; // %m - path to module (binary or shared object); // %o - offset in the module in hex format; // %f - function name; // %q - offset in the function in hex format (*if available*); // %s - path to source file; // %l - line in the source file; // %c - column in the source file; // %F - if function is known to be \u0026lt;foo\u0026gt;, prints \u0026#34;in \u0026lt;foo\u0026gt;\u0026#34;, possibly // followed by the offset in this function, but only if source file // is unknown; // %S - prints file/line/column information; // %L - prints location information: file/line/column, if it is known, or // module+offset if it is known, or (\u0026lt;unknown module\u0026gt;) string. // %M - prints module basename and offset, if it is known, or PC. 不过测试下来似乎未取到函数行号，判断是llvm的问题，addr2line就可以。\nwindows下使用llvm-symbolizer.exe也可以成功取到。\n同时，测试下来windows下使用MinGW版本的addr2line也可以取到堆栈，但是慢到无法接收。\n推荐配置 开启堆栈输出并设置日志路径：\n1 export ASAN_OPTIONS=\u0026#34;symbolize=1:print_stacktrace=1:log_path=/home/crash/ds-${版本}-asan-crash.log\u0026#34; 问题记录 开启ASan之后加载过慢 需要检查fast_unwind_on_malloc是否被设置为0，如果fast_unwind_on_malloc被关闭，则会极大地影响性能。\n详见：Address Sanitizer | Android NDK | Android Developers\n堆栈还原 写了一个golang的脚本用于快速的分析堆栈：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 package main import ( \u0026#34;bufio\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/exec\u0026#34; \u0026#34;strings\u0026#34; ) func convertStackToAddr2line(inputFile, outputFile, binaryPath string) error { infile, err := os.Open(inputFile) if err != nil { return fmt.Errorf(\u0026#34;无法打开输入文件: %v\u0026#34;, err) } defer func(infile *os.File) { err := infile.Close() if err != nil { fmt.Printf(\u0026#34;关闭输入文件时出错: %v\\n\u0026#34;, err) } }(infile) outfile, err := os.Create(outputFile) if err != nil { return fmt.Errorf(\u0026#34;无法创建输出文件: %v\u0026#34;, err) } defer func(outfile *os.File) { err := outfile.Close() if err != nil { fmt.Printf(\u0026#34;关闭输出文件时出错: %v\\n\u0026#34;, err) } }(outfile) scanner := bufio.NewScanner(infile) writer := bufio.NewWriter(outfile) defer func(writer *bufio.Writer) { err := writer.Flush() if err != nil { fmt.Printf(\u0026#34;刷新输出文件时出错: %v\\n\u0026#34;, err) } }(writer) for scanner.Scan() { line := strings.TrimSpace(scanner.Text()) if strings.HasPrefix(line, \u0026#34;#\u0026#34;) { parts := strings.Fields(line) var address string for _, part := range parts { if strings.HasPrefix(part, \u0026#34;0x\u0026#34;) { address = part break } } if address != \u0026#34;\u0026#34; { cmd := exec.Command(\u0026#34;addr2line\u0026#34;, \u0026#34;-e\u0026#34;, binaryPath, address) output, err := cmd.Output() if err != nil { _, err := fmt.Fprintf(os.Stderr, \u0026#34;执行 addr2line 失败: %v\\n\u0026#34;, err) if err != nil { return err } continue } s := strings.TrimSpace(string(output)) _, err = writer.WriteString(s + \u0026#34;\\n\u0026#34;) if err != nil { return err } fmt.Println(s) } } else { _, err := writer.WriteString(line + \u0026#34;\\n\u0026#34;) if err != nil { return err } fmt.Println(line) } } if err := scanner.Err(); err != nil { return fmt.Errorf(\u0026#34;读取文件时出错: %v\u0026#34;, err) } fmt.Printf(\u0026#34;转换完成，结果已保存到 %s\\n\u0026#34;, outputFile) return nil } func main() { if len(os.Args) != 4 { fmt.Println(\u0026#34;Usage: go run main.go \u0026lt;input_file\u0026gt; \u0026lt;output_file\u0026gt; \u0026lt;binary_path\u0026gt;\u0026#34;) os.Exit(1) } inputFile := os.Args[1] outputFile := os.Args[2] binaryPath := os.Args[3] if err := convertStackToAddr2line(inputFile, outputFile, binaryPath); err != nil { _, err := fmt.Fprintf(os.Stderr, \u0026#34;错误: %v\\n\u0026#34;, err) if err != nil { return } os.Exit(1) } } 参考文章 在虚幻引擎项目中使用Clang检测工具 | 虚幻引擎 5.5 文档 | Epic Developer Community google/sanitizers: AddressSanitizer, ThreadSanitizer, MemorySanitizer AddressSanitizer can output Stacktrace on android debug buildconfiguration but not development? - International - Epic Developer Community Forums ","date":"2025-04-03T09:03:48+08:00","permalink":"https://boiltask.com/knowledge/ue/ue-asan/","title":"虚幻引擎中ASan相关机制"},{"content":"简介 在Actor的复制过程中，需要关心两个属性，Role与RemoteRole。\n通过这两个属性，可以明确地知道：\n谁拥有Actor的主控权 Actor是否被复制 复制模式 首先一件要确定的事，就是谁拥有特定 actor 的主控权。要确定当前运行的引擎实例是否有主控者，需要查看 Role 属性是否为 ROLE_Authority。如果是，就表明这个运行中的 虚幻引擎 实例负责掌管此 actor（决定其是否被复制）。\n如果 Role 是 ROLE_Authority，RemoteRole 是 ROLE_SimulatedProxy 或 ROLE_AutonomousProxy，就说明这个引擎实例负责将此 actor 复制到远程连接。\n简单来说：\n对于单机模式，Actor的Role与RemoteRole很显然都是ROLE_Authority。\n对于网络模型下，Role代表本地对于Actor的角色，RemoteRole代表对端对于Actor的角色。\n下面将重点描述多人游戏时的相关机制。\n属性类型 ROLE_Authority 代表最高权限，通常是服务器持有的状态。\n如果客户端本地生成的一个不同步的Actor，其Role有可能也为ROLE_Authority，因为此时这个客户端对这个Actor具有绝对的权限。\nROLE_SimulatedProxy 被动模拟角色，由服务器控制，客户端仅接受同步数据。\n比如对于客户端A视角下的另一个角色，它的Role就有可能是ROLE_SimulatedProxy。\nROLE_AutonomousProxy 主控端角色，通常代表由客户端直接控制，服务器接收控制的输入来同步其状态。\n比如对于客户端A视角下的自身角色，它的Role就有可能是ROLE_AutonomousProxy，接收输入之后发给服务器更新其状态。\nRemoteRole与Role的区别 RemoteRole与Role对应，代表对端对Actor的角色定义，是Role的另一个视角。\n当Actor在服务器为ROLE_Authority，他在服务器上的RemoteRole为ROLE_SimulatedProxy，对应的客户端的Role为ROLE_SimulatedProxy，RemoteRole为ROLE_Authority。\n对于不同的数值观察者，它们的 Role 和 RemoteRole 值可能发生对调。\n注意这个可能的描述\n比如客户端Role为ROLE_AutonomousProxy，RemoteRole为ROLE_Authority的角色（自己操作的那个），他在服务器上的Role为ROLE_Authority，但是RemoteRole可能为ROLE_SimulatedProxy。\n角色组合 常见Role与RemoteRole的组合 本地Role 远程RemoteRole 场景说明 ROLE_Authority ROLE_SimulatedProxy 服务器视角，控制Actor，客户端仅接收同步数据（如NPC）。 ROLE_SimulatedProxy ROLE_Authority 客户端视角，客户端接收服务器同步的Actor（如静态场景物体）。 ROLE_AutonomousProxy ROLE_SimulatedProxy 客户端视角，客户端控制Actor，服务器同步其状态（如玩家角色）。 区分SimulatedProxy与AutonomousProxy 参考官方文档的描述，由于Actor的同步具有间隔，为了弥补这个缺陷，客户端在模拟时采取两种策略：\nROLE_SimulatedProxy通常直接根据服务器同步的信息进行模拟。\nROLE_AutonomousProxy通常会考虑客户端自身的输入，通过这部分输入来补足信息，而非只通过服务器的信息推算。\n参考文档 虚幻引擎Actor的 Role 和 RemoteRole属性 | 虚幻引擎 5.5 文档 | Epic Developer Community ","date":"2025-04-02T13:17:46+08:00","permalink":"https://boiltask.com/knowledge/ue/network-role/","title":"虚幻引擎中网络角色Role相关概念"},{"content":"简介 本文主要用于整理虚幻引擎中移动相关的机制。\n内容可能摘录自各个文章、论坛、文档等，仅用作记录。\n基础简介 移动是一个非常重要并且较为复杂的模块，UnrealEngine对于移动的实现使用了组合模式，在描述Actor的移动时，含义是具有移动组件的Actor可以移动。\n移动组件的基类为UMovementComponent，提供基本的移动功能，有多个不同功能的子类，一些子类移动组件专门用于服务一种特殊的Actor，比如通常代表玩家的ACharacter，对应的移动组件UCharacterMovementComponent。\nActor虽然代表在World中的一个实体，但是本身是没有位置概念的。Actor的位置由其具有的USceneComponent赋予。因此移动的本质，就是改变Actor上的某个USceneComponent的位置，通常指的是Actor的RootComponent。\nUMovementComponent上有个属性UpdatedComponent，就是用于设置移动组件所修改的USceneComponent。暴露给蓝图有个参数bAutoRegisterUpdatedComponent，如果设置为true，则会在组件初始化时，读取Owner的RootComponent，调用SetUpdatedComponent设置UpdatedComponent。\n移动流程 网络同步下的角色移动至少需要考虑以下几个方面：\n玩家客户端操作无延迟 需要直接响应移动输入并上报给服务器 位置以服务器为准 防止外挂 同步到的移动需要表现丝滑 不可能每帧都收到位置更新，需要适当进行插值 自主实现 先思考如果自己实现的情况下可能会怎么做。\n本地接收到输入之后，在本地先操作移动，同时把移动的操作发送给服务器 可能包含的信息是：当前位置、目标位置等 服务器接收到移动的操作，在服务器上执行移动，并把玩家位移的信息同步给所有客户端 信息同样包含：当前位置、目标位置、速度等 其他客户端收到了移动的信息后，修改角色的移动目标，根据插值调整角色位置 引擎实现 虚幻引擎网络同步情况下的移动流程与此类似，大概为：\n每一帧执行TickComponent时，计算这一帧的加速度和转向，之后对于主控的Character，调用ReplicateMoveToServer把移动同步给服务器\nReplicateMoveToServer会把移动保存到列表，然后执行PerformMovement在本地预执行移动操作。\n然后会调用ServerMove把移动同步给服务器，告知移动的参数、客户端自己移动的位置，以及时间戳\nServerMove在服务器上执行，根据客户端声明的位置，与服务器的位置做对比，如果差异过大，则调用ClientAdjustPosition在主控端校正位置\n客户端如果收到ClientAdjustPosition，会把客户端角色位置设置为服务器上的位置，并把bUpdatePosition标记为true，这将会影响到后续的移动更新\n当客户端再次调用TickComponent时，如果存在bUpdatePosition，则会调用ClientUpdatePositionAfterServerUpdate来重演在服务器上调整移动之后发生的所有移动。\n在引擎源码CharacterMovementComponent.h中可以找到对移动同步流程的描述：\nHere\u0026rsquo;s how player movement prediction, replication and correction works in network games:\nEvery tick, the TickComponent() function is called. It figures out the acceleration and rotation change for the frame, and then calls PerformMovement() (for locally controlled Characters), or ReplicateMoveToServer() (if it\u0026rsquo;s a network client).\nReplicateMoveToServer() saves the move (in the PendingMove list), calls PerformMovement(), and then replicates the move to the server by calling the replicated function ServerMove() - passing the movement parameters, the client\u0026rsquo;s resultant position, and a timestamp.\nServerMove() is executed on the server. It decodes the movement parameters and causes the appropriate movement to occur. It then looks at the resulting position and if enough time has passed since the last response, or the position error is significant enough, the server calls ClientAdjustPosition(), a replicated function.\nClientAdjustPosition() is executed on the client. The client sets its position to the servers version of position, and sets the bUpdatePosition flag to true.\nWhen TickComponent() is called on the client again, if bUpdatePosition is true, the client will call ClientUpdatePosition() before calling PerformMovement(). ClientUpdatePosition() replays all the moves in the pending move list which occurred after the timestamp of the move the server was adjusting.\n玩家输入 管理玩家输入的也是一个组件UInputComponent，通常可以调用BindAxis来注册事件响应。\n一般最终会调用到UPawnMovementComponent::AddInputVector来处理移动。\n主控角色移动 在UE的网络框架中，角色主要分为三种：ROLE_Authority、ROLE_AutonomousProxy、ROLE_SimulatedProxy。\n详见：虚幻引擎中网络角色Role相关概念\n在客户端主控角色也即Autonomous角色会接受控制，然后把移动数据发往服务器。\n本地的每次移动都会生成FSavedMove_Character，并维护一个TArray\u0026lt;FSavedMovePtr\u0026gt; SavedMoves的数组，保存了当前玩家本地已经做的移动，这些移动还没经过服务器检查。\n如果服务器认可了一些移动，就可以把这些移动删掉，如果检查不通过，就可以据此执行异常处理。\n协议选择 在UE中，默认使用UDP作为传输协议，这可以使得数据包尽快送达。\nUDP不保证可达和有序，但是应用层面可以通过设计来在需要的地方避免这些问题。\nServer同步移动给客户端 Actor基本同步方案 Actor自身就支持移动同步，打开ReplicateMovement开关后，当Actor的RootComponent位置、朝向等数据发生变化时，就会把数据同步给Simulate客户端。\n当Simulate的客户端收到同步之后，会简单的设置自己的位置和朝向。移动数据的同步有间隔，因此这种实现会导致Actor发生闪现。\nCharacter移动同步 针对Actor基本同步模式的不足，CharacterMovementComponent针对性的做了表现平滑处理，让Simulate角色移动尽可能平滑自然。\nCharacter主要有两个组件，Capsule和Mesh，Capsule是Chara\n关键概念 UCharacterMovement 角色移动组件是最为复杂的一个子类，需要重点进行分析。\nclassDiagram\rclass UCharacterMovementComponent {\r+IRVOAvoidanceInterface\r+INetworkPredictionInterface\r}\rUActorComponent \u0026lt;|-- UMovementComponent\rUMovementComponent \u0026lt;|-- UNavMovementComponent\rUNavMovementComponent \u0026lt;|-- UPawnMovementComponent\rUPawnMovementComponent \u0026lt;|-- UCharacterMovementComponent\rFSavedMove_Character 用于描述玩家的一次移动，可以认为是一次移动的快照。\n主要属性有：\n属性 描述 TimeStamp 这次移动发生的时间 DeltaTime 这次移动使用的时间 CustomTimeDilation 时间膨胀系数，可以用于快进和慢放 StartPackedMovementMode 移动发生前的MovementMode StartLocation 移动发生前的位置 StartVelocity 移动发生前的速度 EndPackedMovementMode 移动发生后的MovementMode SavedLocation 移动发生后的位置 SavedVelocity 移动发生后的速度 Acceleration 移动所用加速度 理论上只要有这些数据，就能复盘整个移动过程，也可用作回放功能。\nReplicateMoveToServer 首先会从SavedMoves里找到最早发生的一个ImportantMove（通过IsImportantMove判断），也就是最新被服务器确认的有显著差异的Move。\n之后创建一个FSavedMove_Character并初始化。然后执行PerformMovement，对角色计算操作后的属性，设置上相关信息。\n根据能否被合并，进行处理。\n延迟发送Move 一个Move有可能可以被延迟一会，与后面的Move合并后再发给服务器。因此一个新建的Move被发往服务器前会先判断是否可以延迟发送。\n首先判断是否开启了NetEnableMoveCombining，如果没开也不会延迟发送。\n同时还会判断当前的Move是否能被延迟发送，会检查该Move前后MovementMode是否改变，如果改变也需要即使变化。也就是说，如果此次Move没有显著改变，那么则可以延后发送，理论上服务器根据之前的信息推算，结果应该是一样的。\n然后会计算当前预期的移动更新时间间隔，根据当前网速、玩家数量等信息，在基准值ClientNetSendMoveDeltaTime上做调整，得到最终间隔，如果Tick时还没达到更新间隔，就会延迟发送Move，把它储存在PendingMove中，留着以后处理。\nCallServerMove 函数接受两个参数，一个是刚创建的Move，另一个是之前获取的ImportantMove（ImportantMove可能为空）。不需要把整个Move都发往服务器，只需要位置、旋转、加速度等关键信息，并且这些信息会经过压缩。\n压缩的过程简单来说，会尝试牺牲精度，把一些字段合并在一个数据结构中。\n之后还会调用ServerMoveOld，把ImportantMove中的一些信息发送到服务器，可以简单理解为一种冗余的保险。\n如果存在PendingMove，说明存在未合并的Move，需要调用ServerMoveDual一次发送两个连续的Move。否则，说明发送间隔较大，或者PendingMove已经被合并，就调用ServerMode发送这个Move。\nServerMoveOld ServerMoveOld主要作为一种冗余措施，防止服务器新收到一个移动数据时，因为网络丢包而落后太多，导致移动判断不通过，进而纠正客户端位置。ServerMoveOld可以让服务器使用传递的加速度，粗略的从旧位置快速移动到新位置，不校验移动结果。\nTODO：安全性如何保证？\nTODO 具有物理模拟下的移动\n移动如何通过RPC发送的\n参考文章 UE4移动的网络同步 - 知乎 UE4/UE5 Character Movement Component移动组件网络同步详解 - 知乎 「Grow by UE」图解角色移动组件 - 知乎 UE移动同步原理分析（一）：Pawn的移动属性复制 - 知乎 ","date":"2025-04-02T12:54:31+08:00","permalink":"https://boiltask.com/knowledge/ue/character-movement/","title":"虚幻引擎中角色移动相关机制"},{"content":"配置参数 Window指定编译SDK 修改Engine/Saved/UnrealBuildTool/BuildConfiguration.xml中的配置，添加MSVC版本号、SDK的版本号。\n1 2 3 4 \u0026lt;WindowsPlatform\u0026gt; \u0026lt;CompilerVersion \u0026gt;14.40.33807\u0026lt;/CompilerVersion\u0026gt; \u0026lt;WindowsSdkVersion\u0026gt;10.0.20348.0\u0026lt;/WindowsSdkVersion\u0026gt; \u0026lt;/WindowsPlatform\u0026gt; 最终示例 配置文件形如：\n1 2 3 4 5 6 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34; ?\u0026gt; \u0026lt;Configuration xmlns=\u0026#34;https://www.unrealengine.com/BuildConfiguration\u0026#34;\u0026gt; \u0026lt;WindowsPlatform\u0026gt; \u0026lt;WindowsSdkVersion\u0026gt;10.0.19041.0\u0026lt;/WindowsSdkVersion\u0026gt; \u0026lt;/WindowsPlatform\u0026gt; \u0026lt;/Configuration\u0026gt; 参考文章 Build Configuration for Unreal Engine | Unreal Engine 5.5 Documentation | Epic Developer Community\n","date":"2025-03-05T12:42:21+08:00","permalink":"https://boiltask.com/knowledge/ue/build-configuration/","title":"UnrealEngine虚幻引擎编译选项"},{"content":"在编辑器中按下~键打开控制台（就是数字1左边的那个按键）\n下面列出一些常用的控制台指令：\nstat fps 显示帧率\nstat unit 显示包括drawcall，游戏逻辑线程，渲染线程，面数等信息（面数信息需要在设置中调整ES3.1才会显示）\nslomo 0.1 游戏运行下的速度0.1表示运行速度变为正常的十分之一\nr.showcollision 显示碰撞体\nt.maxfps 60 设置最大帧率\n更多控制台指令可以在下面这个网站查询： https://digilander.libero.it/ZioYuri78/\n","date":"2025-02-26T11:44:41+08:00","permalink":"https://boiltask.com/knowledge/ue/common-console-command/","title":"UE4常用控制台指令"},{"content":"UE对于Blueprint似乎有个函数级的Merge工具，初体验不太好用还在研究。\n1 D:\\MetaEngine\\Engine\\Binaries\\Win64\\UE4Editor.exe D:\\Meta\\Meta.uproject -diff %theirs %mine %base %merged ","date":"2025-02-24T11:57:11+08:00","permalink":"https://boiltask.com/knowledge/ue/blueprint-merge/","title":"虚幻引擎蓝图合并工具"},{"content":"A-J\n参考文章 加权随机采样 (Weighted Random Sampling) | 三点水\n加权随机采样 | HCigmoid\n前缀和应用之生成加权随机数 | coolcao的小站\n","date":"2024-12-13T12:50:53+08:00","permalink":"https://boiltask.com/knowledge/random-weight/","title":"常用加权随机算法说明与实现"},{"content":" Detailed Actor Replication Flow暂时没有官方翻译，尝试理解顺便翻译一下。\n简介 Actor复制是一个详细的多步骤过程，其中网络驱动程序（Net Driver）确定需要向哪些连接复制哪些Actor，以及按照什么顺序复制。本页面提供了Actor复制流程的概述。\n大多数Actor的复制是在UNetDriver::ServerReplicateActors函数中进行的。 在这个函数中，服务器会首先收集所有被判定对每个客户端相关的Actor，然后将自上次更新以来发生变化的属性发送给每个已连接的客户端。随后，UActorChannel::ReplicateActor 函数负责处理将特定Actor复制到某一通道的详细操作。\n重要属性 对于如何更新 actor、调用某些框架回调以及用于确定在当前服务器 tick 期间是否复制 actor 的属性，有一个定义的流程。以下是一些重要的属性：\n属性 描述 AActor::NetUpdateFrequency 决定Actor复制的频率。 AActor::PreReplication 在任何复制操作发生之前调用。 AActor::bOnlyRelevantToOwner 如果该Actor只会复制给其拥有者，则为True。 AActor::IsRelevancyOwnerFor 当bOnlyRelevantToOwner为True时，决定Actor的相关性。 AActor::IsNetRelevantFor 当bOnlyRelevantToOwner为False时，决定Actor的相关性。 AActor::NetDormancy 决定Actor是处于休眠状态还是激活状态。 Actor复制流程概述 以下步骤构成了Actor复制过程的高级概述：\n确定需要复制的Actors，并进行检查以确定它们的休眠状态、更新频率以及拥有的连接。 将通过这些检查的Actors添加到一个列表中，准备进行复制。 遍历每个连接，并根据当前的Actor和连接执行检查。完成此步骤后，得到每个连接需要复制的Actor列表。 按照优先级对每个连接的Actors进行排序。 确定该Actor是否对当前连接相关。 将该Actor复制到当前连接。 以下部分将提供上述Actor复制流程概述中每一步的详细描述。\n将Actor添加到待复制列表 此步骤首先检查所有Actors，确定哪些Actors正在进行复制（通过检查是否调用了 AActor::SetReplicates(true)）。对于每个正在复制的Actor，NetDriver 执行以下检查：\n判断当前Actor是否初始处于休眠状态（ENetDormancy::DORM_Initial）。 如果是休眠状态，则跳过该Actor。 检查当前Actor是否需要更新，具体通过检查 AActor::NetUpdateFrequency 属性。 如果不需要更新，则跳过该Actor。 如果 AActor::bOnlyRelevantToOwner 为 true，则检查该Actor的拥有连接的相关性，通过调用 AActor::IsRelevancyOwnerFor 来判断。 如果相关，则将其添加到该连接的“拥有者相关列表”中。 在这种情况下，该Actor只会发送给单个连接。 对于通过上述检查的每个Actor，调用 AActor::PreReplication。在 AActor::PreReplication 中，你可以决定是否希望某些属性仅复制到特定连接。可以使用 DOREPLIFETIME_ACTIVE_OVERRIDE 宏来控制Actor复制到哪些连接。 如果Actor通过了所有检查，将其添加到待复制列表中。\n遍历每个连接 接下来，系统遍历每个连接，并为从前一步骤中获得的待复制Actor列表中的每个Actor执行以下检查和操作：\n判断当前Actor是否处于休眠状态，通过调用 AActor::NetDormancy。 如果该Actor在此连接下处于休眠状态，则跳过该Actor。 如果尚未打开通道： 判断客户端是否已加载当前Actor所在的关卡。 如果该关卡尚未加载，则跳过该Actor。 判断当前Actor是否与该连接相关，通过调用 AActor::IsNetRelevantFor。 如果Actor与连接不相关，则跳过该Actor。 将所有在连接的“拥有者相关列表”中的Actors添加到此列表中。此时，列表中包含了所有与该连接相关且不处于休眠状态的Actors。然后按照优先级（AActor::GetNetPriority）对这些Actors进行排序，优先级从高到低排序。排序至关重要，尤其是当考虑复制大量Actor时，需要确保优先复制高优先级的Actor。 遍历排序后的Actor列表 对于该连接的每个Actor，在排序后的待复制列表中执行以下操作：\n如果连接尚未加载该Actor所在的关卡，则关闭通道（如果存在）并继续。 每秒检查一次Actor是否与连接相关，调用 AActor::IsNetRelevantFor。 如果在5秒内不相关，则关闭通道。 如果相关且没有通道打开，则打开通道。 如果此连接在任何时刻变得饱和： 对于剩余的Actors： 如果相关时间少于1秒，则强制在下一tick更新。 如果相关时间超过1秒，调用 AActor::IsNetRelevantFor 判断是否在下一tick更新。 对于通过所有检查的Actor，通过调用 UActorChannel::ReplicateActor 将Actor复制到连接。 控制每次调用时复制的客户端数 你可以通过以下几种方式控制 UNetDriver::ServerReplicateActors 每次调用时复制的客户端数：\n引擎配置和命令行参数：\n启动项目时使用 -limitclientticks 命令行参数。 修改引擎配置中的 NetClientTicksPerSecond 值（位于 [/Script/Engine.Engine] 类别）。 命令行参数：\n启动项目时使用命令行参数：-limitclientticks -ini:Engine:[/Script/Engine.Engine]:NetClientTicksPerSecond=\u0026lt;VALUE\u0026gt;，其中 \u0026lt;VALUE\u0026gt; 是每秒希望使用的客户端ticks数。 控制台变量：\n设置 net.MaxConnectionsToTickPerServerFrame 控制台变量。 更多信息请参考 UNetDriver::ServerReplicateActors_PrepConnections。\n将Actor复制到连接 UActorChannel::ReplicateActor 是复制Actor及其所有组件到连接的主要方法。其流程如下：\n判断这是Actor通道打开后的第一次更新。 如果是第一次更新，则序列化需要的信息（初始位置、旋转等）。 判断当前连接是否拥有该Actor。 如果没有拥有该Actor，且该Actor的角色为 ENetRole::ROLE_AutonomousProxy，则降级为 ENetRole::ROLE_SimulatedProxy。 复制该Actor已更改的属性。 复制每个组件已更改的属性。 对于任何已删除的组件，发送特殊的删除命令。 一旦Actor列表已处理完，或通道已饱和，开始考虑下一个连接，并重复该过程直到所有连接都已更新。 更多信息 有关Actor复制的更多信息，请参考以下头文件中的内容：\n/Engine/Source/Runtime/Engine/Classes/Engine/NetDriver.h\n关于 UNetDriver::ServerReplicateActors 的信息。\n/Engine/Source/Runtime/Engine/Classes/GameFramework/Actor.h\n关于 AActor 及其函数和属性的信息。\n/Engine/Source/Runtime/Engine/Classes/Engine/ActorChannel.h\n关于 UActorChannel 和 UActorChannel::ReplicateActor 的信息。\n/Engine/Source/Runtime/Engine/Classes/Engine/EngineTypes.h\n关于 ENetRole 和 ENetDormancy 等类型的信息。\n","date":"2024-12-02T22:17:16+08:00","permalink":"https://boiltask.com/knowledge/ue/actor-replication/","title":"虚幻引擎中Actor复制流程"},{"content":"简介 想到哪里写到哪里吧，后续有可能再补充。\n虚幻引擎中Actor复制流程 虚幻引擎中网络角色Role相关概念 ","date":"2024-12-02T13:13:25+08:00","permalink":"https://boiltask.com/knowledge/ue/network-start/","title":"虚幻引擎中网络相关机制"},{"content":"功能简介 参考文档：使用Python脚本化运行虚幻编辑器\n","date":"2024-12-02T12:57:53+08:00","permalink":"https://boiltask.com/knowledge/ue/editor-python/","title":"虚幻引擎中编辑器下Python的使用"},{"content":"DataAsset简介 一般用于表示一个数据块，功能与DataTable类似，某种程度上可以理解成一个仅有一行的DataTable。\n参考文档：数据资产\n","date":"2024-11-28T13:14:08+08:00","permalink":"https://boiltask.com/knowledge/ue/data-asset/","title":"虚幻引擎中DataAsset的使用"},{"content":"打开Lyra的默认场景，运行后发现其生成了几个关卡选择器，研究一下生成原理。\n","date":"2024-11-28T13:04:08+08:00","permalink":"https://boiltask.com/knowledge/ue/lyra-start-map/","title":"Lyra的默认场景中关卡选择器的创建"},{"content":"最近想要细研究一下UE5的官方示例项目Lyra，因此创建了一些相关的博文来记录一下研究过程中的所想，总结一下项目所涉及到的技术点。\n时间点开始于2024年11月，没有提到的话相关项目以此时间点的最新版本为准。\nLyra的项目目前可以在Fab中找到：https://www.fab.com/zh-cn/listings/93faede1-4434-47c0-85f1-bf27c0820ad0\n在虚幻引擎启动器Epic Games Launcher中，可以在库找到Lyra项目，创建项目即可。\n经过测试，虽然更新日志标注了支持UE5.5，不过目前创建的仍然是UE5.1版本，后续先使用UE5.1版本测试。\n","date":"2024-11-27T12:54:43+08:00","permalink":"https://boiltask.com/knowledge/ue/lyra-download/","title":"虚幻引擎中下载Lyra官方示例项目"},{"content":"在博客部署到线上之后，发现Katex公式无法正常显示，而相同的Html文件在本地环境下是可以正常显示的。\n其中解析的核心代码如下：\n1 2 3 4 5 6 7 8 9 10 11 window.addEventListener(\u0026#34;DOMContentLoaded\u0026#34;, () =\u0026gt; { renderMathInElement(document.body, { delimiters: [ { left: \u0026#34;$$\u0026#34;, right: \u0026#34;$$\u0026#34;, display: true }, { left: \u0026#34;$\u0026#34;, right: \u0026#34;$\u0026#34;, display: false }, { left: \u0026#34;\\\\(\u0026#34;, right: \u0026#34;\\\\)\u0026#34;, display: false }, { left: \u0026#34;\\\\[\u0026#34;, right: \u0026#34;\\\\]\u0026#34;, display: true } ], ignoredClasses: [\u0026#34;gist\u0026#34;] }); }) 通过添加日志发现是DOMContentLoaded事件没有触发。\n但是一直没想到是什么原因，直到留意到了线上版本里\u0026lt;script\u0026gt;标签变成了形如\u0026lt;script type=\u0026quot;d6a94c0af8a975daac5bee56-text/javascript\u0026quot;\u0026gt;。\n最终回想起来是Cloudflare开启了Rocket Loader。\nRocket Loader是Cloudflare的一个功能，用于异步加载JavaScript，以提高页面加载速度。\n但是Rocket Loader可能会导致加载顺序变化从而导致某些JavaScript代码无法正常执行。\n暂时关闭了Rocket Loader，问题解决。\n也可以通过在标签里添加data-cfasync=\u0026quot;false\u0026quot;来禁用Rocket Loader，不过考虑还需要修改主题，暂时不做修改了。\n","date":"2024-11-09T12:45:51+08:00","permalink":"https://boiltask.com/knowledge/katex-cloudflare/","title":"Cloudflare环境下开启Rocket Loader之后Katex失效问题"},{"content":"在给博客配置评论区的时候，遇见了一些问题，记录一些。\n为何选择Giscus Stack这个主题默认的评论区是Disqus，但是Disqus是个国外的服务，而且需要收费，因此没有使用。\n同时，主题也支持了其他常见的评论区配置。我首先选择了之前经常注意到的Gitalk，使用Github的Issue来作为评论区的方式当时让人眼前一亮。\n不过配置的时候遇见了一些权限问题，发现Gitalk的权限有些不合理，评论者需要把自己的账号授权给博主来评论，理论上来说博主会获得一些不该有的登陆者的权限。 而且由于跨域问题，还需要找个处理跨域的代理，这又增添了一些隐私问题以及配置成本。\n最后选择了Giscus，它使用自己的App来作为权限拥有者，作为一个第三方，使用着只需要授权给这个应用即可完成Github的授权。\n同时使用起来也更方便和灵活。\n配置方式 在Github中安装Giscus 将仓库授权给应用 在Applications中找到Giscus 在Repository access中选择所存放评论的仓库 前往Giscus的官网继续完成配置 选择一个语言 在仓库中输入所授权的仓库，如：BoilTask/BoilTask.github.io 根据后续的配置描述选择自己所要的配置 在启用 giscus一项中查看所需要的配置 可以在需要的地方填写上生成的配置即可。\n","date":"2024-11-08T13:06:06+08:00","permalink":"https://boiltask.com/knowledge/hugo-giscus/","title":"Hogo中Giscus配置"},{"content":"最近在整理之前写的事件系统：DidaEvent，为此创建了一个文档网站。 使用了Hugo来做了网站生成系统，体验还不错，因此决定把博客也从WordPress迁移到Hugo。\n为什么要迁移 本身其实对静态建站方案是比较排斥的，一是和传统的直接在线编辑的方式比没有那么直观，二来有服务器的方案感觉也更加灵活。\n但是自己维护服务器的成本相对还是比较高的，虽然使用了WordPress，但本身我对PHP的发展也不太看好，而且相对来说也过于重了。\n经过过去的经验，服务器往往由于续费、维护等原因需要迁移，这就导致每次博客都需要重新折腾一番。让写作这件事情也变得成本更高，也很难坚持下来。\n因此使用类似于Hugo之类的静态建站方案就突显出了优势，一是有免费的托管方案，二来直接Markdown的写作方式，也能更灵活的运用起来手头的工具。\n而且真需要一些特殊的模块，其实也可以自己自定义一些空间和页面，因此应该也可以符合目前的需求。\n为什么选择Hugo 备选的静态网站生成器有很多，比如Jekyll、Hexo等等，为什么选择Hugo呢？\nHexo是用的Node.js，生成速度较慢，因此不再考虑了。\nJekyll具有Github的官方支持，可以直接在Github上部署。但是尝试了一个Jekyll的主题，感觉太复杂了。 而且其实我是希望数据源与最后生成的文件分开的，这样也方便管理。\n最后选择了Hugo，一是有合适的主题，二来生成速度快，三来使用的Golang语言也是我比较看好的一种语言。\nDidaEvent的文档使用的主题是Doks，博客使用的主题是Stack。\n迁移过程 简单的部署好框架后，感觉整体还是比较满意的。\n剩下的就是需要迁移原先WordPress的文章了，本来都做好一点一点复制的准备了，不过好在发现了一款插件：wordpress-to-hugo-exporter。 经过插件的导出，得到了一个文章的压缩包，又根据我自己的需求简单调整了一下，一个大体的博客就算搭建完毕了。\n不过有一些陈年老文章，还有一些图片需要再整理一下，就后续再慢慢翻新吧。\n评论区配置 评论区配置的时候还是遇见了一些麻烦，详见：Hogo中Giscus配置\n","date":"2024-11-08T12:46:38+08:00","permalink":"https://boiltask.com/record/202411081/","title":"又双叒叕一次重新梳理了一下博客"},{"content":" 一个写一半的文章，有缘后补。\n一个客户端程序，图像感弱，一心想做服务器。\n心路历程：\n多线程 意义 网络 Socket如何编写 如何部署 单机承载 分布式 可扩展性 先实现基础功能→随着需求演变扩展（承载力、鲁棒性等） ","date":"2024-10-24T18:12:31+08:00","permalink":"https://boiltask.com/record/talk-about-server/","title":"谈谈对服务器的认识"},{"content":" 随着灵感逐步更新，主要用于记录一下感觉这辈子应该学的东西……\n思维导图 mindmap\rroot((知识树))\rTEMP\r编程语言\rC++\rBoost\rasio\rsystem\rgdb\rPython\rJava\rTypeScript\rGolang\rLua\r服务器\r分布式架构\r数据库\rMongo\rRedis\r","date":"2024-10-09T17:25:11+08:00","permalink":"https://boiltask.com/record/knowledge-tree/","title":"人生知识树"},{"content":"人常说，时间是抚平伤痛的良药。最近的事情就发生的挺多的，凸显出时间过得非常快。亲人离去，无疑是给所有人心口上刺了一刀。而时间如微风，时不时地吹得伤口隐隐做痛。在做一件不相关的事情的时候，突然脑海浮现一处画面，不自觉地又回想起很多事情。\n总感觉应该写得什么，但一开始动手，又不知道从哪开始。虽然知道这辈子总有这天，但爷爷真得离去时，内心却总难以释怀。二十多年的时光，足够在心中种下许多难以淡忘的回忆。\n爷爷是一名老教师，从事教育43年，教书育人成为他最为看重的事情。乡下教师工作环境自然也比不上城里，不过爷爷也尽其所能，为学生们答疑解惑，培养出了一代代的栋梁之才。\n小时候，爷爷有一次把我带到他工作的学校。一个破旧的自行车，沿着乡间小路骑了好久，到地方把我放到了办公室，然后他去教室上课。怎么说呢，漫长的道路、破旧的校园、无聊的教室，对我可能算不上什么有趣的经历，但是爷爷坚持了数十载时光。\n爷爷说话不喜欢别人插话，一有人说小话，总得把人的话按住才能继续说。我常说爷爷这算职业病，可惜以后大抵是没机会说起了。\n爷爷退休也有段时间了，离开了讲台也没离开教育事业。对家中尚未成年的孩子们，爷爷言传身教，每有机会便给我们传递刻苦学习、艰苦奋斗、团结友爱的精神。爷爷自己也是这么做的，团结家人帮助邻里。他曾说：“人要勤劳要善良，谁有困难咱就帮。不图名来不图利，只要有个好心肠”。当时国家补贴乡村教师，爷爷不辞辛劳，为15名民师证明身份。奔波数月，帮助这些教室落实了国家政策，得到了周围人的称赞。\n爷爷是位老教师，也是位老农民。家里没有条件，自己想尽一些办法培养子孙后代。辛劳了一辈子，自己吃苦受罪，都是为了孩子孙子能茁壮成长。后面慢慢地，各家的生活都安稳下来，本该安详晚年生活的。爷爷也不舍得吃穿玩乐，拿着退休金自己确没什么花销。每有机会，就补贴给还在上学的孩子们。爷爷给考上大学的孩子每人一万元，还小的弟弟妹妹都准备了。很难想象，爷爷是怎么攒下的这些。从中，也能感受到爷爷对我们的爱护与期待。\n作为长孙，比起弟弟妹妹们又多了几年的回忆。印象最深的，是每逢过年都回老家爷爷奶奶那一起团圆守岁。除夕做一桌子菜，大大小小的聚在一起，说说话逗逗小孩，讨论讨论联欢晚会的节目，就是我对过年的童年回忆。后面考虑老家条件差，把爷爷奶奶接到城里了，也方便大家能日常看望。过年也就没在老家吃饭了，年味也少了许多。\n爷爷奶奶偶尔会兴起做几句诗，有时间了把这些誊抄到本子上，这些年也攒下了几十首。爷爷给写下了一篇前言，现在读起来也能感受到爷爷的心情。\n1.春节有感\n风风雨雨几十年，过去日子如黄连。\n现在生活赛蜜甜，争取活到一百年。\n注：2016年2月正当全家人欢度春节时，刚好是爷爷奶奶结婚五十年。\n24年过年的时候，一凡来永城做客。家里准备去饭店聚一聚，爷爷奶奶很高兴。前一天，爷爷掏出来第二天准备讲话用的小诗给我看。\n38.热烈欢迎\n一凡来到咱家园，全家高兴笑开颜。\n祝福大家身体好，幸福美满万万年。\n第二天一念，大家鼓掌欢呼，奶奶也不甘示弱献唱念了一首。\n39.吉祥如意\n孙女来了我高兴，全家老少把她迎。\n欢天喜地摆酒宴，吉祥如意到永远。\n爷爷说奶奶这小学没毕业的文化，现在能随口成章可不简单。\n40.知书达理\n范秀英来不简单，用心作诗好多篇。\n文化知识有点浅，知书达理美名传。\n一时间，欢笑声遍布宴席，不曾想爷爷的诗作停留在了40。\n初一得知爷爷检查身体不好，我还在劝我妈说哪能那么严重，数个月过去最后确成了这样。可能病情也随着我爷爷的节俭种下了因，有点小毛病不愿意打扰大家。年前便有些食欲不振，说着大过年的不影响大家心情，也没去医院检查。最后终于是元宵节，才去了趟医院，谁能想到一个好几年的结石，最后能演变成了这么棘手的癌症。\n于是全家人的心思都为之所牵挂，爸爸妈妈、叔叔婶子、姑姑姑父，还有几个小辈，都在想尽办法让爷爷能延续一些时光。可惜天不遂人愿，只能说科学技术还有发展空间。五一放假的时候，爸爸安排了一起照个照片，现在也成为了一家人的回忆。\n爷爷乐观开朗，一直积极地配合治疗。即使到后期病痛已经难以抵抗，也让我们安心工作学习，他会努力和病魔作斗争。为了安慰我们，还时常地说个玩笑来活跃气氛。去看望时的最后一次聊天，爷爷还在让该上班上班，该上学上学，没啥通知不需要来，不希望给我们找麻烦。\n再回去，爷爷已经难以出声了，留下最后的气力看我们一眼。\n2024年9月4日20点14分，爷爷永远离开了我们，享年77岁。\n纵有再多遗憾，往事种种也只能留在心中了。即使离去，爷爷的教诲和精神也将陪伴着我们。一家人也将铭记爷爷的遗愿，经营好自己的生活，愿爷爷在天堂安息，相信未来您也会护佑着我们继续向前。\n欧阳天\n2024年10月4日\n","date":"2024-10-04T20:20:00+08:00","permalink":"https://boiltask.com/record/qzone-1728044081/","title":"悼念亲爱的爷爷"},{"content":"功能简述 有时候需要还原错误提交，这个时候可以使用Revert命令。\n操作说明 在项目根目录上右键选择TortoiseSVN-\u0026gt;Show log，打开日志窗口。\n英文版 中文版 在所需回退的记录上右键选择Revert changes from this revision，打开确认窗口。\n英文版 中文版 选择Revert即可。\n英文版 中文版 选项说明 Revert to this revision与Revert changes from this revision的区别：\nRevert to this revision指的是复原到此版本，也即执行完之后，本地的状态应该是此版本提交后的状态。\nRevert changes from this revision指的是复原此版本的修改，执行完之后应该是此版本提交前的状态。\n","date":"2023-10-09T10:41:32+08:00","permalink":"https://boiltask.com/knowledge/svn-revert/","title":"SVN回退操作"},{"content":"想知道一个Module被谁引入的，可以通过让其报错来查看堆栈。\n在模块的Build.cs中第一行加入：throw new Exception()。\n编译，查看报错即可。\n","date":"2023-08-02T12:13:26+08:00","permalink":"https://boiltask.com/knowledge/ue/find-module-reference/","title":"查找Module被谁引入"},{"content":"以下以英文版为例，中文版同理选择对应位置选项即可。\n合并是一个相对的概念，既可以从主干（trunk）合并到分支（branch），也可以从分支（branch）合并到主干（trunk），下文以从主干（trunk）合并到分支（branch）为例。\n功能简述 为了保证一个相对稳定的文件版本，开发过程中有时会新建一个分支（branch） ，这样可以可以直接从分支获取资产以提高稳定性。\n相关操作：SVN切分支\n在我们提交主干（trunk）后，有时候需要把相同的提交传到分支，这个时候可以直接使用SVN的合并（merge）功能来简化操作。\n操作说明 准备工作 需要本地拉取（Checkout）主干目录与分支目录，并尽可能保证干净无多余变化，以降低冲突可能性。\n合并操作 在项目根目录上右键选择TortoiseSVN-\u0026gt;Show log，打开日志窗口。\n英文版 中文版 在所需合并的记录上右键选择Merge revision to...，打开选择目标窗口。\n英文版 中文版 选择本地分支的根目录，等待完成即可。\n解决冲突 若分支的版本与主干对不上，则SVN会尝试合并，如果失败则会提供如何解决冲突的确认框。\n如果涉及到多人维护的文件，请充分沟通以减少异常。\n为了表述清晰，下文把来源文件称之为主干，目标文件称之为分支。\nPostpone - 暂不处理，分支会保持冲突状态，相关文件或目录会标红，SVN会创建临时文件需要及时处理\nAccept Base - 放弃主干的文件，仍然使用分支的文件\nAccept incoming - 使用主干的文件，覆盖分支的文件\nMark as resolved - 标记为解决，但需要注意此时文件仍处于冲突状态，SVN会删除临时文件\n英文版 中文版 合并成功 出现下面的提示说明合并成功，此时分支的文件已经被修改，正常提交（commit）即可。\n英文版 中文版 ","date":"2023-05-29T21:44:15+08:00","permalink":"https://boiltask.com/knowledge/svn-merge/","title":"SVN合并操作"},{"content":"功能简述 有时候需要为了避免开发中的机制造成主干不稳定，我们会拉出来一个新的分支。\n可以使用Switch命令将本地目录切换到目标分支。\n切换分支 在项目工程所在文件夹右键选择Switch...打开分支切换窗口。\n英文版 中文版 输入目标分支，点击确认，然后等待完成即可。\n英文版 中文版 单个目录或文件切换分支 在当前想切换的目录选择switch\n找到想要切换到的分支对应的目录点击确定\n回到这个界面点击ok即可\n注：如单独切换某个目录或文件到指定分支，修改完记得切回原分支\n","date":"2023-03-13T23:14:21+08:00","permalink":"https://boiltask.com/knowledge/svn-switch-branch/","title":"SVN切分支"},{"content":"以下主要以英文版为例，中文版同理选择对应位置选项即可。\n多图警告，可通过左侧目录跳转所需章节。\n功能简述 因为修改某一文件往往需要一段时间，在此期间内如果有人上传了同一文件，如果无法合并就会导致自己提交时产生冲突。\n为了尽量避免此问题，我们可以在修改前就把文件锁定（Lock），这样其他人通过正常操作就无法上传。\n同时如果他也在修改前尝试锁定，就可以得到别人已经锁定本文件的提示，从而也避免了无效工作。\n工具使用 锁定文件 在所需锁定的文件上右键选择TortoiseSVN-\u0026gt;GetLock...，弹出确认窗口。\n英文版 中文版 在窗口里输入锁定原因，点击确认即可。\n英文版 中文版 查看锁定 如果需要查看一个文件有没有被别人锁定，可以右键选择TortoiseSVN-\u0026gt;Check for modifications。\n英文版 中文版 点击Check repository即可扫描出变更，并通过Lock一栏查看锁定者。\n英文版 中文版 释放文件 手动释放 同理，在所需释放的文件上右键选择TortoiseSVN-\u0026gt;ReleaseLock...，弹出确认窗口点击确认即可。\n英文版 中文版 自动释放 SVN默认会在提交文件时解锁对应文件，如果提交后也不想解锁，可以选择Keep Locks。\n英文版 中文版 意外情况 如果锁定时出现了如下提示，则说明已被用户锁定，锁定信息会显示在图示位置（如果锁定者没填则不显示）。\n英文版 中文版 此时需要和该用户沟通锁定原因，协商处理。\n强制锁定 由于锁标记是存在本地文件夹的，有时候由于换机器等原因锁定未释放，此时需要强制解除锁定。\n锁定操作勾选Steal the locks时，会强制无效已锁定状态，把锁定转为此次操作的用户。\n如果文件由其他用户锁定，应尽量避免使用此操作破坏开发流程。\n英文版 中文版 结合引擎 UnrealEngine提供了内置的版本控制工具，可以快捷的实现一些SVN操作，可参考引擎内置版本控制工具进行配置。\n注意事项 由于锁定之后会干扰其他同事操作，因此锁定前需要确认操作的必要性。如果遇见有人询问相关问题，应积极处理。\n未避免误操作，应不定期查看Release Lock列表，看看是否有误锁文件。\n","date":"2023-03-13T19:35:21+08:00","permalink":"https://boiltask.com/knowledge/svn-lock/","title":"SVN锁定操作"},{"content":"功能简述 为了便于多人协作UnrealEngine提供了一个版本控制工具，可结合SVN、Git等工具对蓝图等资产进行版本控制。\n工具使用 配置连接 在引擎的工具栏处有一个Source Control的选项，选择Connect to Source Control弹出确认框。 选择Subversion也即SVN，展示信息输入框。\n按照所需信息输入然后点击Accept Settings即可。 其中几项含义分别如下：\n字段 说明 示例 Provider 使用的版本控制系统 Subversion Repository 仓库的链接 http://..com/svn/***/ User Name 用户名 *** Labels Directory 仓库子路径，比如主干、某一分支等 trunk Password 用户密码 abcdefg123465 资产保存 链接版本管理后，对资产做保存等操作时会弹出确认框，询问是否要CheckOut。\n此操作对应SVN的SVN锁定操作，修改前先锁定，这样避免了多人修改同一蓝图时的冲突。\n如果该资产已经被其他人锁定了，那么点CheckOut时会有如下提示。\n如果大家都遵循此操作，则可以大大减少蓝图冲突的可能性。\n如果不需要锁定蓝图，那么可以点击Make Writable在不锁定的情况下保存。\n资产操作 链接版本管理后，在资产上右键可以展开版本管理的操作。\n其中几项含义分别如下：\n字段 说明 CheckOut CheckOut资产，对应前文的锁定 Refresh 刷新资产版本状态，解决有时候更新不及时的问题 History 打开资产的版本历史 Diff Against Depot 对比资产与仓库中的最新版本 其中最常用的是History打开资产版本历史。\n可以在版本历史里右键选择对比前一版本或对比本地文件。\n注意事项 在资产管理中CheckOut操作对应SVN的Lock操作，会锁定资产防止别人提交，因此会干扰其他同事操作。\nSVN锁定操作前需要确认操作的必要性，如果遇见有人询问相关问题，应积极处理。\n连接SVN后，一些操作会自动对SVN做标记，如移动路径、重命名、删除等，会增加操作时间，耐心等待即可。\n","date":"2023-03-13T19:33:24+08:00","permalink":"https://boiltask.com/knowledge/ue/source-control-tool/","title":"引擎内置版本控制工具"},{"content":"功能简述 蓝图因为是二进制文件，所以没办法使用svn自带的版本对比工具来比较变更。\n为了解决蓝图对比的问题，UE4提供了一个工具用以展示两个蓝图的区别。\n可以在UE编辑器中可以直接连接版本控制工具，从而提供直接查看版本历史、启动对比工具、冲突提示等功能，配置细节可以查看：引擎内置版本控制工具\n本文描述的是如何从外部调用引擎的对比工具。\n工具使用 直接使用可以在cmd命令提示符窗口输入如下命令：\n1 引擎路径\\Engine\\Binaries\\Win64\\UE4Editor.exe 项目路径\\Meta.uproject -diff 文件1路径 文件2路径 完整示例如下：\n1 D:\\MetaEngine\\Engine\\Binaries\\Win64\\UE4Editor.exe D:\\Meta\\Meta.uproject -diff D:\\Meta\\Content\\Test1.uasset D:\\Meta\\Content\\Test2.uasset 原理是运行引擎时传入-diff参数开启对比窗口，同时传入所需的项目路径与文件路径。\n结合SVN 结合svn的自定义对比工具功能，可以实现双击版本打开对比工具。\n右键项目svn根目录，选择设置（中文版同理）。\n英文版 中文版 在对比工具页签下选择高级选项（中文版同理）。\n英文版 中文版 在此窗口可以根据不同的文件后缀调用不同的对比工具，因此选择新增一条.uasset文件设置。\n英文版 中文版 输入指定命令行即可。\n英文版 中文版 扩展名输入：.uasset\n命令行完整示例如下：\n1 D:\\MetaEngine\\Engine\\Binaries\\Win64\\UE4Editor.exe D:\\Meta\\Meta.uproject -diff %base %mine 其中D:\\MetaEngine\\Engine\\Binaries\\Win64\\UE4Editor.exe为引擎可执行文件，D:\\Meta\\Meta.uproject为项目文件，%base会被转义为svn文件，%mine会被转义为当前文件。\n对比效果 注意事项 由于引擎问题，部分格式的蓝图可能不被支持。\n打开对比工具的过程较为缓慢，请耐心等待。在此过程中不能关闭svn版本历史窗口，以免目标临时文件被清除从而对比失败。\n此工具不能自动合并蓝图，因此仍需要自己手动合并文件，请谨慎操作避免冲突。\n期待UnrealEngine能更为完善！\n","date":"2023-03-13T18:50:21+08:00","permalink":"https://boiltask.com/knowledge/ue/blueprint-diff/","title":"虚幻引擎蓝图对比工具"},{"content":"在自己维护项目的时候，有的时候会因为忘了切换账号而错误标记了提交者。\n考虑只有自己在用，force强制推送也是可以接受的，所以记录一下可以使用工具来强制修改信息。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #!/bin/sh git filter-branch --env-filter \u0026#39; OLD_EMAIL=\u0026#34;BoilTask@qq.com\u0026#34; CORRECT_NAME=\u0026#34;tian.ouyang\u0026#34; CORRECT_EMAIL=\u0026#34;tian.ouyang@yingxiong.com\u0026#34; if [ \u0026#34;$GIT_COMMITTER_EMAIL\u0026#34; = \u0026#34;$OLD_EMAIL\u0026#34; ] then export GIT_COMMITTER_NAME=\u0026#34;$CORRECT_NAME\u0026#34; export GIT_COMMITTER_EMAIL=\u0026#34;$CORRECT_EMAIL\u0026#34; fi if [ \u0026#34;$GIT_AUTHOR_EMAIL\u0026#34; = \u0026#34;$OLD_EMAIL\u0026#34; ] then export GIT_AUTHOR_NAME=\u0026#34;$CORRECT_NAME\u0026#34; export GIT_AUTHOR_EMAIL=\u0026#34;$CORRECT_EMAIL\u0026#34; fi \u0026#39; 1 git push --force --tags origin \u0026#39;refs/heads/*\u0026#39; ","date":"2023-02-16T19:02:13Z","permalink":"https://boiltask.com/knowledge/git-modify/","title":"强制修改Git记录中提交者"},{"content":" 本文是若干年后补的，也不清楚是什么时候创建的了。\n现在看看这个鸽了的文章，也别有一番感觉，所以补个档。\n上一次好像还是2019总结，复盘一下为啥2020没想到写总结呢。可能整个2020仿佛都沉浸在疫情和项目中，中间穿插了7月入职一周年的时候说要为以后做准备了，然后好像也就没发生什么大事了。毕竟2019年总结也是鸽到了3月份才写，2021年总结这甚至鸽到了年终……\n其实很少设置各种隐藏，也基本不会去删除一些记录，让愿意了解我的人了解我，也是种挺好的事情。\n翻了翻记录，说要写总结是3月，结果又鸽到了7月底。\n20250403：嗯……一鸽又是好多年。\n","date":"2022-11-03T09:06:12+08:00","permalink":"https://boiltask.com/record/summary-2021/","title":"2021总结"},{"content":"String实现 思路 使用Hash方式分配字符串，根据Hash值获取对应桶，与其存在的元素比对，若都不相同，则在桶中新增元素\n需要判断的时候根据Hash值判断\n❓是否需要再判断桶中所有元素\n源码 比对桶中元素时，先对比字符串长度，不同的则认为肯定不相同。\n最新的实现根据LUAI_MAXSHORTLEN = 40判断长短字符串，对于短字符串计算Hash并使用桶机制进行对比，对于长字符串通过随机种子来分配Hash。\n❓长字符串的Hash冲突如何解决\n","date":"2022-08-01T11:21:14Z","permalink":"https://boiltask.com/notes/lua-design-implement-1/","title":"Lua设计与实现"},{"content":"练习：斐波纳契闭包 让我们用函数做些好玩的事情。\n实现一个 fibonacci 函数，它返回一个函数（闭包），该闭包返回一个斐波纳契数列 (0, 1, 1, 2, 3, 5, ...)。\n参考代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package main import \u0026#34;fmt\u0026#34; // 返回一个“返回int的函数” func fibonacci() func() int { a1, a2 := 0, 1 return func() int { res := a1 a1, a2 = a2, a1+a2 return res } } func main() { f := fibonacci() for i := 0; i \u0026lt; 10; i++ { fmt.Println(f()) } } ","date":"2021-09-01T00:50:11+08:00","permalink":"https://boiltask.com/knowledge/golang-fibonacci-closure/","title":"【Go指南】练习：斐波纳契闭包"},{"content":"练习：映射 实现 WordCount。它应当返回一个映射，其中包含字符串 s 中每个“单词”的个数。函数 wc.Test 会对此函数执行一系列测试用例，并输出成功还是失败。\n你会发现 strings.Fields 很有帮助。\n代码参考：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main import ( \u0026#34;golang.org/x/tour/wc\u0026#34; \u0026#34;strings\u0026#34; ) func WordCount(s string) map[string]int { stringList := strings.Fields(s) res := make(map[string]int) for _, word := range stringList { res[word]++ } return res } func main() { wc.Test(WordCount) } ","date":"2021-09-01T00:40:23+08:00","permalink":"https://boiltask.com/knowledge/golang-map/","title":"【Go指南】练习：映射"},{"content":" 整理一下总结的客户端向的编程规范，尽可能做到有理有据，后续可能还会不定期修订。\n头文件 Include 头文件 通过宏防止重复包含 #pragma once，所用的所有编译器均支持 包含时尽量细粒化。例如，勿包含Core.h，而在核心中包含需要定义的特定头文件。 尽量直接包含所需的头文件，以便进行细粒化包含。 在 #include 中插入空行以分割相关头文件, C 库, C++ 库, 其他库的 .h 和本项目内的 .h 是个好习惯。 尽可能在cpp中引用其他头文件，避免头文件中直接引用某一类。 可以考虑优先使用声明类的形式来在头文件中使用另一类而在cpp中再真正include，可以有效梳理结构避免循环引用。 尽可能先根据：cpp对应头文件、C++标准库文件、框架头文件、第三方头文件、项目通用头文件、具体功能头文件的顺序来引用文件，方便理清文件引用结构。 引用头文件时尽可能避免使用相对位置，比如....\\NetDef.h，不利于文件梳理以及理解文件结构。 避免使用反斜线\\来标记路径，在一些编译器会存在异常，应使用斜线/来标记路径。 前置声明 所谓「前置声明」（forward declaration）是类、函数和模板的纯粹声明，没伴随着其定义 前置声明能够节省编译时间，多余的 #include 会迫使编译器展开更多的文件，处理更多的输入。 前置声明能够节省不必要的重新编译的时间。 #include 使代码因为头文件中无关的改动而被重新编译多次。 尽可能的使用前置声明，而非头文件，在CPP中包含对应的头文件 减少编译的时间 内联函数 内联函数的合理使用可提高代码执行效率 当函数只有10行甚至更少时才将其定义为内联函数 谨慎对待析构函数，析构函数往往比其表面看起来要更长，因为有隐含的成员和基类析构函数被调用 包含循环和switch语句的函数内联通常得不偿失 声明了内联也不一定会被编译器内联，虚函数和递归函数不会被正常内联 类内部的函数一般会自动内联。所以某函数一旦不需要内联，其定义就不要再放在头文件里，而是放到对应的 cpp 文件里。这样可以保持头文件的类相当精炼，也很好地贯彻了声明与定义分离的原则。 范例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #pragma once // 头文件区 #include \u0026#34;CoreMinimal.h\u0026#34; #include \u0026#34;UObject/ObjectMacros.h\u0026#34; #include \u0026#34;UObject/UObjectBaseUtility.h\u0026#34; #include \u0026#34;UObject/Object.h\u0026#34; #include \u0026#34;TestObject.generated.h\u0026#34; // 前置声明区 class AActor; class AController; class UPrimitiveComponent; struct FAttachedActorInfo; // 结构体定义 USTRUCT() struct FTestStruct { GENERATED_BODY() public: UPROPERTY() int TestValue = 0; ... }; // 委托定义 // 类体定义 UCLASS(BlueprintType, Blueprintable) class ATestObject : public AActor { GENERATED_BODY() public: ATestObject(); .... }; // 内联函数定义 ... 作用域 命名空间 命名空间将全局作用域细分为独立的, 具名的作用域, 可有效防止全局作用域的命名冲突。 禁止使用using namespace xxx; 禁止使用内联命名空间 1 2 3 4 5 namespace X { inline namespace Y { void foo(); } } X::Y::foo与X::foo是等价的 内联命名空间主要用来保持跨版本的 ABI 兼容性。（一般用不到） 在头文件中使用匿名空间违背了C++的唯一定义原则（One Definition Rule（ODR）） 匿名命名空间和静态变量 内部链接性 意味着你在这个文件中声明的这些标识符都不能在另一个文件中被访问。即使两个文件声明了完全一样名字的标识符，它们所指向的实体实际上是完全不同的。 在 .cpp 文件中定义一个不需要被外部引用的变量时，可以将它们放在匿名命名空间或声明为 static 。 不需要被外部引用的变量 不要在头文件中使用 1 2 3 4 5 6 7 xxx.cpp namespace { int xxx = 0; } static int xxx = 0; 局部变量 函数变量尽可能置于最小作用域，并在变量声明时进行初始化\n离第一次使用越近越好，方便阅读者更容易定位变量声明的位置 局部变量在声明的同时进行显式值初始化，比起隐式初始化再赋值的两步过程要高效，同时也贯彻了计算机体系结构重要的概念「局部性（locality）」。 对象：循环作用域外声明要高效的多 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 int i; i = f(); // 坏——初始化和声明分离 int j = g(); // 好——初始化时声明 vector\u0026lt;int\u0026gt; v; v.push_back(1); // 用花括号初始化更好 v.push_back(2); vector\u0026lt;int\u0026gt; v = {1, 2}; // 好——v 一开始就初始化 // 低效的实现 for (int i = 0; i \u0026lt; 1000000; ++i) { Foo f; // 构造函数和析构函数分别调用 1000000 次! f.DoSomething(i); } Foo f; // 构造函数和析构函数只调用 1 次 for (int i = 0; i \u0026lt; 1000000; ++i) { f.DoSomething(i); } 属于 if, while 和 for 语句的变量应当在这些语句中正常地声明，这样子这些变量的作用域就被限制在这些语句中了，举例而言: 1 while (const char* p = strchr(str, \u0026#39;/\u0026#39;)) str = p + 1; 静态和全局变量 原生数据类型POD（Plain Old Data） Int, char, float等基本类型，POD类型的指针、数组、结构体 静态生存周期变量 全局变量，静态变量，静态类成员变量和函数静态变量 禁止使用类的静态生存周期变量，因为在这种情况下构造和析构函数调用顺序是不确定的，他们会导致难以发现的bug。（对象A依赖对象B，但对象B早于A析构） 不允许用函数返回值来初始化POD变量，除非该函数不涉及任何全局变量（比如 getenv() 或 getpid() ） 函数的作用域内的静态变量除外，毕竟他们的初始化顺序是有明确定义，只会在指令执行到它的声明那里才会发生 同一个编译单元（cpp）内是明确的，静态初始化优先于动态初始化，初始化顺序按照声明顺序进行，销毁则逆序，不同编译单元之间的初始化和销毁顺序则属于未明确行为 quick_exit替代exit，前者不会执行任何析构，也不会执行atexit绑定的任何handlers 如果确实需要一个class类型的静态或全局变量，可以使用单例模式 类 构造函数 不要在构造函数中调用自身的虚函数，这类调用时不会重定向到子类的虚函数实现，即使现在没有被子类重载，将来也是隐患 C++中的虚函数允许在运行时动态绑定，即在运行时根据实际对象的类型来确定调用哪个虚函数实现。这样的动态绑定是通过虚函数表（vtable）来实现的。在构造函数中调用虚函数时，由于对象尚未完全构造完成，可能会导致虚函数表指针尚未被正确初始化，从而导致无法正确调用虚函数的实现。 当虚函数在构造函数中被调用时，如果基类的构造函数中调用了虚函数，由于动态绑定机制，可能会调用派生类中未被构造完全的函数。这样可能会导致对象的状态不正确，甚至产生未定义的行为。 应该尽量避免在构造函数中进行复杂的初始化逻辑，以保证对象正确地构造完成。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 ABaseMonster::ABaseMonster(const FObjectInitializer\u0026amp; ObjectInitializer) : BornLocation(FVector::ZeroVector) , bCanCrouch(true) , LocomotionComp(nullptr) { AutoDestory = true; SpawnedByWaveSpawner = false; MonsterLevel = -1; SpawnType = ETypeofSpawn::None; NetCullDistanceSquared = FMath::Square(8000.f); AkForFoot = CreateDefaultSubobject\u0026lt;UAkComponent\u0026gt;(TEXT(\u0026#34;AkForFoot\u0026#34;)); AkForFoot-\u0026gt;SetupAttachment(RootComponent); AkForFoot-\u0026gt;PrimaryComponentTick.bAllowTickOnDedicatedServer = false; WeaponComponent = CreateDefaultSubobject\u0026lt;UStarsWeaponComponent\u0026gt;(TEXT(\u0026#34;WeaponComponent\u0026#34;)); SetCollisionEnabled(false); if (USkeletalMeshComponent* SKMesh = GetMesh()) { //SKMesh-\u0026gt;VisibilityBasedAnimTickOption = EVisibilityBasedAnimTickOption::OnlyTickPoseWhenRendered; //SKMesh-\u0026gt;bEnableUpdateRateOptimizations = true; } if (AttributeManagerComponent) { AttributeManagerComponent-\u0026gt;SetOwnerType(EAttributeOwnerType::Monster); SetTeamID(FGenericTeamId((uint8)EFactionType::MonsterFac)); } RespawnRate = 1; bBeingCaptured = false; } 构造函数内不要调类似初始化的函数，因为初始化理论上会失败，如果执行失败返回了一个初始化失败的对象，后续怎么使用该对象是比较奇怪的 隐式类型变换 不要定义隐式类型变换，对于转换运算符和单参数构造函数, 请使用 explicit 关键字 隐式类型转换会隐藏类型不匹配的错误. 有时, 目的类型并不符合用户的期望, 甚至用户根本没有意识到发生了类型转换. 隐式类型转换会让代码难以阅读, 尤其是在有函数重载的时候, 因为这时很难判断到底是哪个函数被调用. 可拷贝类型和可移动类型 如果需要显式定义拷贝和移动，否则就把隐式产生的拷贝和移动函数禁掉 如果需要就让你的类型可拷贝 / 可移动. 作为一个经验法则, 如果对于你的用户来说这个拷贝操作不是一眼就能看出来的, 那就不要把类型设置为可拷贝. 如果让类型可拷贝, 一定要同时给出拷贝构造函数和赋值操作的定义, 反之亦然. 如果让类型可移动, 同时移动操作的效率高于拷贝操作, 那么就把移动的两个操作 (移动构造函数和赋值操作) 也给出定义. 如果类型不可拷贝, 但是移动操作的正确性对用户显然可见, 那么把这个类型设置为只可移动并定义移动的两个操作 如果定义了拷贝/移动操作, 则要保证这些操作的默认实现是正确的. 记得时刻检查默认操作的正确性, 并且在文档中说明类是可拷贝的且/或可移动的 1 2 3 4 5 6 7 8 class Foo { public: Foo(Foo\u0026amp;\u0026amp; other) : field_(other.field) {} // 差, 只定义了移动构造函数, 而没有定义对应的赋值运算符. private: Field field_; }; 如果你的类不需要拷贝 / 移动操作, 请显式地通过在 public 域中使用 = delete 或其他手段禁用之. 1 2 3 // MyClass is neither copyable nor movable. MyClass(const MyClass\u0026amp;) = delete; MyClass\u0026amp; operator=(const MyClass\u0026amp;) = delete; 继承 析构函数，虚函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class A { public: A() { p = new int(5); } ~A() { if (p) { delete p; p = nullptr; } printf(\u0026#34;A::~A()\u0026#34;); } protected: int* p = nullptr; }; class B : public A { public: B() { xx = new int(6); } ~B() { if (xx) { delete xx; xx = nullptr; } printf(\u0026#34;B::~B()\u0026#34;); } protected: int* xx = nullptr; }; B b; 多重继承 最多只有一个基类是非抽象类，其他基类都是纯接口类\n菱形继承？？通常意味着设计出了问题\n接口 C++接口\n蓝图接口\nBlueprintImplementableEvent\nBlueprintNativeEvent\n运算符重载 运算符重载会混淆视听，让人误以为耗时的操作和操作内建类型一样轻巧 成员变量 一般不建议把成员变量标记为public，接口变更时更容易出现遗漏。\n并且一个public的变量，对象自身对其更难以控制，不利于约束其读写行为。\n考虑为其增加public的Set与Get相关接口来实现对其的操作。\n比如如下例子：\n1 2 3 4 5 FString SaveKey = StarsSaveGame-\u0026gt;OverrideSaveKey; if (SaveKey.IsEmpty()) { SaveKey = Class-\u0026gt;GetName(); } 如果调用者错误使用了FString\u0026amp; SaveKey = StarsSaveGame-\u0026gt;OverrideSaveKey，那么就会错误修改成员变量。\n如果改成函数的返回则没有这种隐患，会在编译器得到警告：\nBinding r-value to l-value reference is non-standard Microsoft C++ extension\n1 2 3 4 5 FString\u0026amp; SaveKey = StarsSaveGame-\u0026gt;GetOverrideSaveKey(); if (SaveKey.IsEmpty()) { SaveKey = Class-\u0026gt;GetName(); } 结构体 成员变量初始化 如下：用到的指针一定要进行初始化，在栈上创建结构体时，指针并不会被UE初始化，会造成野指针\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 USTRUCT(BlueprintType) struct FDeathInfo { GENERATED_BODY() public: UPROPERTY(BlueprintReadOnly) EDeadCauserType DeadCauserType = EDeadCauserType::Common; /** 击杀者 */ UPROPERTY(BlueprintReadOnly) AActor* Killer = nullptr; /** 被击杀者 */ UPROPERTY(BlueprintReadOnly) AActor* Victim = nullptr; }; 枚举 如果枚举值需要暴露给蓝图，那么他需要在uint8范围内，否则在一些时候会有超出预期的问题。\n如果想要大数值的枚举，又不想在蓝图中直接写死数值，可以考虑使用FName来与之对应，推荐使用表格维护。\n枚举值类型 枚举值应使用enum class定义并标识所使用的存储结构，而不应该直接使用enum。\n枚举值类型理由 enum无法指定底层所使用的数据类型。同一enum的存储结构在不同的编译器下可能不同，有的时候会造成代码的泛用性降低。改为enum class后，可以指定具体的存储结构，使得开发者对其结构更为可控。\nenum存在向整形的隐式转换。隐式转换在一些时候虽然方便了开发者调用，但在错误复制或编码时没有明确的报错，因此不建议使用隐式转换。改为enum class后，如果需要进行转换可以使用static_cast来显式转换。\nenum无法定义重名。enum为了解决这个问题一般需要在枚举值命名中加入类型名，从而导致在一些情境下枚举值较长。而enum class没有这种问题，可以按照设计的枚举值进行命名。\n枚举值命名 枚举值类型命名为以E开头，如EUnitClientType，即使不暴露给蓝图也可以遵循此规范。\n因为枚举值常常直接拿出值用作比较，使用此规范可以区分出枚举值和普通的类型，也方便代码补全工具查找指定枚举。\n枚举值顺序 除非明确地知道修改顺序不会产生影响，否则不要修改枚举的顺序，有可能造成逻辑或者数据不兼容。\n若枚举值的顺序不应被修改（一般是在配置表或其他逻辑中有调用），考虑用=写出其枚举值。\n若枚举值无固定值，则可以默认视为枚举值顺序改变不影响逻辑。\n枚举值举例 1 2 3 4 5 6 enum class EGameType : uint8 { None, Local, Multiple, }; 异常 要注重异常处理，对于有可能报错的函数，可以考虑增加bool的返回值来标识是否正常处理。\n如果有可能有多种错误，建议返回错误码来标识错误类型。\n错误码 使用EErrorId的枚举来表示错误码。\n避免在逻辑中直接写死int32的错误值，在C++中使用错误码，在蓝图或者Lua中使用FName。\n可以使用UErrorIdLibrary中的函数从枚举/int32/FName之间转换。\n判断一个int32是否是OK可以使用UErrorLibrary::IsErrorIdOK。\n判断一个in32是否是指定枚举需要将枚举转为int32判断。\n避免int32转为枚举来判断，有可能出现不是一个合法的枚举而产生非预期结果。\n函数 输入和输出 按值返回，否则按引用返回。避免返回指针，除非它可以为空。\n输入参数放在所有输出参数之前。\n1 void TestFunction(int p1, bool p2, const FString\u0026amp; p3, bool\u0026amp; bOutResult1, FString\u0026amp; OutResult2); 编写简短函数 如果函数特别长，应思考在不影响程序结构的前提下对其进行分割\n编译器优化一方面是消除常用的子表达式。而函数越大，编译器进行辨识的工作量就越大。从而导致编译时间大大增长。\n常量正确性 不要直接进行值传递，避免一次内存拷贝，传递const引用参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 差 - 返回常量数组 const TArray\u0026lt;FString\u0026gt; GetSomeArray(); // 优 - 返回常量数组的引用 const TArray\u0026lt;FString\u0026gt;\u0026amp; GetSomeArray(); // 差 - 传递数组 void TestSomething(TArray\u0026lt;FString\u0026gt; StringArray) {...} // 优 - 传递常引用数组（避免一次内存拷贝） void TestSomething(const TArray\u0026lt;FString\u0026gt;\u0026amp; StringArray) {...} // 优 - 移动语义（避免一次内存拷贝） void TestSomething(TArray\u0026lt;FString\u0026gt;\u0026amp;\u0026amp; StringArray) {...} 若方法不修改对象，将函数标记为常量函数\n常量成员函数承诺不会修改类的成员变量，提高代码的安全性，防止意外的数据修改和潜在错误。\n代码逻辑更清晰，一眼就能看出这是个只读函数\n给编译器优化空间\n1 2 3 4 void FThing::SomeNonMutatingOperation() const { // 若此代码在FThing上被调用，其不会修改FThing } 游戏中的例子：如果PrintAIData函数定位为const，则我们立马能确认函数体内的AIDataPack成员变量进行的都是只读操作，否则还要去判断是否有写入操作。 1 2 3 4 5 6 7 8 9 10 11 void ABaseMonster::PrintAIData(FString\u0026amp; CompName, FString\u0026amp; TreeDescName, TArray\u0026lt;FString\u0026gt;\u0026amp; BBLine) const { /*if (AIDataPack.ComponmentName.IsEmpty()) return;*/ CompName = AIDataPack.ComponmentName; TreeDescName = AIDataPack.TreeDescription; AIDataPack.BlackboardDescription.ParseIntoArrayLines(BBLine, true); MARK_DIRTY？？ } 若循环不修改容器，则在容器上使用常量迭代 1 2 3 4 5 TArray\u0026lt;FString\u0026gt; StringArray; for (const FString\u0026amp; Str : StringArray) { // 此循环的主体不会修改StringArray } 函数重载 若要使用函数重载, 则必须能让读者一看调用点就胸有成竹, 而不用花心思猜测调用的重载函数到底是哪一种. 这一规则也适用于构造函数 1 2 3 4 5 6 class MyClass { public: void Analyze(const string \u0026amp;text); void Analyze(const char *text, size_t textlen); }; 如果函数单靠不同的参数类型而重载 (这意味着参数数量不变), 读者就得十分熟悉 C++ 五花八门的匹配规则, 以了解匹配过程具体到底如何。另外，如果派生类只重载了某个函数的部分变体，继承语义就容易令人困惑。 缺省参数 缺省参数实际上是函数重载语义的另一种实现方式\n对于子类继承的虚函数，不允许使用缺省参数\n虚函数是动态绑定，而缺省参数值是静态绑定。即虚函数是运行时确定类型，而缺省参数值是编译时就确定的。\n如果重新定义的话，会使得程序使用基类虚函数的默认参数，这显然并不是你想要的结果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;iostream\u0026gt; class Shape { public: enum Color { Red, Green, Blue, }; virtual void draw(Color color = Red) = 0; static std::string ColorToString(Color c) { switch (c) { case Red: return \u0026#34;Red\u0026#34;; case Green: return \u0026#34;Green\u0026#34;; case Blue: return \u0026#34;Blue\u0026#34;; default: return \u0026#34;\u0026#34;; } } }; class Rectangle : public Shape { public: virtual void draw(Color color = Green) override { std::cout \u0026lt;\u0026lt; \u0026#34;Rectangle : \u0026#34; \u0026lt;\u0026lt; ColorToString(color) \u0026lt;\u0026lt; std::endl; } }; class Circle : public Shape { public: virtual void draw(Color color) override { std::cout \u0026lt;\u0026lt; \u0026#34;Circle : \u0026#34; \u0026lt;\u0026lt; ColorToString(color) \u0026lt;\u0026lt; std::endl; } }; int main() { Rectangle R; Circle C; R.draw(); //输出：Rectangle : Green //C.draw(); //报错，静态绑定无法继承默认参数 Shape* pr = \u0026amp;R; Shape* pc = \u0026amp;C; pr-\u0026gt;draw(Shape::Blue); //输出：Rectangle : Blue pc-\u0026gt;draw(Shape::Blue); //输出：Circle : Blue // 静态绑定，使用基类的默认参数，完成派生类的动作 pr-\u0026gt;draw(); //输出：Rectangle : Red pc-\u0026gt;draw(); //输出：Circle : Red return 0; } Lambda表达式 不要使用默认捕获（=, \u0026amp;），所有变量捕获都显式写出来\n非异步的lambda表达式除外，例如：Foreach之类的 异步回调Lambda表达式捕获局部变量\nLambda不要捕获UObject裸指针\n如果再等待异步回调执行之前，捕获的UObject裸指针已被GC且在原来的内存上又分配了新的UObject\n如果此时在回调中对该过期了的UObject进行写入，则相当于在一个未知的内存上写入，可能把新的UObject写坏了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 异步回调的情况 UStarsAssetsManager::Instance()-\u0026gt;AsyncLoad(this, MeshInfo.MeshPath, this, [WeakThis, CallBack, CompPtr, MeshInfo, WithCollision](const FSoftObjectPath\u0026amp; ObjectPath) { if (!CompPtr.IsValid() || !WeakThis.IsValid()) return; ... }); // 非异步的情况 SpecialElementNames.Empty(); ForeachRow\u0026lt;FSpecialElementTableRow\u0026gt;([\u0026amp;](const FName\u0026amp; RowName, const FSpecialElementTableRow\u0026amp; Row) { SpecialElementNames.Emplace(Row.Type, RowName); } ); 配置 使用UDataManger来管理所有表格\n需要使用StarsGetDataTable等接口来读表，禁止使用UE自带的表格读取\n我们会对同结构表格在读取时进行合并处理 考虑热更配置的需求，谨慎对配置进行缓存，优先考虑以RowName去查表。\n回调 谨慎使用回调，尤其需要注意是否存在跨帧逻辑与递归逻辑。\n谨慎缓存Delegate，有可能会使得闭包异常。\n比如在Delegate的回调中，修改了这个Delegate，那么捕获的变量会存在异常。 标准库 UE有自己的一套模板库，大部分情况下应该使用UE，下面是可以在UE中使用的标准库。\n应在新代码中使用，在迁移旧代码时也应该使用。原子性（Atomic）将在所有受支持平台上高效推广。 TAtomic 仅实现了部分功能，Epic后续也不会继续进行维护和改善。 \u0026lt;type_traits\u0026gt; 应在旧版UE特性（trait）和标准特性重叠的地方使用。 \u0026lt;initializer_list\u0026gt; 用于支持初始化器（initializer）语法 正则表达式，UE没有自己的正则表达式方案 std::numeric_limits 可以完整使用。 这个头文件中只有浮点比较函数可以使用 排版与格式 命名相关 命名（如类型或变量）中的每个单词需大写首字母，单词间通常无下划线。例如：Health 和 UPrimitiveComponent，而非 lastMouseCoordinates 或 delta_coordinates。\n类型名前缀需使用额外的大写字母，用于区分其和变量命名。例如：FSkin 为类型名，而 Skin 则是 FSkin 的实例。\n模板类的前缀为T。\n继承自 UObject 的类前缀为U。\n继承自 AActor 的类前缀为A。\n继承自 SWidget 的类前缀为S。\n接口的前缀为I。\n枚举的前缀为E。\n布尔变量必须以b为前缀（例如 bPendingDestruction 或 bHasFadedIn）。\n其他多数类均以F为前缀，而部分子系统则以其他字母为前缀。\nTypedefs应以任何与其类型相符的字母为前缀：若为结构体的Typedefs，则使用F；若为 Uobject 的Typedefs，则使用U，以此类推。\n特别模板实例化的Typedef不再是模板，并应加上相应前缀，例如： 1 typedef TArray\u0026lt;FMytype\u0026gt; FArrayOfMyTypes; 即使不暴露给蓝图，也可以遵循此命名规范以适应UE的规范。\n类型和变量的命名为名词。\n方法名是动词，以描述方法的效果或未被方法影响的返回值。\n所有返回布尔的函数应发起true/false的询问，如IsVisible()或ShouldClearBuffer()。\n若函数参数通过引用传递，同时该值会写入函数，建议以\u0026quot;Out\u0026quot;做为函数参数命名的前缀（非必需）。此操作将明确表明传入该参数的值将被函数替换。\n若In或Out参数同样为布尔，以b作为In/Out的前缀，如 bOutResult。\n返回值的函数应描述返回的值.命名应说明函数将返回的值。此规则对布尔函数极为重要。请参考以下两个范例方法：\n1 2 3 4 5 // True的意义是什么？ bool CheckTea(FTea Tea); // 命名明确说明茶是新鲜的 bool IsTeaFresh(FTea Tea); 对于缩写单词，推荐仍然使用首字母大写其余小写的格式\n可以避免陷入什么是缩写什么不是的争议中\nPHP-\u0026gt;Php 对于复杂变量名可以获得更清晰的展示\n如HTTPSubsystem-\u0026gt;HttpSubsystem UE内部变量两者都有，以仅大写首字母为主\n命名范例\n1 2 3 4 5 6 7 8 9 float TeaWeight; int32 TeaCount; bool bDoesTeaStink; FName TeaName; FString TeaFriendlyName; UClass* TeaClass; USoundCue* TeaSound; UTexture* TeaTexture; FPlayerIdentifier PlayerId; 代码格式 一行不超过120个字符\n尽量不使用非ASCII编码，文件编码必须为UTF-8\n缩进使用制表位\\t\n大括号格式必须一致。在Epic的传统做法中，大括号固定被放在新行。请遵循此格式。\n固定在单语句块中使用大括号。例如：\n1 2 3 4 if (bThing) { return; } if-else语句中的所有执行块都应该使用大括号。此举是为防止编辑时出错——未使用大括号时，可能会意外地将另一行加入if块中。多余行不受if表达式控制，会成为较差代码。条件编译的项目导致if/else语句中断时，也会造成不良结果。因此务必使用大括号。 1 2 3 4 5 6 7 8 if (bHaveUnrealLicense) { InsertYourGameHere(); } else { CallMarkRein(); } switch语句\n一定有Default条件，其中包含有break，以防在默认条件后添加新的条件。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 switch (condition) { case 1: ... // 落入 case 2: ... break; case 3: ... return; case 4: case 5: ... break; default: break; } 注释 规范 无所谓英不英文，代码是项目组内的人看的，方便大家读懂就行\n函数注释\n大概功能描述\n各个参数的描述\n返回值的描述\n其他信息：可选择使用 @warning、@note、@see 和 @deprecated 记载额外相关信息。此类注释应在其他注释后单列一行声明。\n1 2 3 4 5 6 7 8 9 10 11 /** * @brief 判断所给定义的道具是否是确定的 * 比如如果是随机品质的定义，就不是确定的 * @param ItemDef 所需检查的物品定义 * @param CheckQualityNum 是否需要检查该道具是否仅有一个品质 * 如果检查并且发现该道具仅有一个品质 * 那么即使定义随机也会认为是唯一的 * @return 返回值的意义 */ UFUNCTION(BlueprintCallable, Category=\u0026#34;Item\u0026#34;) static bool IsItemDefCertain(const FBagItemDef\u0026amp; ItemDef, bool CheckQualityNum); 原则 编写含义清晰的代码： 1 2 3 4 5 // 错误示范： t = s + l - b; // 正确示范： TotalLeaves = SmallLeaves + LargeLeaves - SmallAndLargeLeaves; 编写有用的注释： 1 2 3 4 5 6 7 // 错误示范： // increment Leaves ++Leaves; // 正确示范： // we know there is another tea leaf ++Leaves; 不要对低质量代码进行注释——重新编写这些代码： 1 2 3 4 5 6 7 8 // 错误示范： // total number of leaves is sum of // small and large leaves less the // number of leaves that are both t = s + l - b; // 正确示范： TotalLeaves = SmallLeaves + LargeLeaves - SmallAndLargeLeaves; 不要让代码与注释自相矛盾： 1 2 3 4 5 6 7 // 错误示范： // never increment Leaves! ++Leaves; // 正确示范： // we know there is another tea leaf ++Leaves; TODO 对那些临时的, 短期的解决方案, 或已经够好但仍不完美的代码使用 TODO 注释。\n标记一些未完成的或完成的不尽如人意的地方, 这样一搜索, 就知道还有哪些活要干, 日志都省了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 while (PriorityQueue.Num() \u0026gt; 0) { logger.CheckLoop((__FUNCTION__)); //取出优先队列头 auto\u0026amp; PopData = PriorityQueue.HeapTop(); // 先判空一下，TODO: 后面查一下循环内销毁问题 if (!PopData.SmeltComp.IsValid()) { PriorityQueue.HeapPopDiscard(DataPredicate); continue; } } 其他相关 Sizeof 尽可能的使用sizeof(varname)代替sizeof(type)\n假设varname的类型变了，sizeof(type)大概率会忘改造成bug\n迭代器 前置自增效率更高，少了一次拷贝\n迭代器失效的情况\nTArray\n增加导致的内存重分配\n删除元素\n插入元素\n死循环 无符号整数错误使用导致的死循环 1 for (unsigned int i = 10; i \u0026gt;= 0; --i) { ... } 容器的size()返回类型size_t是无符号整数 1 2 3 4 5 6 std::vector\u0026lt;int\u0026gt; vec; vec.push_back(1); for (auto idx = vec.size(); idx \u0026gt;= 0; idx--) { cout \u0026lt;\u0026lt; \u0026#34;===== \\n\u0026#34;; } while循环，条件永远不满足\n死循环检查工具\nFDeadLockDetector\n死循环时崩掉并打印主线程堆栈 浮点数 判断浮点数是否相等 1 2 3 float f; if (f == 0.2) {} // 错误用法 if (abs(f - 0.2) \u0026lt; 0.00001) {} // 正确用法 std::vector\u0026lt;bool\u0026gt; 尽量不要在vector中存放bool类型，vector为了做优化，它的内部存放的其实不是bool。 空指针 空指针尽量使用nullptr而非NULL\n1 2 3 4 5 6 7 8 9 10 11 12 void func(char*) { cout \u0026lt;\u0026lt; \u0026#34;char*\u0026#34;; } void func(int) { cout \u0026lt;\u0026lt; \u0026#34;int\u0026#34;; } int main() { func(NULL); // 编译失败 error: call of overloaded ‘func(NULL)’ is ambiguous func(nullptr); // char* return 0; } 数值溢出 1 2 3 4 5 6 7 8 const int32 RetryToken = FMath::RandRange(0, INT_MAX); // 这里会随机出负数 ##RandRange 实现 static FORCEINLINE int32 RandRange(int32 Min, int32 Max) { const int32 Range = (Max - Min) + 1; //INT_MAX的情况下，一定溢出 return Min + RandHelper(Range); } 内存 常见问题 避免使用原生数组，尽量使用UE容器\n原生数组无法检查越界 空指针未判空\n空指针导致的崩溃占大多数\n防御性编程\n缓冲区溢出\nsprintf，printf，memcpy，memset，strcat，strcpy等等\n上述函数拷贝内存的时候没有检查是否越界，如果发生越界会把其他不相干的内存写坏，导致无法预料的bug\n1 2 3 4 5 6 void foo() { char szName[10]; int n = 0; strcpy(szName, \u0026#34;asdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdfasdf\u0026#34;); } 返回局部引用\n1 2 3 4 5 int* foo() { int xxx = 0; return \u0026amp;xxx; } 指针未初始化\nUObject成员带UPROPERTY，会被自动初始化为nullptr\n普通指针未初始化，指向任意地址\nif判断已经无效，向野指针内写入数据 注意：USTRUCT的指针成员就算带UPROPERTY也不会初始化位null\n不正确的类型转换\n使用C++的类型转换，避免C类型转换\nstatic_cast，不使用C类型转换\nconst_cast，去掉const限定符\nreinterpret_cast，指针类型和整形或其他指针之间进行不安全的相互转换\n当程序执行不正确的类型转换时，就会发生不可预测的结果。这可能会导致程序崩溃写坏内存或产生不正确的输出。\n1 2 3 4 5 6 7 int main() { int num = 10; double *ptr = (double*)\u0026amp;num; // 不正确的类型转换 *ptr = 5.0; // 写越界 std::cout \u0026lt;\u0026lt; *ptr \u0026lt;\u0026lt; std::endl; return 0; } Memcpy, memset用于非POD类型，把vtable的指针给破坏掉了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class A { public: A() {} virtual void test() { printf(\u0026#34;%d\u0026#34;, nn); } protected: int nn; }; class B : public A { public: B() {} virtual void test() override { A::test(); printf(\u0026#34;B::test, %d\u0026#34;, nn); } }; B b; memset(\u0026amp;b, 0, sizeof(b)); 函数内自销毁，导致后续代码访问或写入成员变量时写坏内存\n宠物切换状态会停掉行为树，而此函数在行为树Task节点中直接执行（Task内停掉行为树）\n行为树Task节点尝试删掉行为树Owner的Actor（危险操作、应延迟一帧执行）\n有自销毁操作时需小心，考虑清楚是否需要延迟一帧\n循环操作没有取引用，导致发生了结构体拷贝\nLambda表达式自销毁，内部引用的捕获变量被销毁后使用引发的内存问题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 TWeakObjectPtr\u0026lt;UWorldManager\u0026gt; thisObject(this); Stars::Message::PvpTrigger triggerData = trigger; GetWorld()-\u0026gt;GetTimerManager().SetTimer(PvPingTimerHandle, FTimerDelegate::CreateWeakLambda(this, [thisObject, triggerData](){ if (!thisObject.IsValid()) return; if (thisObject-\u0026gt;m_GuildManager==nullptr ) { return; } int32 DefenEndTime = AStarsGameState::GetWorldDayZeroTime(thisObject.Get()) + triggerData.defendendtime(); int32 worldTime = AStarsGameState::GetWorldTime(thisObject.Get()); if (worldTime \u0026gt; DefenEndTime \u0026amp;\u0026amp; thisObject-\u0026gt;m_WorldInfo.PlanetPVPStatus != EPlanetPVPStatus::None \u0026amp;\u0026amp; DefenEndTime \u0026gt; 86400) { //防守结束 thisObject-\u0026gt;m_WorldInfo.PlanetPVPStatus = EPlanetPVPStatus::None; thisObject-\u0026gt;m_GuildManager-\u0026gt;OnPlanetPVPStatusStart(EPlanetPVPStatus::None); thisObject-\u0026gt;m_GuildManager-\u0026gt;OnPvpBattleEnd(); SetWorldInfomation(thisObject-\u0026gt;m_WorldInfo); } if (AStarsGameState::GetWorldIntTime(thisObject.Get()) \u0026gt;= triggerData.enttime()) { //完全结束 thisObject-\u0026gt;m_WorldInfo.PlanetPVPStatus=EPlanetPVPStatus::None; thisObject-\u0026gt;m_WorldInfo.PVPStatusStartTime=0; thisObject-\u0026gt;m_WorldInfo.PVPStatusEndTime=0; thisObject-\u0026gt;m_WorldInfo.PVPDefenseStartTime=0; thisObject-\u0026gt;m_WorldInfo.PVPDefenseEndTime=0; thisObject-\u0026gt;m_WorldInfo.IsPlanetBattleStatues=false; thisObject-\u0026gt;m_GuildManager-\u0026gt;OnPlanetPVPStatusStart(EPlanetPVPStatus::None); thisObject-\u0026gt;m_GuildManager-\u0026gt;OnPVPBattleStateChanged(false); thisObject-\u0026gt;m_GuildManager-\u0026gt;OnPvpBattleEnd(); // 这里Lambda表达式被销毁，导致thisObject被销毁 thisObject-\u0026gt;GetWorld()-\u0026gt;GetTimerManager().ClearTimer(thisObject-\u0026gt;PvPingTimerHandle); // 好在这里是读内存不是写，没有造成更坏的情况 SetWorldInfomation(thisObject-\u0026gt;m_WorldInfo); } }), 1, true); 智能指针 智能指针\n一个裸指针使用多个智能指针包裹\n前一个智能指针销毁后导致内存被销毁，后面的再写入导致内存写坏 1 2 3 4 5 int* rawPtr = new int(5); TSharedPtr\u0026lt;int\u0026gt; p1 = MakeShareable(rawPtr); TSharedPtr\u0026lt;int\u0026gt; p2 = MakeShareable(rawPtr); p1 = nullptr; *p2 = 7; TSharedPtr\n引用计数 TUniquePtr\n只能转移所有权 注意循环引用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class B; class A { public: ~A() { std::cout \u0026lt;\u0026lt; \u0026#34;~A\u0026#34; \u0026lt;\u0026lt; std::endl; } TSharedPtr\u0026lt;B\u0026gt; b; }; class B { public: ~B() { std::cout \u0026lt;\u0026lt; \u0026#34;~B\u0026#34; \u0026lt;\u0026lt; std::endl; } TSharedPtr\u0026lt;A\u0026gt; a; }; int main() { TSharedPtr\u0026lt;A\u0026gt; a = MakeShared\u0026lt;A\u0026gt;(); TSharedPtr\u0026lt;B\u0026gt; b = MakeShared\u0026lt;B\u0026gt;(); a-\u0026gt;b = b; b-\u0026gt;a = a; a = nullptr; b = nullptr; return 0; } TWeakPtr\n解决循环引用 容器 循环内删除与添加\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void erase(std::vector\u0026lt;int\u0026gt; \u0026amp;vec, int a) { for (auto iter = vec.begin(); iter != vec.end();) { // 这个正确 if (*iter == a) { iter = vec.erase(iter); } else { ++iter; } } for (auto iter = vec.begin(); iter != vec.end(); ++iter) { // error if (*iter == a) { vec.erase(iter); // error } } } 拷贝到一个新容器中再做循环删除\n使用迭代器\n内存重分配问题\nTArray\nTMap也存在此问题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 struct TestStruct { int a = 0; bool b = false; float c = 0.0f; FString s; ~TestStruct() { UE_LOG(LogTemp, Log, TEXT(\u0026#34;~TestStruct\u0026#34;)); } }; TMap\u0026lt;int, TestStruct\u0026gt; structMap; TestStruct* val1 = \u0026amp;structMap.Emplace(1); TestStruct* val2 = \u0026amp;structMap.Emplace(2); for (int i=0;i\u0026lt;10000;i++) { structMap.Emplace(i); } UE的内存管理 GC机制 UE使用标记清除算法实现GC，当对象的引用链不可达时，GC会回收该对象所占用的内存。在进行GC之前，UE会从根集出发对所有UObject对象进行标记，标记活动对象，并清除所有未被标记的非活动对象。\nGC的触发通常在特定时机，如关卡切换、游戏循环周期等，以避免对游戏性能造成过多影响。\n开发者在UE中需要注意正确管理对象引用，避免出现不必要的长期引用，以确保GC可以正确回收不再使用的内存资源，从而提高游戏性能和稳定性。\n弱指针 通过UObject的弱指针判断其是否在生命周期内\n通过GUObjectArray中的索引来指向具体的UObject\n自增量校验指向的合法性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ATestActor* pActor = GetWorld()-\u0026gt;SpawnActor\u0026lt;ATestActor\u0026gt;(); FTimerHandle handle; GetWorld()-\u0026gt;GetTimerManager().SetTimer(handle, [pActor]() { // 完犊子了，野指针写入！！！ pActor-\u0026gt;Test(); pActor-\u0026gt;Destroy(); }, 2, false); // 强制GC pActor-\u0026gt;Destroy(); CollectGarbage(GARBAGE_COLLECTION_KEEPFLAGS); // 新的TestActor复用原有内存 ATestActor* pActor2 = GetWorld()-\u0026gt;SpawnActor\u0026lt;ATestActor\u0026gt;(); 非主线程中使用UObject或者其弱指针的问题\nUObject是在主线程中被GC掉，所以非主线程中无法预料其生命周期\n所以在非主线程中尽量不访问UObject或其弱指针，在外部主线程中将非主线程需要处理的数据全部备份好，通过Lambda表达式传递进去，任务处理完回到主线程后再访问UObject的弱指针\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 TWeakObjectPtr\u0026lt;UBuildingSearchProxy\u0026gt; WeakThis(this); uint8 Id = WeakThis-\u0026gt;Id; FString SearchInput = WeakThis-\u0026gt;SearchInput; TArray\u0026lt;FName\u0026gt; List = WeakThis-\u0026gt;List; AsyncTask(ENamedThreads::AnyBackgroundThreadNormalTask, [WeakThis, Id, SearchInput, List] { if (!WeakThis.IsValid()) return; TSet\u0026lt;FName\u0026gt; SearchResult; for (const FName\u0026amp; Part : List) { if (Id != IdCounter) break; #if WITH_EDITOR if (Part.ToString().Contains(SearchInput)) { SearchResult.Add(Part); continue; } #endif const FItemTableRow* pRow = UDataManager::FindRow\u0026lt;FItemTableRow\u0026gt;(Part); if (pRow != nullptr \u0026amp;\u0026amp; pRow-\u0026gt;DisplayName.ToString().Contains(SearchInput)) { SearchResult.Add(Part); } } AsyncTask(ENamedThreads::GameThread, [WeakThis, SearchResult] { if (!WeakThis.IsValid()) return; if (WeakThis-\u0026gt;Id == IdCounter) { WeakThis-\u0026gt;PostSearchResult.Broadcast(SearchResult); } WeakThis-\u0026gt;SetReadyToDestroy(); }); }); 成员变量保存UE的接口裸指针\n无法判断其生命周期，应保存UObject的弱指针\n使用的时候再将其Cast为接口指针\n1 2 3 4 5 TWeakObjectPtr\u0026lt;UObject\u0026gt; CauserAttributePtr; //伤害造成者 TWeakObjectPtr\u0026lt;UObject\u0026gt; TakerAttributePtr; //伤害承受者 IAttributeInterface* GetCauserAttributeInterface() const; IAttributeInterface* GetTakerAttributeInterface() const; 网络 Proto 禁止直接缓存消息的Proto结构，内存有可能会被重新分配或回收。\n如果需要保存调用项目封装的接口，或者使用Proto上的CopyFrom接口。\n考虑使用FByteArray或者FByteCompressedArray来快捷保存通用数据。\n日志 现状：该有日志的地方没有，不该有的地方疯狂打，导致出bug时很难通过日志判断。\n日志规范 各功能模块的重要事件，尽量记录（只要不是频繁重复发生）\n无用信息或过于频繁打印的就不要输出了（可通过Verbosity等级控制）\n新增加的模块，尽量记录足够还原现场的日志\n涉及玩家数值的行为，如物品得失、经验获得、货币流通、装备升级等，尽量记录\n如果数量太大可以考虑归并后打印\n避免三字符序列\n在C和C++中，三字符序列是一种特殊的字符序列，用两个问号（??）开头，并由另一个字符结尾。例如，\u0026quot;??=\u0026ldquo;代表#，\u0026rdquo;??/\u0026ldquo;代表\\，等等。这些三字符序列是为了在早期的编码系统中处理一些没有对应字符的情况而设计的，但在现代的编码系统中，这些三字符序列已经不再使用。\n当编译器在转换三字符序列时遇到问题时，就会报错：\u0026ldquo;trigraph converted to \u0026rsquo; \u0026rsquo; character\u0026rdquo;。这意味着编译器无法正确地将三字符序列转换为预期的字符，通常是因为在转换时出现了错误或者遇到了无法识别的三字符序列。\n1 UE_LOG(LogAStar, Error, TEXT(\u0026#34;Particle Type Shrink Error????!!\u0026#34;)); CheckList 裸指针成员变量未初始化为空\n局部变量未初始化使用\n数组越界\n内存拷贝缓冲区溢出\nUObject需要强引用的未用UPROPERTY包裹\nUObject不需强引用的没有用弱指针\nUSTRUCT中包含UObject成员未用UPROPERTY\n成员变量保存UE接口的裸指针\n构造函数内调用虚函数\n基类析构函数未声明成虚函数\n指针未判空使用\n异步回调捕获所有\u0026amp;,=\n异步回调Lambda表达式传入裸指针\n异步回调未判断Upvalue的生命周期\n异步回调Lambda表达式引用捕获局部变量\nLambda表达式自销毁导致的Upvalue生命周期问题\n使用异常机制\n返回局部变量的引用或指针\n手动管理内存的申请和回收未成对\n不正确的类型转换\n容器的循环内删除错误\n智能指针循环引用\nTArray取值未判断边界\nTArray写入未判断边界\nTArray前值指针或引用在触发内存重分配后野掉\nTMap前值指针或引用再触发内存重分配后野掉\nTMap取值前未判断是否存在\n非主线程中对UObject的使用\n使用类对象的静态存储周期变量\n出现菱形继承\n间接无限递归调用导致栈溢出\n死循环\n关键事件未加日志\n该用PushModel未用\nMemset, memcpy用于非POD结构\n浮点数判断是否相等导致的问题\nUE_LOG传入的参数类型不匹配导致崩溃\n设置的Timer没有回收，导致Timer泄漏\n除0问题\n循环操作该用引用时没有用引用\n尽量使用UE内置typedef的基础数据类型（如：int32, int64，不要使用long, size_t之类的）\n可复制变量不能是Public，不能是蓝图可写\n配置表所有的引用都要使用软引用\n参考文献 https://docs.unrealengine.com/4.27/zh-CN/ProductionPipelines/DevelopmentSetup/CodingStandard/\nhttps://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/\nhttps://www.zhihu.com/question/26901409/answer/1858690571\nhttps://github.com/Icassell/UE4-Style-Guide-1\n","date":"2021-05-10T21:34:36+08:00","permalink":"https://boiltask.com/knowledge/client-style-guide/","title":"客户端编程规范"},{"content":"参考下文配置Protobuf：\nhttps://github.com/protocolbuffers/protobuf/tree/master/src#c-installation\u0026mdash;windows\n所需环境 推荐提前安装以下环境：\nWindows 10 Git Cmake Visual Studio 2019 生成工具 在https://github.com/protocolbuffers/protobuf/releases/latest下载protobuf生成工具。\n文件应形如protoc-$VERSION-win32.zip，解压其中的bin/protoc.exe，放于Dep/protobuf/bin下。\n编译依赖 参考下文编译所需依赖：\nhttps://github.com/protocolbuffers/protobuf/blob/master/cmake/README.md\n在https://github.com/protocolbuffers/protobuf/releases/latest下载protobuf源文件。\n文件应形如 protobuf-cpp-[VERSION].tar.gz。\n解压全部文件到文件夹中，此处以D:\\Protobuf为例。\n打开cmake-gui，选择source code文件夹为D:\\Protobuf\\cmake，build the binaries文件夹为目标文件夹，此处以D:\\Protobuf-build为例。\n点击Configure，选择Visual Studio 2019。\n取消配置中的所有勾选。\n留意CMAKE_INSTALL_PREFIX值，此值为之后运行安装后目标文件存放位置。此处以D:/Protobuf-install为例。\n点击Generate生成解决方案，之后Open Project打开解决方案。\n选择MinSizeRel与x64，之后生成解决方案。\n右键INSTALL，选择生成，目标文件会被生成在前面所配置文件夹中。\n复制D:/Protobuf-install/include到项目/protobuf/include。\n复制D:/Protobuf-install/lib到项目/protobuf/lib。\n配置项目 在Visual Studio的项目中，参考如下方法配置Protobuf。\n配置头文件引用 右键项目属性，点击C/C++，在附加包含目录之中，填入protobuf头文件目录，如：\\protobuf\\include。\n配置静态链接 右键项目属性，点击链接器，在附加库目录之中，填入protobuf依赖文件目录，如：\\protobuf\\lib。\n展开链接器一栏，选择输入，在附加依赖项之中，填入protobuf依赖文件名，如libprotobuf.lib与libprotobuf-lite.lib。\n","date":"2020-07-18T17:39:54Z","permalink":"https://boiltask.com/knowledge/cpp-protobuf/","title":"Windows下C++版本Protobuf使用方法"},{"content":"修饰普通变量 修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。\n普通变量，当程序执行到它的定义处时，为其在栈上分配空间，在函数执行结束时被释放掉。使用static修饰变量，可以使得函数中的值保存至下一次调用。\nstatic修饰的静态局部变量只执行初始化一次，而且延长了局部变量的生命周期，直到程序运行结束以后才释放。\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; using namespace std; void staticLocalVar() { static int a = 0; // 运行期时初始化一次, 下次再调用时, 不进行初始化工作 cout \u0026lt;\u0026lt; \u0026#34;a=\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; ++a; } int main() { staticLocalVar(); // 第一次调用, 输出a=0 staticLocalVar(); // 第二次调用, 记忆了第一次退出时的值, 输出a=1 return 0; } 修饰普通函数 表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为static。\n修饰成员变量 修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。\nC++中需要一个数据对象为整个类服务，可将其定义为静态数据。\n比如一个类的所有对象都要调用的值，设为static后只需要修改这个值，就能使得所有对象都可以使用新值。\n修饰成员函数 修饰成员函数使得不需要生成对象就可以访问该函数，但是在static函数内不能访问非静态成员。\nstatic与const static const等价于const static，修饰成员变量把二者结合起来理解。\n不可以同时用const和static修饰成员函数，二者的含义矛盾。\n","date":"2020-03-23T05:30:15Z","permalink":"https://boiltask.com/knowledge/cpp-static/","title":"C++中static关键字用法总结"},{"content":" 当用const进行修饰时，根据const位置的不同有三种不同效果。\n判断的标准是：const修饰谁，谁（在const后面）的内容就是不可变的。\n修饰变量 const int a;，表示变量不可被改变。\n修饰指针 分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）。\nconst int *p = \u0026amp;a; *p不可变，*p是p指向的内存单元的内容，所以*p不可变也就是p指向的内存单元的内容不可变。p是可变的，即p指向的内存单元（变量）是可变的，但是p指向谁，谁的值就不可变。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include\u0026lt;iostream\u0026gt; using namespace std; int main(){ int a = 10; const int *p = \u0026amp;a; //不可以用*p改变a的值 printf(\u0026#34;a = %d \\n\u0026#34;, a); //*p = 20; //语法错误，*p不可被修改 a = 40; //可以直接赋值进行修改 printf(\u0026#34;a = %d \\n\u0026#34;, a); int b = 11; p = \u0026amp;b; printf(\u0026#34;b = %d \\n\u0026#34;, *p); int *q = \u0026amp;a; *q = 20; //可以用*q改变a的值 printf(\u0026#34;a = %d \\n\u0026#34;, a); a = 30; //给a赋值也可以修改a的值 printf(\u0026#34;a = %d \\n\u0026#34;, a); return 0; } \u0026gt;a = 10 a = 40 b = 11 a = 20 a = 30 int* const p = \u0026amp;a; const修饰p，指针p是不可变的，即p指向的内存单元不可变。p的指向不可变，p指向的内存单元的内容可以变。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include\u0026lt;iostream\u0026gt; using namespace std; int main(){ int a = 10; int* const p = \u0026amp;a; //p的指向不可变 printf(\u0026#34;a = %d \\n\u0026#34;, a); *p = 20; //可以修改p指向的内存单元的内容 printf(\u0026#34;a = %d \\n\u0026#34;, a); int b = 11; //p = \u0026amp;b; //语法错误 printf(\u0026#34;b = %d \\n\u0026#34;, b); *p = b; //修改了a的值 printf(\u0026#34;a = %d \\n\u0026#34;, a); return 0; } \u0026gt;a = 10 a = 20 b = 11 a = 11 const int* const p = \u0026amp;a; const修饰了*p和p，所以p指向的内存单元和p指向的内存单元的内容都不可变。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include\u0026lt;iostream\u0026gt; using namespace std; int main(){ int a = 10; const int* const p = \u0026amp;a; //const修饰了p和*p printf(\u0026#34;a = %d \\n\u0026#34;, a); //*p = 20; //不可修改p指向的内存单元的内容 printf(\u0026#34;a = %d \\n\u0026#34;, *p); int b = 11; //p = \u0026amp;b; //不可修改p的指向 printf(\u0026#34;b = %d \\n\u0026#34;, b); return 0; } \u0026gt;a = 10 a = 10 b = 11 修饰引用 指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include\u0026lt;iostream\u0026gt; using namespace std; int main(){ int a = 10; int \u0026amp;r = a; //定义了a的引用r printf(\u0026#34;a = %d \\n\u0026#34;, r); r = 20; //也修改了a的值 printf(\u0026#34;a = %d \\n\u0026#34;, a); //int \u0026amp;rm = 3; //语法错误，引用不可直接绑定常量 const int \u0026amp;rm = 3; printf(\u0026#34;\u0026amp;rm = %d \\n\u0026#34;, rm); //常量可以绑定const引用 /* 编译器分配内存空间，把rm放在符号表中 int temp = 3; const int \u0026amp;rm = temp; */ int b = 5; const int \u0026amp;rb = b; printf(\u0026#34;b = %d \\n\u0026#34;, rb); //rb = 6; //const修饰引用不可更改 double p = 3.1415; //int \u0026amp;rp = p; //引用类型需与绑定类型相同 const int \u0026amp;rp = p; //可以绑定到const引用上 printf(\u0026#34;\u0026amp;rp = %d \\n\u0026#34;, rp); //常量可以绑定const引用 /* double p = 3.1415; int temp = p; const int \u0026amp;rp = temp; */ return 0; } \u0026gt;a = 10 a = 20 \u0026amp;rm = 3 b = 5 \u0026amp;rp = 3 const引用的目的,禁止通过修改引用值来改变被引用的对象。\n没有const reference，因为引用本身就是 const pointer。\n普通引用相当于int* const e const int \u0026amp;e相当于const int* const e 修饰成员函数 说明该成员函数内不能修改成员变量。\n有const修饰的成员函数，对数据成员只能读取，没有const修饰的成员函数，对数据成员可读可写。 const对象可以调用const成员函数，不能调用非const修饰的函数。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; using namespace std; class Test { public: Test(int v) : a(v) {} int getA() { return a; } int getAc() const { return a; } int a; }; int main() { Test test(2); cout \u0026lt;\u0026lt; test.getA() \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; test.getAc() \u0026lt;\u0026lt; endl; return 0; } \u0026gt;2 2 相当于，C++对类的成员函数数中的this指针做了隐藏。本质上，const修饰的是被隐藏的this指针所指向的内存空间，修饰的是this指针（const Class *this）。\n","date":"2020-03-23T05:00:00Z","permalink":"https://boiltask.com/knowledge/cpp-const/","title":"C++中const关键字用法总结"},{"content":"今天是2020年3月8日的0点，拖了小半年的2019总结，终于在2020年都已经过去四分之一的时候开始动笔了。说起总结2019，其实在去年国庆左右的时候就已经开始计划了，零零散散写了些东西。本来计划元旦认真总结一下的，结果一拖又拖了好久。但，再不总结恐怕就再也没有兴致了，所以还是来动笔吧。\n2020年对大多数人来说都是一个不平常的年份，而2019年对我来说，比之更有过之而无不及。从这一年中零零散散，短至一句话，长至一篇文的随笔之中，也能感受到这一年来的心路历程。虽然可能很多东西已经想不到当时的背景，没办法完全记录下来当时的所想了，但是总还能给历史留下点见证。\n2019的故事，自然从元旦开始说起。2019年1月1日，离开了租住了半年的房子，一时间突然特别伤感。回忆起2019，伴随着考研、实习、过年、毕设、求职、入职、进京等一系列的故事。考研的失败对我来说是个不太愿意聊起的事情，这个故事掺杂了很多话题。\n1月2号，是踏上去郑州实习的日子。虽然不喜欢智游的安排，但是不得不说，在智游的几周，我学到了我想要学习的知识。作为酝酿毕业设计良久的我，自然希望能够系统的学习一下前端的知识。在智游的学习，虽然浅显，但是确实给了我入门很大的帮助。后面能够顺利的驾驭Vue等框架，也有很多这段经历的功劳。\n顺嘴说一句，确实想再试试智游楼下的竹筒饭了。\n学着学着，过年了，2019年的春节其实倒也没什么说的。只不过伴随着考研成绩的出炉，给了人生道路又一个抉择。其实在人生的大方向上，从幼儿园到到目前为止还基本没怎么变过。幼儿园到小学五年级之间喜爱美术等艺术性的领域，小学五年级到初三喜欢小说剧本等文艺性的领域。这其中，又掺杂着对计算机魅力的向往。再往后，突然发现电子游戏这一行业，完美契合一路以来的心路历程。既满足了对计算机的向往，又满足了对文学性艺术性的追求。\n所以，不挺好的吗。\n然后，开学了。在得知没办法在智游继续学习前端知识之后，自然不准备在智游熬时间了。于是待了一天之后选择了回学校，准备毕业设计和求职。\n我现在对学弟学妹们说没有什么追求的话，毕业设计随便做做就好了。那么，对于我来说，为什么想这么认真地准备一下毕设呢。首先，自然是来源于大一以来对OJ系统的好气。再来，正如我那天写下的。可能，这是我最后一次花这么久的精力去做一个网站。\n人的一生，是要学会舍得的。我自认在这方面做得并不好，尝尝不舍得扔垃圾，考研资源这么久过去了也没舍得删除。但是在人生的选择上，既然百分百选择了游戏行业，那么其他领域可能注定不会有太大成就了。毕竟，我自认综合天赋不高。\n事实证明CodeOJ项目，足够给我的大学生活画上一个不一定完美但完整的句号。从起初的项目构思，到理论验证，实际开发，测试与维护。一段段的心路历程，回忆起来都是难忘的。\n犹记得在清明节之前，我甚至没决定好后台采用什么技术。还是假期去南京的火车上，抱着Ipad找相关资料，决定了使用PHP框架PhalApi来做后台服务器。\n说起来Ipad虽然没给考研带来太多帮助，但确实给毕设和后面的学习提供了很大的帮助。\n前端的Ivew框架来源于最早寻找好看的前端模板时，发现了一套易用、美观还组件丰富的UI框架。包括Vue也是当时维护HPUACM官网时，自己研究了一下简单的用法。\n整个开发过程吧，也算体会了一下简单的全栈工程师的感觉。回忆起来，也是一种乐趣。每天晚上搞个通宵，特别是当时前期晚上还断电，于是又研究怎么延长一波晚上的工作时间。唉，那种不用考虑其他事情，一心只需要把自己喜欢的东西做完的机会，恐怕是不多了。\n到了毕设后期临近毕业，又开始研究了一下小程序。也是赞叹微信能做出一个这么简单易用的平台，也对互联网环境起着引领的作用。包括我自己，也对基于微信小程序的小游戏很看好。依托于微信的用户量，一个小型精品很容易在朋友圈之间流行开来。\n再然后，三方协议的催促，开始尝试投一波简历。虽然四月份网易的笔试通过，面试一塌糊涂的经历给了一定的心理负担。但是最终好歹还算顺利拿到了Offer。\n所以，工作的事情也不用愁了。\n那么，毕业吧。\n毕业照拍的还算难忘，与同学们共同生活了四年。大学四年时间，人生最美好的时光之一。很幸运，能和这群人一起度过。\n再然后，东西打包收拾回家。过了一周，启程前往北京。\n北京这个城市给我的体验一直不太好，并没有给我向往的感觉。但是，进了北京，却依旧能感受到这个城市的魅力。看着以往一二十年，只能在电视网络上知晓的建筑，在自己的眼前飘过。那种感觉，还是别有一番滋味。\n入职，前一个月迷迷糊糊地度过了。好在老大与项目组大佬们的帮助下，慢慢熟悉了整个的工作流程。改改BUG，问问问题，也就度过了又一两个月。到了临近国庆节，开始接到了工作以来的第一个新功能。\n密藏宝箱系统，整个制作来说不算特别困难，但也确实在很多点上有所卡顿。所以，国庆节注定是要加个小班了。但是，当完成的时候，内心的喜悦自然也是不用提的。不管怎么说，这也是自己进入游戏行业的里程碑事件。\n再往后，机器人的修改，NPC的修改，慢慢地能感受到自己的提升，也继续沉醉着游戏行业的魅力。\n所以，2019大抵也就是这样了。\n说他特殊吧，确实挺特殊的。正如2015年那样。2015衔接了高考与大学，2019衔接了大学与工作。说起来是挺分裂的两种感受，高考之前的紧张与迷茫，大学之后的自由与梦想；毕业之前的懵懂与无措，工作之后的憧憬与拼搏。\n但是说他普通吧，好像也很普通。只是一个年份，发生大事随便写写几千字也足以记录了。况且，比起2020的广泛性特殊来说，2019好像也算不得什么。这么想，晚点写总结，可能和早点写的感受确实不会完全一样。不好说孰是孰非吧，但感觉下次这种东西还是尽量早些写吧，毕竟晚点有啥事想补充大不了再说呗。\n这半年个人文件夹数据大小增加缓慢，也确实是没产出什么自创性的东西了。也许，后面有机会要继续进行适度的创作。毕竟灵感这种东西，不经常挖掘真的会越来越枯竭的。\n国庆节假期的时候，站在天安门广场上，就有一种很特殊的情绪。那一瞬间，你就感觉前几天还是世界焦点的地方，此时此刻就在你的面前。仿佛这一瞬间，你自己就变成了世界的焦点。但愿，有朝一日能给这个世界留下一笔属于我的记忆。\n剩下的，就是零零星星根据留下的只言片语再说几句了。唉，真的是可惜很多脑子里的东西没办法全部写下来。\n很多事情不是技术可以搞定的。比如BiliBili的弹幕功能，做出来可能很容易，但是培养一个弹幕社区与文化，却需要更多的努力。正是我认为游戏行业，不单单是技术引领的。技术的发展，给了游戏设计者更多的发挥空间。但对于同时代的玩家来说，只需要使用此时代已有的技术，就足以让其快乐了。这个，也是游戏制作者需要正视的一个问题。一个游戏是否好玩，有的时候并不在于技术是否高端，而要看技术是否完美解决了设计者的需求。\n世界上的很多事情应该都不是纯粹的技术问题，可惜我自己是没什么头脑的，只能自己尝试去努力创造自己的价值。\n现在还年轻，还能有打小怪兽的梦，所以就还挺开心的。想想很多人，可能不知不觉间就忘记了自己在追寻什么。或者说，变得更为“佛系”，无所谓未来追寻什么。我是感觉，能有一个努力的目标，并且这个目标对于世界来说是有正向价值的，就挺好的。\n六岁那年，在门口小摊位抽个次奖，一毛钱一次。然后第一次里面什么都没有，第二次的时候抽到了一个飞镖，三个角的那种，还能调整角度。很高兴，然后绑了一个绳子每天甩着玩。这段故事应该之前也说过，一些奇思妙想也是从小就根深蒂固地。包括目前，也能零零星星想起来小时候的一些想法，还有思考时候的一些状态和场景。虽然从目前的眼光来看，很多想法可能并没有参考价值，设置随便用系统地方法去设计都要更好一些。但有想法这件事情本身，就足够我难忘一辈子了。\n作为游戏制作者，只要人家肯玩就应该谢谢人家，至少在玩的时候，玩家此时是比起那些知名作品更愿意在你身上花费时间的。所以要珍惜每个愿意尝试了解你的玩家，尽量不要亲手毁掉这一份信任。这，也是我在此愿意许下的承诺。\n有的时候，确实感觉到了自己的平庸。不光是生理上的，而且是教育等各方面的平庸。但是，好在游戏行业并不一定是个非要争第一的行业。就好像去年玩过一段时间的《家国梦》，虽然卸载很久不玩了，之后可能也不会再去下载。但玩的那段时间，确实给了我快乐和一定的思索。\n所以，努力提高自身综合素质。尽量能给大家带来一些快乐和情感，我想我的人生价值也就实现了。当然，在这个过程中能让自身和在乎我的人以及我在乎的人幸福，那就再好不过了。\n想说的时候可以说，不想说的时候可以不说。这，也就是日志的魅力了。2019就总结到这吧，2020年再见了。\n我有预感，2020年也同样是一个值得总结的一年。\n也许这一年之后，可以加大日志的频率。没事写写的话，若干年之后再看一定是别样的感受。\n","date":"2020-03-07T17:17:48Z","permalink":"https://boiltask.com/record/202003081/","title":"从大学到工作 – 我的2019总结"},{"content":"原理15 记忆和技巧 在游戏设计领域有很多游戏种类，有更广义的游戏分类方法把游戏分为记忆游戏和技巧游戏。\n在记忆游戏中需要用到试错法、记忆识别、本能反应（平台跳跃游戏）以及对游戏本身的掌握。技巧游戏需要体能或精神上的实力和条件来完成。许多游戏在特定情况下对这两种类型都有涵盖。\n记忆游戏可能会在玩了一段时间之后让玩家感到无聊，解决这个问题的方法是在保持游戏机制、故事和结果不变的前提下为游戏加入一些随机性。\n原理16 “极小极大”与“极大极小” 与“最小/最大化”（Min/Maxing）不同，“极小极大”（Minimax）指出，在一个零和博弈中，每个博弈者会选择一个能最大化他们回报的混合策略，由此产生的策略和回报的组合是帕累托最优的。\n在经济博弈论中，极小极大原理常被用来减低机会成本（也就是后悔）。\n极大极小原理解决的问题是玩家致力于防止最差的后果，想要避免错误决定导致的最坏结果。\n在数学上，极小极大算法是一个递归算法，用来在参与人数确定（通常是两个）的博弈中做出下一步的决定。\n极小极大也被应用于没有其他对手，但结果取决于不可预知事件情形下的决策。在这样的情形下，可能出现的结果与有两个参与者的零和博弈类似。\n原理17 纳什均衡 纳什认为，在任意一个混合策略博弈中有这样一个策略组合，在该策略组合上，任何参与人都有有限的选择；而当所有其他人都不改变策略的时候，没有人会改变自己的策略，因为改变策略会导致该博弈者得到的得益降低，那么这个策略组合就是一个纳什均衡。\n纳什均衡原理可用于预测博弈者在他们最优策略的基础上互动的结果。\n纳什均衡可以通过数学方法，基于回报矩阵（payoff matrix）得出。\n囚徒困境博弈\n假设有两个小偷A和B联合犯事、私入民宅被警察抓住。警方将两人分别置于不同的两个房间内进行审讯，对每一个犯罪嫌疑人，警方给出的政策是：如果一个犯罪嫌疑人坦白了罪行，交出了赃物，于是证据确凿，两人都被判有罪。如果另一个犯罪嫌疑人也作了坦白，则两人各被判刑8年；如果另一个犯罪嫌人没有坦白而是抵赖，则以妨碍公务罪（因已有证据表明其有罪）再加刑2年，而坦白者有功被减刑8年，立即释放。如果两人都抵赖，则警方因证据不足不能判两人的偷窃罪，但可以私入民宅的罪名将两人各判入狱1年。\n收益矩阵\nA╲B 坦白 抵赖 坦白 -8，-8 0，-10 抵赖 -10，0 -1，-1 可以看出对于个人而言，坦白的收益总比抵赖要高。\n关于案例，显然最好的策略是双方都抵赖，结果是大家都只被判1年。但是由于两人处于隔离的情况，首先应该是从心理学的角度来看，当事双方都会怀疑对方会出卖自己以求自保、其次才是亚当·斯密的理论，假设每个人都是“理性的经济人”，都会从利己的目的出发进行选择。这两个人都会有这样一个盘算过程：假如他坦白，如果我抵赖，得坐10年监狱，如果我坦白最多才8年；假如他要是抵赖，如果我也抵赖，我就会被判一年，如果我坦白就可以被释放，而他会坐10年牢。综合以上几种情况考虑，不管他坦白与否，对我而言都是坦白了划算。两个人都会动这样的脑筋，最终，两个人都选择了坦白，结果都被判8年刑期。\n囚徒困境中，在都选择背叛时，任何一个人单独改变策略都不会使自己的收益更高，所以都背叛就是纳什均衡点。相反在都合作的情况下，任何单独的改变状态都会增加自己的收益，所以合作不是纳什均衡点。\n原理18 帕累托最优 许多博弈论的例子都是零和命题——其中参与一方的收益来自于另一方的损失。然而，也有一些情况下，玩家可以在不影响其他玩家地位的情况下让自己的地位上升。意大利经济学家维尔弗雷多·帕累托（Vilfredo Pareto）在财富和收入分配等领域研究了这样的关系。人们以他的名字命名了他的发现。\n当有人得到了一定数量的货物、金钱、土地等，而且是从一个人手上转移到了另一个人手上（比如通过销售），这就是“帕累托交换”（Pareto shift）。\n如果一个交换过程在改进了系统中一个人的状态的情况下没有直接损害系统中其他人的利益，这个变化就是一个“帕累托改进”（Pareto improvement）。\n当一个角色扮演游戏（roleplaying games，RPG）中的角色升级自己的能力和技能时，这就是一个帕累托改进。另一方面，如果一个玩家偷了另一个玩家的装备，这就不是一个帕累托改进，因为这会让被偷的一方能力削弱。\n当一个系统达到了没有帕累托改进的余地的状态，它就达到了“帕累托最优”（Pareto optimality），又称“帕累托效率”（Pareto efficiency）。这时，系统中的任何一个交换都是零和的。\n帕累托最优的一个重要特性是它不一定是一个公平合理的分配，它也并不意味着这个分配是可能的分配方案中最好的。它只是说明当前的选择已经被扩展到了没有任何人可以在不损害其他人利益的情况下进行改善的地步。\n“占优策略”（参见原理84“占优策略”）并不总是与帕累托最优一致。在囚徒困境中，占优策略（也就是背叛）就跟帕累托最优（双方合作）不一致。这是因为双方“保持沉默”相当于一系列同步的帕累托改进——每人都在不使对方状况变差的情况下让自己的状况变好了。没有人能在不让对方变差的情况下让自己的状况变好（要让自己的状况变好只能背叛对方，也就意味着对方的状况变差）。\n在合作的游戏或系统中，帕累托最优是一个理想的目标。\n在竞争的游戏中如果达到了帕累托最优，则往往意味着僵局或不可避免的冲突。\n帕累托改进（及其最终带来的帕累托最优）在资源平衡的游戏机制中也经常被使用。达到帕累托最优并不意味着这就是最佳组合，只是表示所有的资源都被有效地使用了。\n原理19 得益 得益（Payoff）是指在游戏中一个决定所带来的产出或结果，不管是正面的还是负面的，不管它如何被计量。\n不是所有的玩家玩游戏都是出于追求同样的回报（巴特尔的玩家分类理论）。\n假定游戏中的所有玩家都是理性自利的，也就是说每个人的行为都以获得自己的最佳回报，并且将其最大化为目的，根据玩家自己的价值体系，每个决定对玩家带来的影响都是合理的。\n在博弈论中，得益可被分为基数的和序数的。\n基数得益（Cardinal Payoffs）是固定量的值。\n序数得益（Ordinal Payoffs）采用得益产生的顺序而不在于其数值的大小来描述结果。就像竞赛一样，排序名次比时间和距离更重要。\n当游戏是同步进行的，也就是说，当一个玩家必须在不知道其他玩家会怎么做的情况下采取行动时，通常会有一个正则形式的表格来显示得益，这样我们就可以比较游戏双方所做选择的结果。\n在平衡一个游戏的得益时需要注意的一点是：在决策过程中的理性自利（没有与其他玩家之间的可信承诺）通常会给玩家带来最坏的结果。\n在“囚徒困境”中，我们要注意尽管这个游戏看起来是基数得益的，它实质上却是序数得益的。因为唯一重要的一点是它们的顺序保持不变。\n原理20 囚徒困境 囚徒困境（Prisoner’s Dilemma）是一个简单的博弈，它解释的是为什么两个博弈者在博弈时会分别作出不是对自己最有利的，却能通过合作达成一个更好结果的选择。\n博弈可以按照传统方式进行，如单一决策，或重复决策，产生基于过去结果的行为模式。\n如果两个博弈者连续完成了多次囚徒困境的情景，并基于对方之前的行为各自形成了一个对对方的看法，这两人都将开始基于对方的行为来规划自己的策略。连续玩N（N已知）次游戏时，最合理的决定是每一次都背叛对方。然而在实践中，大多数人都不会超理性到能够意识到对他们来说能得到最大利益的做法是：每一次都与对方合作，然后在最后一次背叛对方。假定他们会这么做，这也会让他们推断对方也与他们一样理性，也会做出同样的事情。于是他们在倒数第二轮选择背叛，如此循环往复，回到开头。而如果N是未知的，这个做法就不再是游戏的“占优策略”，而是一个“纳什均衡”。\n罗伯特·阿克塞尔罗德（Robert Axelrod）提出了博弈者的策略要获得成功的4 个必要条件。\n要友好（Nice）。不要首先背叛（尽可能的合作）。 不嫉妒（Non-Envious）。不要试图比对方得到更多（优化平衡积分）。 要报复（Retaliating）。当对方背叛你时一定要报复（不要永远合作）。 要宽容（Forgiving）。报复之后要改回合作（如果对方不背叛你的话）。 威廉姆斯·普雷斯（William Press）和弗里曼·戴森（Freeman Dyson）提出了一个被称为“零行列式策略”（Zero-Determinant Strategy）的新方法，该方法认为一个博弈者可以通过让对方相信他们会做出某个特定选择的方式来控制博弈，该博弈者通过利用假信息来从对方那里获得好处。\n原理21 解谜游戏的设计 设计师斯科特·金（Scott Kim）这样定义“谜题”（puzzle）：“有趣的东西，并且有一个正确的解答”。这个定义尽管模糊，却至少提出了一个定义谜题的有用元素：它是有解的。\n一个好的谜题对它的受众而言既不能太容易也不能太难。要让一个谜题游戏做到这一点，一个好的方式就是面包屑式（breadcrumbs）的引导。例如在数独（Sodoku）或纵横填字（crossword）游戏中，随着一个一个空格被填上，玩家也就得到了对剩下的空格更多的提示，那些剩下的空格也就变得越来越好填了。\n一个好的谜题应该需要一个聪明、智慧的解决方法，而不是通过简单的蛮力就能解决。\n一个谜题的产生可以是随机的，但当玩家开始解答它时，它必须是确定的。\n最后，一个好的谜题必须让玩家知道目标是什么，他们需要进行怎样的操作来达成这个目标。谜题”的设计师通过模糊化规则来增加解谜的难度，但是这样的谜题是不公平的。\n当我们设计一个谜题时，要确保：\n在难度上要让玩家保持在一个“心流”的状态 需要一个聪明、智慧的解决方法 是确定的 从其目标和机制上来说是明确而公平的 原理22 石头剪刀布 石头剪刀布（Roshambo），是一种只需要通过手势参与的、同步的、半随机的，零和博弈。\n石头剪刀布可以通过算法对对手的行为模式及其发展趋势进行分析，基于马尔科夫链（Markov Chains）、战略预测和随机数的算法来选择应对的手势。\n这种循环的制约关系已被应用于其他游戏中，以防止占优策略的演进，保证游戏过程中各种类型的元素保持同等的价值。\n石头剪刀布有时也被一些不愿意去探索更有趣的、创新或独特的方法来平衡游戏机制的设计师当作偷懒的依托。如果石头剪刀布方式是我们针对功能设计的唯一策略，我们要小心了。\n原理23 7种通用情感 游戏设计师往往致力于唤起玩家的情感，他们花费很大的精力去研究“兴趣曲线”，以及设法保持玩家对游戏的注意力。\n有7种通用的情感表达是世界的每一种文化公认的。\n惊讶（Surprise） 轻蔑（Contempt） 愤怒（Anger） 喜悦（Joy） 恐惧（Fear） 悲伤（Sadness） 厌恶（Disgust） 情感总是无意识的、稍纵即逝，但可以很容易地通过人们面部的变化看出来。这是情感和情绪的一个显著区别，后者持续的时间更长，并且可以被隐藏和掩饰。\n原理24 斯金纳箱 预测玩家的行为是游戏设计师最基本的需求。其中一个被过分广泛使用的理论流派——行为主义。\n斯金纳做了如下尝试：\n老鼠每次按下杠杆，就给它食物作为奖励；\n老鼠每X次按下杠杆，就给它食物作为奖励；\n在老鼠每隔N分钟后第一次按下杠杆时给它奖励；\n当老鼠每第X（X是随机的）次按下杠杆时给它奖励；\n在老鼠每隔N（N是随机的）分钟后第一次按下杠杆时给它奖励。\n实验结果表明老鼠对几种不同的奖励周期有十分明确的回应方式。有一些奖励周期引起老鼠狂热地一次又一次按下杠杆，以期得到更多食物；有一些则相对温和，造成老鼠按杆的机会相对较少。\n如果要让老鼠尽可能多按杆，最好的奖励周期是以变化比率的形式，也就是使用随机变化的参数。在给老鼠加强“多按就会多得”印象的同时，又让它们摸不清楚到底按多少下才能得到食物。\n玩家与游戏的交互等同于价值，因此，最能引导玩家与游戏产生更多交互的方式就是以随机的周期给用户奖励。采访这些游戏的玩家会发现他们对这个游戏是否“好玩”抱有矛盾的意见，但却承认自己被吸引不停地玩。\n行为主义理论是可以被当作一个推动玩家参与的妙招的。\n有些孩子被要求每周末修剪草坪。对孩子来说有些院子太大了，而且他们从开头就害怕这个苦差事。在盛夏的日头下推割草机可不是他们爱干的事儿。但是他们随后就发现，这个工作越接近完成就变得越轻松，他们割完一行草的速度更快，他们也越来越为即将到手的5美元兴奋。\n这种现象被称为目标的梯度效应（goal-gradient effect）。\n如果玩家知道他将马上能得到奖励，他们会更有动力去完成能让他们得到这个奖励的任务。如果你发现你的玩家在游戏中的某一点逐渐失去他们的兴趣，或许这就是向他们展示他们如果继续下去将得到的奖励的最佳时机。\n原理25 社会关系 对大部分的玩家来说，游戏是一项群体活动，不管是棋盘游戏、卡牌游戏，还是视频游戏。\n这些社交性、合作性的游戏的发展证明在游戏设计中社会关系对增加玩家的兴趣、参与和满意度是非常有效的。\n大多数现代游戏要求设计师至少要考虑激活玩家的社会关系网络。\n邓巴数理论认为，任何一个人的社交网络大概由150个连接，也就是社会关系构成。它是指你能从你的社交网络中的每一个个体中得到的好处，包括互相帮助、互相访问，或通过其他手段帮助彼此。\n社交机制可以是主动的、被动的，也可以介于两者之间。\n有一个心理现象叫“害怕错过”，这是个体寻求能帮助他们被纳入团体的经验的一个很有说服力的理由。\n目标受众的偏好和他们的舒适区都会影响与社会关系相关的设计的一般方法。\n研究受众的喜好并巧妙地使用社交设计方法能够将游戏的复杂性和娱乐性提高一个层次，并最终帮助游戏从市场竞争中脱颖而出。\n原理26 公地悲剧 公地悲剧（Tragedy of the Commons）的含义是，如果一项资源是可供所有人使用的，那么该资源最终一定会被耗尽，而这对所有人都是有害的，长期的损失远大于短期内获取该资源得到的好处。\n公地悲剧的假定条件是在有限的系统内对资源的使用是增长的。\n广义而言，公地悲剧表达了一个人艰难的选择：努力争取物质利益，并由此导致自己和他人的长期损失——寄希望于短期的物质利益能弥补长期损失——或者为了所有人的利益与大家合作来节约资源，但是这样做的风险是，如果有其他人有更好的个人资源，或者有其他人谎称合作实则过度使用公共资源，这个人就吃亏了。\n在游戏中，玩家的策略或游戏的机制都有可能导致公地悲剧。应该有某种协议（或一些特殊的规则来奖励使用资源较少的玩家）来预防玩家们用完所有可用资源。\n对于公地悲剧有两种常见的，并且是相反的解决方案，但是它们都不能理想地解决这个问题。\n资源平等的再分配（共产主义）意味着无法有效利用资源的人依然能得到它，这样有很大一部分被浪费掉或很快被用完。\n另一方面，垄断资源（政府控制）则意味着资源的利用效率远低于腐败、法律法规和特殊利益集团对资源的征用。\n向人们提供足够的资源被过度使用的信息来让他们意识到保护资源的重要，确保对社区的强烈归属感以减少自私的囤积行为和滥用集体财产，建立值得信赖的机构来管理关键资源的分配，以及对负责任的资源利用行为提供激励机制，并惩罚那些不负责任的过度使用行为。\n原理27 信息透明 许多游戏都是围绕着发现隐藏信息的过程而展开的。\n游戏理论将这些信息不透明的游戏归类为“不完全信息（imperfect information）游戏”。\n另一种信息——游戏状态，则在不完全信息游戏的分类下还有所细分。\n在不完全信息游戏中有一个子分类，这类游戏中玩家能够接触到关于游戏环境和规则的所有信息，但不能看到其他玩家的行动状态，这就是完整信息（complete information）的游戏。\n在不完全信息游戏中，那些玩家没有依据对未知进行假设的游戏就是不完整信息（incomplete information）的游戏。\n理解信息透明的概念对于游戏设计师（国内公司通常称为游戏策划）而言有多强大的最后一个关键是，记住信息透明可以是自愿的或非自愿的。\n游戏中有规则规定玩家有时必须向另一名玩家展示手中的一张牌，这张牌本来应该是保密的，这就是非自愿的信息透明。\n自愿信息透明，设立这样的规则通常是为了鼓励玩家虚张声势、双重间谍的行为，并且建立一个互相不信任的氛围。\n原理28 范登伯格的大五人格游戏理论 理解人们的心理是游戏设计的基础。在许多方面，游戏的功能性目标就是激发起玩家采取行动的意愿。\n大五理论认为人类的行为主要是由5类动机驱动的：\n对体验的开放性（Openness to Experience），这一点将那些有创造力、有想象力的人和那些更务实、更循规蹈矩的人区分开来 尽责性（Conscientiousness），人如何控制和缓和自己的冲动情绪 外倾性（Extraversion），这一点将那些追求刺激以及在他人面前的存在感的人，与那些不这么做的人区分开来 随和性（Agreeableness），反应人如何处理与社会和谐的规则相关的问题 神经质或情绪稳定性（Neuroticism），这反应了一个人是否选择经历（或不经历）负面情绪的倾向 每一类人格特质都能被细分为6个子维度，这描述了更加具体的内在驱动。\n“对体验的开放性”就包括以下几个子维度：\n想象力（Imagination），这将那些认为自己的内在精神世界比外部世界更有趣的人跟与他们相反的人区别开来 艺术趣味（Artistic Interest），这关系到一个人如何体验美 情绪性（Emotionality），这指示了一个人意识到自己内心情感状态的程度 冒险性（Adventurousness），区分那些喜欢探索、寻求新事物的人和那些更喜欢已知和常规事物的人 求知欲（Intellect），关于一个人从用他们自己的脑子解决谜题，或者参与进复杂的心理游戏这样的活动中能得到多少满足感 自由主义（Liberalism），衡量一个人希望社会如何发展，是向未来推进、保持稳定不动、还是回到过去。 与想象力相关联的是玩家对幻想和写实的偏好。\n与冒险性相关联的是玩家是更喜欢将探索作为游戏机制的一部分。\n我们抱着同样的目的生活和游戏。\n我们希望在游戏中扮演别人的看法很普遍，但这是错误的。\n注：补充阅读《大五人格心理学》\n原理29 志愿者困境 “志愿者困境”（Volunteer’s dilemma）是群体博弈理论中的一个特殊例子，类似于“公地悲剧”。\n在志愿者困境中，一个人面临的选择是，是否牺牲自己的一小部分利益来让群体中的所有人受益，同时这个人自己不能得到任何额外的好处。而如果这个人不牺牲，并且也没有任何一个其他人这么做，则所有人都要面临严重的利益损害。当然，这个选择是，自己牺牲一小部分时间、经历、钱等等，或是承担等着其他人来做的风险。\n这些情况在互联网合作游戏中屡见不鲜。\n玩家可能会选择不参与一些危险的、但是对团队来说是必须的任务，而是去做更多对自己有好处的任务。他们会假设为了团队的生存和胜利，团队会去承担完成那些危险任务的责任。\n如果这个策略成功，他们会受到鼓励而继续这样的行为——并且可能会有更多的玩家选择这种对自己来说没有风险的做法——这样也就把越来越多的责任转嫁到了仍然愿意执行危险任务的团队成员身上。显然，如果这个趋势继续下去，整个团队（包括那些搭便车者）都会完蛋。\n心得 书中所介绍游戏原理其实很多在目前主流游戏中都有所体现，而学习游戏原理的意义，在于自己不仅限于“感觉这个模块挺有意思，可以拿来借鉴一下”，而是能够根据原理去设计一个模块。\n成品是游戏原理的实际运用，游戏设计的“抄作业”也至少应该明白这道题的答案为何，这样才能在以后的设计中交出一个满意的答卷。\n","date":"2019-11-14T11:00:24Z","permalink":"https://boiltask.com/notes/100principles-2/","title":"游戏设计的100个原理笔记(2) – 第1篇 游戏创新的一般原理（下）"},{"content":"第1章 如何深入高效地学习语言 在比较中学习多种语言时，一些知识能理解得更深刻。所谓语言不同，规则不同。\n知道了语言设计者为解决何种问题而创造了这种语言，以及这种语言经历过怎么样的历史变迁后，慢慢地就能理解为什么需要有这种功能了。\n了解了语言的历史，我们往往更能加深所学。\n第2章 程序设计语言诞生史 优秀的程序员具有三大美德： 懒惰、急躁和傲慢（Laziness, Impatience and Hubris）。\n“急躁”的意思是，程序员忍受不了程序执行的低效。\n“傲慢”的意思是，程序员容不得对错误不管不顾。\n“懒惰”的意思是，一项为了减少总能量支出，而不遗余力地努力的素质。\n程序设计语言是为了给人们带来便捷，但是何为便捷，语言不同，便捷的含义也各不相同。\n语言只是工具，要看通过使用它自己能做出多大成果，应当根据自己的实际情况选择好的工具。\n第3章 语法的诞生 语言设计者制定的规则就是语法。\n第4章 程序的流程控制 在提倡规则让读写程序更轻松的时代潮流中，结构化程序设计应运而生。\n第5章 函数 函数，即把代码的一部分视作有机整体，然后切分出来并为之命名的程序设计机制。\n把相同的操作封装在一起的好处不仅仅在于使程序更简短，也在于能使阅读程序的人无需反复读取相同内容的源代码。从冗长的程序中切分出反复使用的代码将其封装成一个整体，程序就更容易理解了。\n第6章 错误处理 程序在执行过程中也有可能出错，出错时如何处理（错误处理）很重要。错误处理的方法大体可分为两种：使用返回值和使用异常（异常处理）。\n为了提高软件的品质通过检查代码来确认程序员期待的程序行为，这一测评方法也是基于同样的想法。\n发生错误应该停止操作立刻报告，这一设计思想被称为错误优先（fail first）。\n第7章 名字和作用域 给内容或位置取个易于理解的名字，并用该名字来指示它们会更加方便。\n作用域是编写易于理解的代码的有力工具，很多地方都应用了这一概念。\n第8章 类型 类型是人们给数据附加的一种追加数据。\n需要有表示这个值为何种类型的额外的信息，这就是类型。\n第9章 容器和字符串 在不同的语言中，容器的名称不同，性质各异。\n根据容器的使用目的、使用方式和操作类型的不同，最适宜的容器类型也会相应地变化。\n这个地球不是单靠程序员运转的，现实中还有很多不依赖于程序实现方式的解决方案。\n第10章 并发处理 为了实现便利的并发处理，出现了进程和线程的概念。\n执行处理用的线路（CPU）只有一个，在人们察觉不到的极短间隔内交替进行多项处理，尽管在某一瞬间实际只进行一项处理，但人们会觉得似乎有多项处理在同时进行。\n在合适的节点自发进行交替，利用这种方法实现的多任务（并发处理）称为协作式多任务模式。有一个问题，有可能某个处理一直找不到合适的节点进行任务切换从而持续地进行，导致其他处理无法等到执行的机会。\n隔一定时间就进行交替，任务管理器在一定时间后强制中断现在正在进行的处理，以便允许其他程序执行。\n并行执行的两个处理之间出现竞态条件必须同时满足以下三个条件。\n两个处理共享变量 至少一个处理会对变量进行修改 一个处理未完成之前另一个处理有可能介入进来 人们在共享→非共享→共享、协调→非协调→协调、硬件→软件→硬件这样两种对立观念中左右摇摆，不单看片面而是兼顾两面，在平衡中灵活运用或许才是最为重要的。\n第11章 对象与类 在不同语言中，同一个用语的含义可能会有很大差别。\n在 C++ 语言里，类被定义为是“用户可自定义的类型”。\n类的存在只不过是因为人们觉得有了它编写程序会更方便些，而约定的一种事项。\nC++ 语言和 Java 语言的类具有以下几个作用：\n整合体的生成器 可行操作的功能说明 代码再利用的单位 第12章 继承与代码再利用 继承的实现策略大体可以分为三种。\n一般化与专门化 共享部分的提取 差异实现 一般化与专门化，在父类中实现那些一般化的功能，在子类中实现那些专门的个性化的功能\n共享部分的提取，从多个类中提取出共享部分作为父类，子类并否为父类的一种。\n差异实现，继承之后仅实现有变更的那些属性会带来效率的提高。它把继承作为实现方式再利用的途径，旨在使编程实现更加轻松。这些情况下通常子类都不是父类的一种。\n使用方法多意味着继承这种机制有很高的自由度。\n影响范围越广，就越难确定这种修改会不会带来什么问题。这个问题不是单靠在程序设计上下工夫就能解决的，同时也可以把大量的检查工作交给计算机去完成来帮助解决，这叫回归测试。\n里氏置换原则可以表述为：假设对于 T 类型的对象 x，属性 q(x) 恒为真。如果 S 为 T 的派生类，那么 S 类型的对象 y 的属性 q(y) 也必须恒为真。\n对于类 T 的对象一定成立的条件，对于类 T 的子类 S 的对象也必须成立。\n当要继承某种类时，需要考虑该类是否可以被继承。\n多重继承对于实现方式再利用是一种非常便利的方法。\n类具有两种截然相反的作用。一种是用于创建实例的作用，它要求类是全面的、包含所有必需的内容的、大的类。另一种是作为再利用单元的作用，它要求类是按功能分的、没有多余内容的、小的类。\n后记 只要是编程，大概都不可避免要产生一些错误（bug）。为了使程序准确运行，就需要调试（debug）。\n我们很容易更加关注 How 的问题（即如何去实现），实际上，What（要实现什么）和 Why（为什么要实现）的问题也是不可忽略的。\n专栏 要确认理解是否正确，首先得表达出来 为了验证理解正确与否，需要表达出来。只能基于自己的理解说出自己的观点，然后让第三方来判断和检验。\n程序员一直受益于这一点。只有理解了这一点，才能和语言处理器打交道。\n当你不知道该学习什么时 自己到底想做什么，然后再去学习能够达成这一目标的知识。\n具体的知识和抽象的知识 我们不仅要学习具体的知识，更要有意识地去学习那些应用范围广泛的抽象的概念。\n学习讲求细嚼慢咽 在庞大信息量面前心力交瘁的时候有三种战略可供参考：从需要的地方开始阅读，先掌握概要再阅读细节，从头开始逐章手抄。\n从需要的地方开始阅读 明确阅读的目的并弄清楚为达成这一目的需要阅读哪些地方，就可以有针对性地阅读，无需在其他无关的地方花费大量精力。\n先掌握概要再阅读细节 要先掌握概要再渐进式地追求细节，这是大的原则。\n从头开始逐章手抄 当没有明确要做的事情或者想要了解的东西时，当简单浏览的内容过目即忘时，以这种学习状态，不管怎么学也无法获得真知。\n","date":"2019-11-11T13:43:08Z","permalink":"https://boiltask.com/notes/coreconcept/","title":"代码之髓：编程语言核心概念笔记"},{"content":"原理1 游戏的对称性/非对称性和同步性 在对称性游戏（Symmetric gameplay）中，参与游戏的玩家的体验完全一样。\n在非对称性游戏（Asymmetric gameplay）中，参与游戏的玩家的体验并不完全一样。\n游戏中的延迟也会导致玩家看到的画面有不同，这种意外产生的信息不对称可能会产生这样的后果，这便涉及到同步性（synchronicity）问题 。同步的游戏是指在游戏过程中参与的双方同时发动自己的动作。\n原理2 A最大，鬼万能 通过在游戏中途改变定义的大小顺序，或是要求玩家根据自己或团队的目标来重新定义一张最大的牌。这样无需重新洗牌（重新分配资源），便可以改变特定结果。这就给游戏引入了多样性和惊喜，避免了过多的重复。\n改变某张牌的价值，总而组成一个更强力的牌组则为游戏增添了更多的复杂性。（赖子机制）\n原理3 巴特尔的玩家分类理论 理查德·巴特尔 将MUD（ Multi-User Dimension）玩家分为四个基本类型： 成就型玩家 、 探险型玩家 、 社交型玩家 、 杀手型玩家 。\n其用两条轴线分出的4个象限来分析这4种不同的玩家。\n原理4 合作与对抗 当与超过一个玩家一起玩游戏时，有两种可能的玩家类型：合作型和对抗型。\n在合作型的游戏中（co-op play），两个或多个玩家共享一个目标，并且通过共同努力去实现这个目标。 合作游戏通常是两个或两个以上玩家与人工智能选手的对抗。玩家可以交易物品，相互治疗，使用互补的游戏战略（如主战坦克与远程武器的联手使用），或更为动态的方式（如相互给予身体上的增强互补）以通过单个玩家靠自身能力无法通过的障碍物。\n对抗型游戏的概念很简单：一个或一组玩家与另一个（或一组）对抗去取得胜利。通常对抗的玩家中只有一个（或一组）能获胜，除非这个游戏能以平局结束。对抗性的竞争是很多多人游戏的核心，而也有很多单人游戏以之前的最高分为对抗对象。\n个别游戏机制和功能可能会起到鼓励或阻止玩家之间的合作或对抗的作用，有时候会是以意想不到的方式产生作用。\n原理5 公平 当游戏设计中的公平性也是一样——游戏对于玩家必须是公平的。换句话说，游戏必须不偏不倚，不对玩家作弊。（注：与人工智能相关理论中的思路辩证地去看待，换句话说，作弊也必须是为了使玩家获得更佳的反馈。）\n当玩家觉得游戏给了他们不公平的对待时，他们有可能会退出游戏。当玩家觉得其他玩家给了他们不公平的对待时，他们有可能会去惩罚其他玩家。在创建一个玩家会对公平性有要求的系统时记得考虑这个问题。\n在俄罗斯方块游戏中，玩家经常会将游戏中的随机行为看作是不随机的，他们认为游戏是故意给他们不想要的方块。事实上俄罗斯方块中方块的掉落确实是完全随机的，但是玩家会感觉有背后的行为模式，并把这些归咎于想象中的不公平。\n类似地，如果一个游戏的难度在逐步提高的过程中突然出现一个大的飞跃，会被玩家认为不公平——事实上这也确实不公平。游戏的难度应该平稳地逐渐上升，这样玩家才不会觉得被欺骗或受到不公正的待遇。\n第一，对于那些友好的人们，其他人愿意牺牲他们自己的物质利益。也就是说，如果在一个游戏中玩家们表现友好，那么一个独立的玩家会更容易表现出利他行为或是愿意为友好的玩家们牺牲一些自己的物质利益。\n第二，基本上可以认为是第一条的反面——玩家将会愿意损失自己的物质利益去惩罚那些不友好的玩家。如果一个玩家有意对其他玩家不友好，另一位玩家为了让他受到惩罚，将宁愿在一定程度上损失自己的物质利益。\n最后，第三条规则是，第一和第二条规则在物质损失越小的情况下越容易发生。换句话说，玩家需要放弃的物质利益越小，他们越容易参与到前面提到的那些利他或是惩罚行为中去。\n原理6 反馈循环 反馈循环有两种不同的类型。\n在一个正反馈循环中，达成一个目标能够获得奖励，而这让继续达成目标变得更容易。反馈循环的另一种形式是负反馈循环。其中达成一个目标会让下一个目标更难达成。 解决负反馈循环的难题其实很容易：为玩家完成游戏的目标提供奖励 。 我们可以考虑将正反馈和负反馈配合起来，或者是找到一个对玩家的实力不造成真正影响的奖励方式，比如新的皮肤或者动画效果之类装饰性的奖励。\n原理7 加德纳的多元智能理论 霍华德·加德纳（Howard Gardner）提出了多元智能理论，该理论认为，作为个体，我们每一个人在认知方式上都各有长处和短处。\n数理逻辑认知：通过批判性思维和逻辑来认知的过程，有时也被含糊地称为左脑学习。\n空间认知：通过想象将物体在空间中的情形视觉化来认知的过程。\n语言认知：以听觉或书面的方式，通过文字来认知的过程。\n身体-运动认知：通过身体或者周围的物理世界的移动来认知的过程。\n通过身体或者周围的物理世界的移动来认知的过程。这些人如果能站起来，走动走动，或者与他们正在学习的东西有身体上的接触，就能学得更好。\n音乐认知：通过各种和音乐有关的东西，包括音调、旋律、节奏和音色来认知的过程。\n通过各种和音乐有关的东西，包括音调、旋律、节奏和音色来认知的过程。这种类型的人能从童谣或任何以音乐形式呈现的东西中学习。\n人际交往认知：在与其他人的互动中来认知的过程。\n在与其他人的互动中来认知的过程。这类人可能非常有爱心或者是一位交际花。\n内省认知：自我反省和认知的过程。\n自我反省和认知的过程。这类人通常都很安静，一直从自己的内心寻找答案。\n自然探索认知：从周围相关的自然环境中认知的过程。\n如果设计师在设计游戏时考虑到这些不同的智能，他们可以让游戏适应无限多的玩家。\n原理8 霍华德的隐匿性游戏设计法则 霍华德的隐匿性游戏设计法则（Howard’s Law of Occult Game Design，隐匿性游戏设计法则，或称霍华德法则）可以用以下公式来表示：秘密的重要性其表面看来的无辜性完整度\n$$\r秘密的重要性 \\propto 其表面看来的无辜性 \\times 完整度\r$$$$\rSecret Significance \\propto Seeming Innocence \\times Completeness\r$$秘密的重要性，是与其表面上看起来无辜的程度及其完整度直接成比例的。\n原理9 信息 在一个游戏中的任何一个点上，玩家能接触到的信息数量和性质可以极大地改变其决定。\n和游戏相关的信息可以采取不同的形式以及分类呈现。\n游戏的结构 所有信息的类别中最首要的一个是游戏的结构，包括游戏的设定和规则。游戏环境本身也应该被视为信息。 如果一个游戏中的随机元素被作为参数而不是一个固定值来考虑，它也是一条明确的信息。\n游戏的状态 这类信息包括单位元素所处的位置、分数、资源的情况等。而它的含义比单个元素在地理上被放置在哪里这一点要更广泛一些。\n信息的利用 每个游戏利用这些原则的方式都不一样，但是一般的分类和分级对描述游戏设计师是如何处理这些信息是有帮助的。\n“完全信息”是游戏中一种最基本和限制最少的信息传达方式。在“完全信息”的环境下，所有的玩家都知道关于游戏的每一件事——环境，规则，当前位置，所有物品的状态，以及当前的游戏阶段。\n与“完全信息游戏”相对的，如果在游戏中一部分信息对某一个或更多的玩家是隐藏的，那么这个游戏是“不完全信息游戏”。\n原理10 科斯特的游戏理论 《游戏设计快乐之道》：所有游戏其实是低风险的学习工具，要让每一个游戏在某种程度上都是寓教于乐的。 这种“快乐”来源于“超游戏思维” 。\n如何在游戏设计中用到“组块化”，“组块化”是一个将复杂的任务分解成我们能够下意识地完成事情的过程。\n在我们的体验中，我们在一个不断变化的过程中参与并接受挑战就是“快乐”，特别是在学习中。\n原理11 拉扎罗的4种关键趣味元素 拉扎罗（Lazzaro）的4种关键趣味元素是一个设计工具，它能在游戏设计师设计新的游戏机制时激发其灵感，研究人员也能利用它来检验这些游戏机制的效果。\n简单趣味：玩家对一种新的体验感到好奇，他被带入到这种体验中去并且开始上瘾。\n困难趣味：游戏提供了一个可供追求的目标，并将其分解成一个一个可以达成的步骤。\n他人趣味：竞争、合作、沟通和领导结合在一起，增加参与度。“他人趣味”带来的情绪上的感受比其他3种加起来还要多。\n严肃趣味：玩家通过游戏来改变他们自己和他们的世界。游戏是一种对他们价值观的表达，而不是在浪费时间。\n最畅销的游戏通常能同时满足这4种趣味元素中的至少3个。游戏玩家对这4种趣味元素都喜欢，尽管在这其中他们有自己偏好。\n“简单趣味”是一个吸引好奇的玩家的并且促使他们加入游戏的诱饵。\n在某个时候，当这些新奇的感觉不再能持续获取玩家的关注时，他们会去寻找一些具体的事情来完成。“困难趣味”就是通过游戏困难度和玩家技巧间的平衡来做到让他们在经历挫折之后从史诗般的胜利中感受到“自豪” 。\n当与朋友在一起时，胜利的快感会让人感觉更好。围绕着游戏展开的社交互动能创造娱乐效果和社交纽带。\n原理12 魔法圈 游戏的一大特点是它是一种幻想（这是关于游戏的定义中一个主要的部分）。我们固有的假设是，游戏是一种独立于真实世界的存在。\n当“这只是一个游戏”不再只是一个游戏，魔法圈的界限就被丢诸脑后了。\n原理13 采取行动 游戏中的博弈，依据博弈各方做决定或采取行动的先后关系，可以被区分为“同步博弈”（Simultaneous game）或“序贯博弈”（Sequential game）。\n在同步博弈中，每个玩家同时也知道博弈中的每个人都面临着同样的问题。关键的信息对于博弈者在做自己每一步的决策时并不可见 （自己行动的时候不知道对方此刻的行动）。在序贯博弈中，每个博弈者能得到更多的信息。他们能通过其他人刚刚采取的行动，对其下一步行动进行可靠的预测（体现在自己行动的时候可以知道对方已有的行动）。\n同步博弈有可能是在时间上真正同步进行的，比如“石头剪刀布”；也有可能不是，博弈者各自在不同的时间进行自己的行动，只是他们在采取自己的行动时不知道其他博弈者的决策。\n序贯博弈要求博弈各方每一步都要轮流做出决策，同时他们对于其他人之前做出的决定至少是部分知情的。\n原理14 MDA：游戏的机制、运行和体验 游戏的机制、运行和体验（Mechanics，Dynamics，and Aesthetics，MDA）是一个系统化的分析和理解游戏的方法。\n游戏机制是整个系统的规则。它定义了这个系统如何处理玩家的输入，以及玩家能看到什么和做什么。\n游戏的运行讲的是在玩游戏的过程中整个系统的各个参与者的行为。游戏的运行是对游戏机制在真正运行时效果的展现。\n游戏的体验是在游戏运行的影响下玩家的情感输出。\n我们有两种不同的方式来实践MDA。\n第一种方式，游戏设计师以定义在游戏中想要达到的体验效果作为设计流程的开始，然后确定要达到这样的体验效果玩家需要参与什么样的游戏运行过程，最终再为这样的运行过程设置游戏的机制。\n第二种方式，玩家反向体验MDA的3个要素并且首先与游戏机制进行互动，这些机制会带来特定的游戏运行，而这又将让玩家产生特定的体验。\nMDA只是在游戏中达到创造特定情绪反应效果的一个方法，它有它的局限性。\n","date":"2019-11-09T15:50:57Z","permalink":"https://boiltask.com/notes/100principles-1/","title":"游戏设计的100个原理笔记(1) – 第1篇 游戏创新的一般原理（上）"},{"content":"阿里云发来了一条续费通知……\n这一个应该是ECS里跟了我最久的一台主机了吧，主要运行了酷Q机器人相关的服务。\n在网络编程课程设计和Java课程设计里面，用过他当做运行Java的服务器。这么久的日子了，人生第一个可以称得上作品的项目，QQ机器人也跟随了这么久。随着已经很长时间没有进行维护了，但是一直半死不活地运行着，后边也写了HPU小助手这种小工具。\n那么……说声再见吧，有缘江湖不散~\n","date":"2019-10-15T10:12:26Z","permalink":"https://boiltask.com/record/201910151/","title":"又一台跟了好久的主机到期了"},{"content":"记录 Obsidian Typora Microsoft Todo Sticky Notes OneNote 有道云笔记 开发环境 NodeJs Git TortoiseGit Github Desktop TortoiseSVN JetBrains Toolbox 编辑器 VsCode EmEditor 建站 Hugo WordPress 图像 PixPin PicGo ScreenToGif Captura PotPlayer 剪映 OBS Studio Snipaste 树洞OCR 快捷 Quicker Everything Anytxt Searcher Wox 聊天 QQ 微信 AI 腾讯元宝 读书 Calibre NeatReader 游戏 暴雪战网\n其它 腾讯桌面整理 Q-Dir Steam Clash FileZilla ShadowsocksR MacTray Scrcpy PanDownload ","date":"2019-09-21T16:17:00Z","permalink":"https://boiltask.com/material/common-software/","title":"学习工作常用软件汇总"},{"content":"美术 教你画像素画：每一个像素都有意义\n虚幻4渲染编程：在虚幻4中学习图形编程\n设计 笔记：游戏设计\n社区 Project1（66RPG）\n","date":"2019-09-21T05:30:02Z","permalink":"https://boiltask.com/material/game-learning/","title":"游戏制作学习资料汇总"},{"content":"前几天看到有个回答，关于程序员提升过程的说法。\n学习编程，开发软件，过程大抵如下：\n看书，看视频，看博客，听课等等 对着书敲代码 脱离书自己敲代码 自己实现一些小DEMO 进项目看代码 在别人指点下写代码 自己独立在别人搭建好框架内填写代码 自己独立负责别人设计好的模块的实现 自己独立负责一个软件模块的设计和实现 负责较大软件模块，拆分模块，分子任务给他人 负责一个小项目，设计，拆分，分派任务 做较大的软件系统的架构设计 作者：安晓辉\n链接：https://www.zhihu.com/question/297309123/answer/537836889\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n想想经过这么些年，也差不多在6~7之间徘徊了。而下面的评论也说，这个过程又是一个程序员提升过程中的瓶颈。能有所突破，未来便能继续稳步提高。\n想想人生和程序员有所关联，应该缘起于2006在小学生学习报上看到了跑跑卡丁车的广告。然后2007年在我姑父的带领下解除了泡泡堂，随后家里安装了电脑，又度过了一段难忘的游戏时光。随后，人生梦想就由画家转变成了游戏开发人员 （虽然画画也同样还很喜欢）。\n如今，也算是梦想成真了一部分。\n未来，还需要继续努力呀~\n","date":"2019-09-21T05:00:34Z","permalink":"https://boiltask.com/record/201909211/","title":"程序员之路"},{"content":"相加 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 string add(string a,string b) {\t//两数相加 string res=\u0026#34;\u0026#34;; int i=1; string first=\u0026#34;0\u0026#34;; while(true) { int tai=a.size()-i; int tbi=b.size()-i; if(tai\u0026lt;0 \u0026amp;\u0026amp; tbi\u0026lt;0) break;\t//从两数最右边开始模拟加法运算直到两数都遍历完 int ta,tb; if(tai\u0026lt;0) ta=0;\t//如果没数则至为0 else ta=a[tai]-\u0026#39;0\u0026#39;; if(tbi\u0026lt;0) tb=0;\t//如果没数则至为0 else tb=b[tbi]-\u0026#39;0\u0026#39;; int temp=ta+tb+first[0]-\u0026#39;0\u0026#39;;\t//相加 first保存上一个的进位信息 first[0]=temp%10+\u0026#39;0\u0026#39;;\t//当前位是对10取余 res=first+res; first[0]=temp/10+\u0026#39;0\u0026#39;;\t//进位是除10 i++; } if(first!=\u0026#34;0\u0026#34;) res=first+res;\t//如果进位还有则添加 if(res[0]==\u0026#39;0\u0026#39; \u0026amp;\u0026amp; res.size()\u0026gt;1)\t//去除前导0 res.erase(res.begin()); return res; } 相乘 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 string mul(string a,string b) { if(b.size()==1) {\t//如果b只有一位则使其分别相乘 string res=\u0026#34;\u0026#34;; string first=\u0026#34;0\u0026#34;; int mb=b[0]-\u0026#39;0\u0026#39;; for(int i=a.size()-1; i\u0026gt;=0; i--) {\t//从最后开始依次计算 int temp=(a[i]-\u0026#39;0\u0026#39;) * mb + (first[0]-\u0026#39;0\u0026#39;); first[0]=temp%10+\u0026#39;0\u0026#39;;\t//当前位 res=first+res; first[0]=temp/10+\u0026#39;0\u0026#39;;\t//进位 } if(first!=\u0026#34;0\u0026#34;) { res=first+res;\t//处理进位 } if(res[0]==\u0026#39;0\u0026#39; \u0026amp;\u0026amp; res.size()\u0026gt;1) res.erase(res.begin());\t//除去前导0 return res; } //否则则把b拆分为一位 string res=\u0026#34;0\u0026#34;; string zero=\u0026#34;\u0026#34;; for(int i=b.size()-1; i\u0026gt;=0; i--) {\t//从b的最后一位开始 string temp=mul(a,b.substr(i,1));\t//计算当前为与a相乘 res=add(res,temp+zero);\t//在其后添加适当的0再与结果相加 zero=zero+\u0026#34;0\u0026#34;; } return res; } 整数转string 1 2 3 4 5 6 7 8 9 10 11 12 string inttostring(int m) {\t//将整数转为string string res=\u0026#34;\u0026#34;; string temp=\u0026#34;0\u0026#34;; while(m) { temp[0]=m%10+\u0026#39;0\u0026#39;; res=temp+res; m/=10; } if(res==\u0026#34;\u0026#34;) res=\u0026#34;0\u0026#34;; return res; } 较大的值 1 2 3 4 5 6 7 string smax(string a,string b) { if(a.size()\u0026gt;b.size()) return a; if(a.size()\u0026lt;b.size()) return b; return a\u0026gt;b?a:b; } long long 时间复杂度比较高是个问题\n考虑用long long拼接\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 struct int128 { long long h; long long l; }; int128 max(int128 a,int128 b) { if(a.h\u0026gt;b.h) return a; if(a.h\u0026lt;b.h) return b; if(a.l\u0026gt;b.l) return a; if(a.l\u0026lt;b.l) return b; return a; } int128 operator + (int128 a,int128 b) { int128 k; k.l=0,k.h=0; k.l=a.l+b.l; k.h=k.l/p+a.h+b.h; k.l%=p; return k; } int128 operator * (int128 a,int b) { long long mod=1e9; long long l1=a.l/mod; long long l2=a.l%mod; l1=l1*b+l2*b/mod; l2=l2*b%mod; a.h=a.h*b+l1/mod; l1=l1%mod; a.l=l1*mod+l2; return a; } ","date":"2018-11-13T00:16:30+08:00","permalink":"https://boiltask.com/knowledge/cpp-big-int/","title":"C++用实现大数模板（string、int128）"},{"content":" 相关环境 Open3D（https://github.com/IntelVCL/Open3D/） D435（https://github.com/IntelRealSense/librealsense） Open3D环境的安装 备注：官方版本有更新，遇到问题以官方说明为准\n1.Python环境安装\nOpen3D安装成功导出一个Python库以供调用，网上有Open3D教程基于Python2.7，此处使用的Python版本为3.7，经测试可用。\nPython安装可前往官网下载：https://www.python.org/ ，安装时可勾选添加环境变量以免仍需自己配置。\n2.Cmake环境安装\nCmake允许开发者编写一种平台无关的 CMakeList.txt 文件来定制整个编译流程，然后再根据目标用户的平台进一步生成所需的本地化 Makefile 和工程文件\n在官网下载最新版本：https://cmake.org ，安装时勾选添加环境变量。​\n3.Visual Studio环境安装\nVisual Studio可前往官网下载：Visual Studio: IDE and Code Editor for Software Developers and Teams\nOpen3D官方推荐版本为2015，此处使用VS2017编译成功\n4.Open3D编译\n前往github下载最新的代码：https://github.com/IntelVCL/Open3D\n参考官方文档：http://www.open3d.org/docs/getting_started.html\n使用Cmake最终可在Open3D文件夹下过的build文件夹，后续研究大部分基于此文件夹。\n配置成功在python中输入import open3d应该可以正常运行\nD435环境的安装 1.MeshLab安装\nMeshLab用于打开相机导出的数据。\n在官网下载最新版：MeshLab\n按照提示安装即可。\n2.D435安装SDK\n在github上下载官方SDK：\nhttps://github.com/IntelRealSense/librealsense/releases\n其中主要是：Intel.RealSense.Viewer.exe\n插入D435相机，运行Intel.RealSense.Viewer.exe，可在右方显示相机图像。\n打开RGB通道与Depth通道，切换为3D模式，可导出ply文件\n运行代码 为了方便调试代码，推荐把需要调试的代码与数据复制到其他文件夹操作。\n合成代码：https://paste.ubuntu.com/p/gq2SwfjVss/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 import numpy as np import open3d from open3d import registration_ransac_based_on_feature_matching as RANSAC from open3d import registration_icp as ICP from open3d import compute_fpfh_feature as FPFH from open3d import get_information_matrix_from_point_clouds as GET_GTG def register(pcd1, pcd2, size): kdt_n = open3d.KDTreeSearchParamHybrid(radius=size, max_nn=50) kdt_f = open3d.KDTreeSearchParamHybrid(radius=size * 10, max_nn=50) pcd1_d = open3d.voxel_down_sample(pcd1, size) pcd2_d = open3d.voxel_down_sample(pcd2, size) open3d.estimate_normals(pcd1_d, kdt_n) open3d.estimate_normals(pcd2_d, kdt_n) pcd1_f = FPFH(pcd1_d, kdt_f) pcd2_f = FPFH(pcd2_d, kdt_f) checker = [open3d.CorrespondenceCheckerBasedOnEdgeLength(0.9), open3d.CorrespondenceCheckerBasedOnDistance(size * 2)] est_ptp = open3d.TransformationEstimationPointToPoint() est_ptpln = open3d.TransformationEstimationPointToPlane() criteria = open3d.RANSACConvergenceCriteria(max_iteration=400000, max_validation=500) result1 = RANSAC(pcd1_d, pcd2_d, pcd1_f, pcd2_f, max_correspondence_distance=size * 2, estimation_method=est_ptp, ransac_n=4, checkers=checker, criteria=criteria) result2 = ICP(pcd1, pcd2, size, result1.transformation, est_ptpln) return result2.transformation def merge(pcds): all_points = [] for pcd in pcds: all_points.append(np.asarray(pcd.points)) merged_pcd = open3d.PointCloud() merged_pcd.points = open3d.Vector3dVector(np.vstack(all_points)) return merged_pcd def add_color_normal(pcd): # in-place coloring and adding normal pcd.paint_uniform_color(np.random.rand(3)) size = np.abs((pcd.get_max_bound() - pcd.get_min_bound())).max() / 30 kdt_n = open3d.KDTreeSearchParamHybrid(radius=size, max_nn=50) open3d.estimate_normals(pcd, kdt_n) def load_pcds(pcd_files): pcds = [] for f in pcd_files: pcd = open3d.read_point_cloud(f) add_color_normal(pcd) pcds.append(pcd) return pcds def align_pcds(pcds, size): pose_graph = open3d.PoseGraph() accum_pose = np.identity(4) pose_graph.nodes.append(open3d.PoseGraphNode(accum_pose)) n_pcds = len(pcds) for source_id in range(n_pcds): for target_id in range(source_id + 1, n_pcds): source = pcds[source_id] target = pcds[target_id] trans = register(source, target, size) GTG_mat = GET_GTG(source, target, size, trans) if target_id == source_id + 1: accum_pose = np.matmul(trans, accum_pose) pose_graph.nodes.append(open3d.PoseGraphNode(np.linalg.inv(accum_pose))) pose_graph.edges.append(open3d.PoseGraphEdge(source_id, target_id, trans, GTG_mat, uncertain=True)) solver = open3d.GlobalOptimizationLevenbergMarquardt() criteria = open3d.GlobalOptimizationConvergenceCriteria() option = open3d.GlobalOptimizationOption( max_correspondence_distance=size / 10, edge_prune_threshold=size / 10, reference_node=0) open3d.global_optimization(pose_graph, method=solver, criteria=criteria, option=option) for pcd_id in range(n_pcds): trans = pose_graph.nodes[pcd_id].pose pcds[pcd_id].transform(trans) return pcds def main(): pcds = load_pcds([\u0026#34;data/test/bun270.ply\u0026#34;, \u0026#34;data/test/bun315.ply\u0026#34;, \u0026#34;data/test/chin.ply\u0026#34;, \u0026#34;data/test/bun000.ply\u0026#34;, \u0026#34;data/test/bun045.ply\u0026#34;, \u0026#34;data/test/bun090.ply\u0026#34;, \u0026#34;data/test/bun180.ply\u0026#34;]) open3d.draw_geometries(pcds, \u0026#34;input pcds\u0026#34;) size = np.abs((pcds[0].get_max_bound() - pcds[0].get_min_bound())).max() / 30 pcd_aligned = align_pcds(pcds, size) open3d.draw_geometries(pcd_aligned, \u0026#34;aligned\u0026#34;) pcd_merge = merge(pcd_aligned) add_color_normal(pcd_merge) open3d.draw_geometries([pcd_merge], \u0026#34;merged\u0026#34;) if __name__ == \u0026#39;__main__\u0026#39;: main() 将测试数据与代码放入对应文件夹内\n打开命令提示符窗口 cd 代码文件夹（如果不在C盘还需要再键入一行盘符，如D:） python main.py（main.py为代码文件夹名称） 环境配置无误的话将依次获得处理结果\n处理数据 1.通过D435导出ply文件\n2.导入MeshLab中，通过上方工具去除多余点\n常用操作：\n鼠标：旋转模型\nCtrl+鼠标：整体位置拖动 选取某一区域的点：\n删除所选的点：ctrl+delete\n处理完成后在左上角选择保存。\n把数据放入指定文件夹中 修改代码读取的文件名，即给pcds变量复制的load_pcds函数 运行代码查看效果 附录 测试数据：\nhttps://download.csdn.net/download/u011493189/10713389\n3DCloud基于照片的3D模型构建：\n官方网站：http://www.3dcloud.cn\n模型展示：\nhttp://www.3dcloud.cn/Member/?m=Models\u0026amp;a=model_view\u0026amp;model_id=10078\n所用照片：\nhttps://download.csdn.net/download/u011493189/10713405\n备注：\n网站功能尚不完善，免费下载额度有限，高精度建模尚未开放，API尚未开放。\n正在慢慢完善之中，可观察其后续进展。\n​\n","date":"2018-10-11T12:22:07+08:00","permalink":"https://boiltask.com/knowledge/cattle-model-technology/","title":"中国荷斯坦牛建模相关技术的研究（Open3D、D435）"},{"content":"在AutoCAD中写了一个生成摩天轮的程序，这辈子估计也少有机会深入学AutoCAD了，留作纪念。\n代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 (defun c:mtl () (setq ss (getvar \u0026#34;osmode\u0026#34;)) (setq cc (getvar \u0026#34;cecolor\u0026#34;)) (setvar \u0026#34;osmode\u0026#34; 512) (prompt \u0026#34;\\n先画圆:采用圆心和半径式\u0026#34;) (setq\tpc (getpoint \u0026#34;\\n圆心\u0026#34;) p0 (getpoint pc \u0026#34;\\n圆周上点\u0026#34;) ) (setq tpc pc) (setq r (distance pc p0)) (setq r2 (/ r 2)) (command \u0026#34;circle\u0026#34; pc (* 0.875 r)) (command \u0026#34;circle\u0026#34; pc r2) (setq tang0 (/ pi 18)) (setq tang1 (/ pi 9)) (setq i 1) (repeat 36 (setq pt1 (polar pc (* tang0 i) r2)) (setq pt2 (polar pc (+ (* tang1 (fix (/ i 2))) (/ tang1 4)) r)) (setq pt3 (polar pc (+ (* tang1 (fix (/ (- i 1) 2))) (/ tang1 4)) r) ) (setq pt4 (polar pc (+ (* tang1 (fix (/ (+ i 1) 2))) (/ tang1 4)) r) ) (setq pt5 (polar pc (+ (* tang1 (fix (/ i 2))) (/ tang1 4)) (* 0.875 r) ) ) (setq pt6 (polar pc (+ (* tang1 (fix (/ (+ i 1) 2))) (/ tang1 4)) (* 0.875 r) ) ) (command \u0026#34;line\u0026#34; pt5 pt6 \u0026#34;\u0026#34;) (command \u0026#34;line\u0026#34; pc pt1 \u0026#34;\u0026#34;) (command \u0026#34;line\u0026#34; pt1 pt2 \u0026#34;\u0026#34;) (command \u0026#34;line\u0026#34; pt1 pt3 \u0026#34;\u0026#34;) (command \u0026#34;line\u0026#34; pt1 pt4 \u0026#34;\u0026#34;) (command \u0026#34;line\u0026#34; pt2 pt3 \u0026#34;\u0026#34;) (command \u0026#34;circle\u0026#34; pt2 (/ r2 4)) (setq i (+ i 1)) ) (setq pc (list (+ (nth 0 pc) (* 2 r)) (nth 1 pc))) (command \u0026#34;circle\u0026#34; pc (/ r2 4)) (setq tr r) (setq r (* 1.25 r)) (setq pcd (list (nth 0 pc) (- (nth 1 pc) r))) (setq pcl (list (- (nth 0 pcd) r) (nth 1 pcd))) (setq pcr (list (+ (nth 0 pcd) r) (nth 1 pcd))) (setq pcl1 (list (- (nth 0 pcd) (/ r 2)) (nth 1 pcd))) (setq pcr1 (list (+ (nth 0 pcd) (/ r 2)) (nth 1 pcd))) (command \u0026#34;line\u0026#34; pc pcl1 \u0026#34;\u0026#34;) (command \u0026#34;line\u0026#34; pc pcr1 \u0026#34;\u0026#34;) (command \u0026#34;line\u0026#34; pc pcl \u0026#34;\u0026#34;) (command \u0026#34;line\u0026#34; pc pcr \u0026#34;\u0026#34;) (command \u0026#34;line\u0026#34; pc pcd \u0026#34;\u0026#34;) (command \u0026#34;line\u0026#34; pcr pcl \u0026#34;\u0026#34;) (setq pclm (polar pcd (* (/ 3.0 4.0) pi) (* r (/ (sqrt 2.0) 2.0)))) (command \u0026#34;line\u0026#34; pclm pcr \u0026#34;\u0026#34;) (command \u0026#34;line\u0026#34; pclm pcd \u0026#34;\u0026#34;) (setq pcrm (polar pcd (/ pi 4) (* r (/ (sqrt 2.0) 2.0)))) (command \u0026#34;line\u0026#34; pcrm pcl \u0026#34;\u0026#34;) (command \u0026#34;line\u0026#34; pcrm pcd \u0026#34;\u0026#34;) (setq r4 (/ r2 2)) (setq pc (list (nth 0 pc) (- (nth 1 pc) (* 3 tr)))) (setq pcd (list (nth 0 pc) (- (nth 1 pc) r))) (setq plu (list (- (nth 0 pc) r4) (+ (nth 1 pc) tr))) (setq pru (list (+ (nth 0 pc) r4) (+ (nth 1 pc) tr))) (setq pld (list (- (nth 0 pc) r4) (- (nth 1 pc) tr))) (setq prd (list (+ (nth 0 pc) r4) (- (nth 1 pc) tr))) (setq pcr (list (+ (nth 0 pc) tr) (- (nth 1 pc) r))) (command \u0026#34;pline\u0026#34; plu pru prd pld \u0026#34;c\u0026#34;) (command \u0026#34;line\u0026#34; plu prd \u0026#34;\u0026#34;) (command \u0026#34;line\u0026#34; pru pld \u0026#34;\u0026#34;) (command \u0026#34;line\u0026#34; pc pcd \u0026#34;\u0026#34;) (command \u0026#34;line\u0026#34; pc pcr \u0026#34;\u0026#34;) (command \u0026#34;line\u0026#34; pcd pcr \u0026#34;\u0026#34;) (setq pc (list (nth 0 tpc) (- (nth 1 tpc) (* 3 tr)))) (setq r tr) (command \u0026#34;circle\u0026#34; pc tr) (command \u0026#34;circle\u0026#34; pc r2) (setq i 1) (repeat 36 (setq pt1 (polar pc (* tang0 i) r2)) (setq pt2 (polar pc (+ (* tang1 (fix (/ i 2))) (/ tang1 4)) r)) (setq pt3 (polar pc (+ (* tang1 (fix (/ (- i 4) 2))) (/ tang1 4)) r) ) (setq pt4 (polar pc (+ (* tang1 (fix (/ (+ i 4) 2))) (/ tang1 4)) r) ) (setq pt5 (polar pc (+ (* tang1 (fix (/ i 2))) (/ tang1 4)) (* 0.875 r) ) ) (setq pt6 (polar pc (+ (* tang1 (fix (/ (+ i 1) 2))) (/ tang1 4)) (* 0.875 r) ) ) (command \u0026#34;line\u0026#34; pt5 pt6 \u0026#34;\u0026#34;) (command \u0026#34;line\u0026#34; pc pt1 \u0026#34;\u0026#34;) (command \u0026#34;line\u0026#34; pt1 pt2 \u0026#34;\u0026#34;) (command \u0026#34;line\u0026#34; pt1 pt3 \u0026#34;\u0026#34;) (command \u0026#34;line\u0026#34; pt1 pt4 \u0026#34;\u0026#34;) (command \u0026#34;line\u0026#34; pt2 pt3 \u0026#34;\u0026#34;) (command \u0026#34;circle\u0026#34; pt2 (/ r2 4)) (setq i (+ i 1)) ) (setvar \u0026#34;osmode\u0026#34; ss) (setvar \u0026#34;cecolor\u0026#34; cc) ) ","date":"2018-05-19T00:00:00+08:00","permalink":"https://boiltask.com/knowledge/autocad-lisp-mtl/","title":"AutoCAD LISP编程绘制摩天轮"},{"content":" 早便计划为《红楼梦》写点什么，特别是在上完第一次《红楼梦鉴赏》课后，又把红楼梦原著及一些周边作品（电视剧、书评等）看了一遍。但适逢近些日子自己的思想也有着很大的波动，而且随着课程的进行也有着新的体会。于是写一段感觉不满意或是又若有所思便断了下来，过些时间再看时，又感觉过往论点有所偏差，因此这一拖又是好久。不过，正是在这个过程中，我似乎又突然明白了贾宝玉的心路历程。\n― 题记 开辟鸿蒙，谁为情种？都只为风月情浓。奈何天，寂寥时，试遣愚忠。因此上演出这悲金悼玉的“红楼梦”。1\n一曲红楼几多梦，《红楼梦》作为一部流传至今仍散发出文化内涵与思想底蕴的作品，其不光有着巨大的史料价值、文学价值，甚至还可以从中领悟到深刻的哲学思想。也因此，很多人对《红楼梦》的印象会停留在这是一本枯燥乏味、满载之乎者也的古代言情小说。然而细读下来，这本“批阅十载，增删五次”的小说，虽满载头衔，却平易近人；虽满纸荒唐，却引人深思。抛去其中对文学、文化的思考，只看对情节的把握与人物的塑造，也可堪称一绝。蕴含其中的，不光是老学究们的考证，也是一些“少年维特的烦恼”。\n“无才可去补苍天，枉入红尘若许年。此系身前身后事，倩谁记去作奇传”。以男主角贾宝玉的成长来看，很多人认为宝玉太过花心以至到处沾花惹草。在第二回《贾夫人仙逝扬州城冷子兴演说荣国府》中，我们便可以借冷子兴之口看出大多数世人对周岁抓阄便认准“脂粉钗环”，后又说出“女儿是水做的骨肉，男子是泥做的骨肉。我见了女儿便清爽，见了男子便觉浊臭逼人”的贾宝玉的一般看法——“你道好笑不好笑？将来色鬼无疑了！”。虽然后有贾雨村为之辩解，但终归逃不出“公候”二字。\n前段时间翻到高中的笔记，竟也提到了这一段。当时我的理解是贾宝玉认为世人对男子的要求较高，男人身上与生俱来便有着一些世故，换做女子去做同样的事反倒显得单纯。现在想来这还是片面的，宝玉所生活的时代恰恰是一个世俗对女子所偏见的时代。甚至在当今社会，我们对女子的要求虽无三从四德，却也绝谈不上平等。以一个大学生（高中生）的角度，可能对周围的女同学还体会不深，不过从生活与文化的熏陶之中，却也不难以发现这一点。举例说明，在大多数家庭，过年往往都是女方在婆家忙活。旁人若见一个女子出嫁后仍“赖”在娘家，恐怕不免传出闲言碎语。所以宝玉能发出此言，可能恰恰是由于弱化了女子与男子在世俗中地位的不同。当然，宝玉的行为虽似古怪，却终究是有其产生的道理的。\n可能受86版电视剧的影响，人们对宝玉的第一印象是与成人无异。然而尽管存疑，但我们探讨《红楼梦》时仍需明白，这是一部“少年少女那些事”。在这里需要特别指出的是，红楼梦中素有“真事隐去，假语村言”，甚至书中细节考究起来可能会略有矛盾，这也给我们探究红楼中人具体年龄带来了困扰。如今我们只能从脂批本和书中情节之间的关联来大致做出猜想。不过毫无疑问的，宝玉起初的行为绝不是一个成年人的思维，而是作为一个孩童式的表达。任何人都有一个生理和心理的成长和发展的过程，贾宝玉的人格形成也有着这样的过程。2因此我们是不能用太成人的眼光与看待他们的故事的，试想身边这些十岁的少年少女，恐怕我们会对这本书有着新的理解。考虑到这一层，我们便可以选取一些片段逐步来分析宝玉的其人其事。\n一、这个妹妹我曾见过的\n这句话出自原著第三回《托内兄如海荐西宾 接外孙孟母惜孤女》，是宝玉初见黛玉时言论。正是在这一回里宝玉初登场，作者也没吝啬笔墨，集大量辞藻去“批判”贾宝玉。作者称之为“纵然生得好皮囊，腹内原来草莽”与“天下无能第一，古今不肖无双”。能被如此形容的主角，想必也是古今也是鲜有。\n就是这个“潦倒不通庶务”的“混世魔王”，在见到黛玉的第一面说出了进人看到都为之经典的一句“撩妹经典”：“这个妹妹我曾见过的……虽没见过，却看着面善，心里倒象是远别重逢的一般。”之后两人闲聊之中，宝玉的一言“除了《四书》，杜撰的也太多呢。”，可谓是一语道尽其内心对功名文章的不屑。\n在这里我们重点来分析一下后面宝玉摔玉这一桥段，因为在往常看来，我们可能更倾向于这体现了宝玉对世俗的不羁态度。不过想想原文中年龄的描述，此时的宝玉应该是不满十岁的（由第三回可知其比黛玉大不几岁，而黛玉丧母之时原文中有具体描述为六岁，故而推知）。放在当今社会，一个几岁的孩子可能刚上小学没几年，偶然一次心里不高兴把自己的玩具摔了，我们会去联想到他对这个社会产生抵触情绪吗？恐怕我们也只会一笑了之吧。所以在我看来，宝玉摔玉这件事恐怕并不需要解读得太过严重。\n我们分析一下当时宝玉的心理。自己衔玉而生，家里人都引以为奇并无比珍重这块玉石。然而这块玉对自己又有何用呢？正像宝钗所言，“沉甸甸的，有什么趣儿？”。所以反倒宝玉自己并没有感受到这块玉有多么得重要，甚至某种意义上来说，家人对玉的关注影响到了家人对自己本身的关注，那就不妨找个理由闹上一场了。\n摔玉事件也着时吓到了黛玉，晚上还在闺房中伤心流泪，引得袭人安慰了一番。绛珠仙草以泪还恩，在这里也开始有所体现。\n二、到如今回头试想真无趣\n这是第二十二回《听曲文宝玉悟禅机 制灯谜贾政悲谶语》中宝玉在听过为宝钗生日所点的《山门》后，填的一只《寄生草》中的一句。在这一回中，我才第一次感觉到贾宝玉好像有点不一样的。在此之前，我对贾宝玉的直观感受是这是一个迷恋于姐妹之间的富家公子。但这一回画风突变，贾宝玉从一个整天耍着“精致的淘气”、“撩妹达人”的形象，突然转变成了一个悟道之人。人说世上存在由情入道，也是最难而最特别的一种方式，这也给后人推测的宝玉出家的结局作出了一定的解释。\n回顾本回，这一篇的内容不可谓不丰富，且不论本回后半部分的谶语，只单看宝玉悟禅机一事。先是宝钗给宝玉提到的“赤条条来去无牵挂。哪里讨烟蓑雨笠转单行？一任俺芒鞋破钵随缘化！”，再有黛玉对众人玩笑自己像戏子的不满，继而引起湘云的不快。作为宝玉，在心系黛玉又关心湘云的情况下，接连遭受到自己所珍视的两个妹妹的脸色，也难过自己会生出一些不一样的情绪来。\n在此之前，宝玉内心一直感觉自己是和众姐妹一起的，虽然和以父亲为代表的官僚作风为敌，但倒了内心还有所归宿。可是经过这一系列的事情，宝玉又发觉姐妹们也不是那么的团结友好。因此宝玉说出了，“什么‘大家彼此’？他们有‘大家彼此’，我只是赤条条无牵挂的！”。\n那作为一个富有诗书的文人难过时候应该怎么办呢？当然是奋笔写东西啦，把自己的内心所想变为高雅的文字，不仅能抒发自己的感情，也可以留下来一些情感的记录。想到这里，其实便意识到为什么有时候很理解贾宝玉，毕竟作为一名理工科的男生，还是很羡慕这种有话便可以寄托给文字的天赋。\n“从前碌碌却因何？到如今回头试想真无趣！”，有时候我也在想，如果宝玉在悟到碌碌却因何之后，选择不再沉迷脂粉，而是选择做一些“功名文章”，那么红楼梦还会是一场悲剧吗？可惜，贾宝玉终究是贾宝玉，离了姐妹，就能“真有趣”了吗？恐怕也不尽然。\n三、不知将来葬我洒泪者谁\n悟道之后，第三十六回《绣鸳鸯梦兆绦芸轩 识分定情悟梨香院》中宝玉的“不知将来葬我洒泪者谁”，则更是体验出了宝玉的孤独感。纵使周围玩伴看似众多，却不知谁在是真正与自己志同道合之人。\n在这一回中，我们见到了宝钗与宝玉的志不同不足为谋。甚至于宝玉说出了“好好的一个清净洁白的女子，也学的钓名沽誉，入了国贼禄鬼之流”，这种不顾及宝钗颜面的话，从而我们开始能切身体会到黛玉与宝玉的那种互为知己之情。\n而宝玉发出“不知将来葬我洒泪者谁”也是有所前因的。在这之前，因袭人与宝玉开玩笑说自己要走。二人谈论到“人活百年，横竖要死”，宝玉兴起便也发出自己的看法。古人常说“文死谏”“武死战”，这也是我们今人所为之京津乐道的。宝玉确认他们都是沽名钓誉，不知君臣大义之辈。继而宝玉表达出了自己对待死亡的看法：“比如我此时若果有造化，趁着你们都在眼前，我就死了，再能够你们哭我的眼泪，流成大河，把我的尸首漂起来，送到那雅雀不到的幽癖去处，随风化了，自此再不托生为人，这就是我死的得时了。”。可见宝玉对死亡的追高追求还是能收到自己所珍重之人的关心，然后能逃避自己所不屑之人的注意，这也就实现了宝玉的抱负。\n我们从中其实可以体会到宝玉的一种归属感，他其实也是想要“功成名就”，只不过他所希望更多的是身边的这些“脂粉佳人”。\n让宝玉又一次“怀疑人生”的是梨香院中十二女孩中的玲官，也就是那个前文所述被玩笑眉眼像林妹妹的小戏子。原文中也说过宝玉“因素昔与别的女孩子玩惯了的，只当玲官也和别人一样”，可以理解宝玉此时的心情，更何况这个小戏子还和黛玉长得相像。然而真的可以“和别人一样”吗？“玲官见他坐下，忙抬起身来躲避。”，又说“嗓子哑了，前儿娘娘传进我们去，我还没有唱呢。”。宝玉心里很显然是一种羞愧和紧张，“从来未经过这样被人弃厌，自己便讪讪的，红了脸，只得出来了。”而药官告诉宝玉，只等蔷二爷来了叫她唱便必唱得。从第三十回《宝钗借扇机带双敲椿龄画蔷痴及局外》中，读者可以发现玲官是心系贾蔷的。而后蔷二爷真的过来了，宝玉看二人的“打情骂俏”也“不觉痴了”。\n被一个在自己与林妹妹等人等同的女子拒绝，又见她与另一名男子关系如此和谐，也难过宝玉会心生惆怅。宝玉此时也难得同意了老爷的看法，承认老爷说自己“管窥蠡测”。宝玉也悟出了“昨夜说你们的眼泪单葬我，这就错了。看来我竟不能全得。从此后，只好各人得各人的眼泪罢了”。\n“不知将来葬我洒泪者谁”与黛玉《葬花词》中“侬今葬花人笑痴，他年葬侬知是谁”有异曲同工之妙。恰巧此时黛玉也在身旁，不过黛玉却没有把这话接过去，而是不便多问换了一个话题。我认为黛玉此时的反应正是表达了黛玉是很懂宝玉的想法的，不然若让黛玉接着这个话题聊下去，甚至说一句“我肯定心系于你”也不恰当。宝玉也没有继续谈论这个话题，我们还是可以体会到二人之间的小默契的。\n四、始信黄土隆中，女儿命薄\n晴雯是我个人非常喜欢的一位角色，虽说“晴为黛影”，但晴雯本身也有着黛玉不一样的色彩。晴雯比起黛玉更多了一份活泼，一幕晴雯撕扇，也让读者感受到这样一位女子的魅力。然而，“霁月难逢，彩云易散”，到底晴雯因为丫鬟身份而遭受诽谤，最终殒命怡红院外。\n贾宝玉生平最怕写一些有固定格式的文章，然而此次却出奇地写出了一篇精彩的诔文，这便是《芙蓉女儿诔》。文中最为人所熟知的，恐怕应属“岂道红绡账里，公子情深；始信黄土陇中，女儿命薄”。不仅是这两句直指“公子”与“女儿”，也因后文中黛玉与宝玉谈论过这两句。\n《芙蓉女儿诔》的出现已是红楼梦的第七十八回《老学士闲征姽媜词 痴公子杜撰芙蓉诔》（一说为《老学士闲征姽婳词　痴公子杜撰芙蓉诔》），我们知道目前公认原作为前八十回，此时已近尾声。除去一早便离世的秦可卿，晴雯之死，开启了《金陵十二钗》正册、副册、又副册女子的归宿。有人不理解为什么宝玉会为晴雯写下一篇《芙蓉女儿诔》，而当黛玉去世时却好像毫无作为。这当然一方面是黛玉去世之时已是后四十回，我们无从简单原作者如何安排。况且已经有了一篇为“芙蓉女儿”作的诔文，也无需再来一遍。但我们分析起来也可以理解，宝玉的《芙蓉女儿诔》可能更多的还是有一丝卖弄文采之意。尤其在后一回开始之时与黛玉探讨，宝玉也“笑答道”：“原不过是我一时的玩意儿，谁知被你听见了。”。后来二人又咬文嚼字，商议出“茜纱窗下，我本无缘；黄土陇中，卿何薄命”，这一句放在当时的情境下，也可以说是假若黛玉去世，宝玉用这一句来奠念。因此“黛玉听了，陡然变色”，可能黛玉也发觉这句话有所不妥吧。这时大概已经出了为晴雯祭奠的情感，而开始了二人的沟通。\n我们可以猜想宝玉此时是何种心情，面对一个自己所爱之人，他可能也不想黛玉看见自己为另一个女子太过哀伤。在失去众多姐妹以至怀疑人生之时，所幸宝玉终于意识到了黛玉对自己的意义。那是纵使离开群芳之后仍能有一人为伴的欣喜，那是世人皆不解我唯有一人能懂我之真心的感动，那是舍世界愿为伊人一生的希冀。可惜，个人的力量在世俗的庞然大物下略显单薄，更何况贾宝玉内心又太过软弱。\n可能很多人无法理解贾宝玉为何能“百花丛中过，片叶不沾身”（当然这属于广义的，和贾宝玉有实质关系的女子，甚至推测有过的男子也是存在的）。我认为这其中的本质原因是贾宝玉从始至终都不是为了色欲（甚至可以说是爱情）才去接近一个女子的。无论宝玉爱吃胭脂，或是喜爱与姐妹丫头们嬉戏玩耍，都源自于内心对美丽事物的向往。这也是我愿意相信宝玉与蒋玉函可能真的有一定关系的原因，因为琪官此时象征着美好，而无关性别。当抛开性去思考贾宝玉的所作所为，我们不难看出宝玉只是单纯地想接近于这些美好。只不过用后来人的眼光来看，宝玉并没有能力去保护这些美好。\n想起张爱玲平生所言有“三大恨”：一恨海棠无香；二恨鲥鱼多刺；三恨红楼未完。虽然广为流传的高鹗所续后四十回补完了红楼梦的结局，却被称之为狗尾续貂。确实，后文与前文的精妙之处可谓天渊之别。作为计算机专业的一名学生，也曾在网上看到一篇用人工智能与深度学习技术分析红楼梦前八十回与后四十回的论文。得出的结论就是，两者画风截然不同，可以预见的是如果前八十回按照后文一般撰写，那红楼梦也不可能传为经典了。\n红楼梦作为一本文学史上的重要著作，确是一本没有结局的小说。本来作为情节取胜的小说这一文体，能在缺少结局的情况下得到如此高的评价，也从另一方面体现了其内蕴的深厚。这可能就是一种残缺美吧，它把红楼这幅人生画卷带给读者，又把下卷的白纸留给读者自己绘制。\n不过话虽如此，到了我们无从得知宝玉的结局如何。可能作为计算机领域的一员，未来或许希望根据前文内容通过建立语法树，借由计算机推测出原版结局云云。但对每个人来说或许也不是那么重要了，因为每个人心中早已有了自己的“贾宝玉”。\n《红楼梦》，曹雪芹\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n《贾宝玉的年龄推断》，文哲\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2018-05-07T04:33:53Z","permalink":"https://boiltask.com/record/qzone-1525667602/","title":"论贾宝玉的心路历程"},{"content":" 参考《计算机图形学基础(OpenGL版)》与网上资料。\n第1章 什么是计算机图形学，它主要研究内容？ 计算机图形学是一门研究用计算机将数据转换成图形，并在专用设备上显示和处理的学科，它着重研究图形生成和处理的原理、方法和技术，是一门多学科综合应用的新技术。\n其涵盖图学理论、应用数学、计算机科学等学科。\n主要研究内容：\n围绕：图形处理过程中的软、硬件技术、表示图形和图像的准确性、真实性和实时性。\n包括：研究内容分为九个方向。\n基于设备的基本图形生成算法，如直线、圆弧等； 图形元素的裁剪和几何变换技术； 曲线和曲面的处理技术：插值、拟合、拼接和分解； 三维几何造型技术； 三维形体的实时显示和图形的并行处理技术； 真实感图形生成技术和仿真模拟系统； 随机形体或模糊景物的模拟生成技术； 虚拟现实环境的生成和控制技术； 三维或高维数据场的可视化技术 图形的构成要素和表示方法？ 图形的构成要素 几何要素：刻画对象的轮廓、形状等； 非几何要素：刻画对象的颜色、材质等。 图形的表示方法 点阵表示：枚举出图形中所有的点, 简称为图像； 参数表示：形状参数+属性参数，简称为图形。 第2章 请简要总结图形系统体系结构的三个阶段的任务、内容与特点。 图形学系统体系结构的三个阶段：应用程序阶段、几何处理阶段、像素处理阶段。\n应用程序阶段：把数据以图元的形式提供给图形硬件，同时也提供用于表面纹理映射的图像或者位图。开发者能够对该阶段发生的情况进行完全控制，可以通过改变实现方法来改变实际性能。在应用程序阶段的末端，将需要绘制的几何体输入到绘制管线的下一阶段。\n几何处理阶段：以每个顶点为基础对几何图元进行处理，并从三维坐标变换为二维屏幕坐标的过程。几何处理阶段主要负责大部分多边形和顶点操作，可以将这个阶段进行划分为模型与视点变换、光照、投影、裁剪、屏幕影射等几个功能阶段。根据具体的实现，这现阶段可以和管线通道等同也可以不同。几何处理阶段执行的是计算量非常大的任务。\n像素处理阶段：屏幕对象先是被传送到像素处理器进行光栅化，再对每个像素进行着色，然后，然后再输出到帧缓冲器中，最后输出到显示器。当图元发送并通过光栅阶段之后，从相机视点处看到的东西就可以在屏幕上显示出来，这些图元可以用合适的着色模型进行绘制，如果运用纹理技术，就会显示出纹理效果。不像几何阶段进行的多边形操作，光栅阶段进行的是单个像素操作。对于高性能图形系统来说，光栅阶段必须在硬件中完成。\n从图形硬件显示原理角度，思考并分析如何显示直线？ 当电子束扫描到屏幕上某一像素的位置（坐标）时，显示器中的处理器DPU会同时从对应的显示缓冲单元中取出像素值，并以此查找彩色表的地址，从该地址处得到该像素的红、绿、蓝三基色分量，经D/A转换后分别控制三基色电子枪，使屏幕上该像素显示出三基色的混合色。要显示直线只需根据构成直线的方程找出所有符合方程的点，并在屏幕完整显示出由计算机画出的图形。\n计算机图形系统由哪几部分组成，各自实现什么功能？ 由图形软件和图形硬件组成。硬件设备是计算机图形学存在与发展的物质基础，主要由中央主机（图形显示处理器）、图形输入设备、图形输出设备组成。图形软件又分为图形应用软件、图形支撑软件和图形应用数据结构三部分，并与外部的图形设备接口，三者之间相互联系，互相调用，互相支持，形成图形系统的软件部分。\n常用的图形输入、输出设备有哪些？各有何特点？ 定位设备：实现定位功能，即输入一个点的坐标，包括光笔、数字化仪、鼠标、键盘的数字键等。\n笔划设备：实现描划功能，输入一系列点的坐标，包括的物理设备和定位设备一致。\n数值设备：实现定值功能，包括旋钮、数字键、方向键、编程功能键等。\n选择设备：根据一个正整数得到某一种选择，包括光笔、触摸板、数字化仪、鼠标等。\n拾取设备：实现拾取功能，即识别一个显示的图形元素，包括各种定位设备、编程功能键、字符串输入设备。\n字符串设备：实现字符串输入，包括键盘、光笔、声音识别仪等。\n图形显示设备：液晶显示器等显示图形设备。\n图形绘制设备：打印机、绘图仪等输出可视化且能长期保存图形的输出设备。\n图形软件分为几层？各个层有什么特点？ 软件系统由零层图形软件(驱动程序、接口程序)、一层图形软件(基本子程序)、二层图形软件(通用程序)、三层图形软件(应用程序)，零到二级软件称:基本图形软件或支撑软件，三级及以上软件:应用图形软件。\n图形支撑软件通常可分为如下三个层次，第一层次面向系统，是最底层的软件，又称设备驱动程序，主要解决图形设备与计算机的通信接口等问题，包括一些最基本的输入、输出程序。第二层次既面向系统又面向用户，它建立在设备驱动程序之上，又称为基本子程序，包括图元的生成、设备的管理等各程序模块。第三层次面向用户，在基本子程序的基础上编写，又称功能子程序，其主要任务是建立图形数据结构，定义、修改和输出图形。\n熟悉光栅扫描显示系统的结构。 光栅扫描显示系统的逻辑组成主要有三部分：显示器、视频控制器和帧缓冲存储器。早期的光栅扫描显示系统经典结构：CPU、系统主存、显示控制器、显示器，帧缓存可在系统主存的任意位置，显示控制器访问帧缓存，以刷新屏幕，但此时显示控制器访问帧缓存均需通过系统总线，故总线成为系统的主要瓶颈。目前常用的：CPU、系统主存-帧缓存、显示控制器、显示器，帧缓存由显示控制器直接访问，它既可以使用系统主存的固定区域，又可以是专用的显示内存，扫描转换的计算量相当大会加重CPU的负担。高级光栅图形系统结构除了帧缓存和显示控制器外，它还包含显示处理器和独立的显示处理器存储器。\n了解分辨率、帧缓存、像素、像距等常用词语的含义。 分辨率：显示屏上像素的总数，分为水平分辨率和垂直分辨率，常用屏幕上像素的数目来表示。分辨率越高，像距离越小，显示字符或图像越清晰。\n帧缓存：帧缓冲存储器简称帧缓存或显存，它是屏幕所显示画面的一个直接映象，又称为位映射图或光栅。帧缓存是一块连续的计算机存储器，用来存储动态刷新的图形图像信息。帧缓存的每一存储单元对应屏幕上的一个像素，整个帧缓存对应一帧图像。\n像素：在光栅扫描图形显示器中，屏幕上可以点亮或熄灭的最小单位。\n像距：像到屏幕的距离。\n行频、帧频：水平扫描频率为行频。垂直扫描频率为帧频。\n隔行扫描：先扫偶数行扫描线，再扫奇数行扫描线。\n显示速度：显示字符、图形、图像的速度。\n点距：LCD的点距是两个液晶颗粒之间的距离，液晶面板的宽或高除以水平像素数或垂直像素数。\n刷新率：LCD中每个像素都在一定的信号（电压）下持续不断的发光，直到另一个信号（电压）来到时才会改变发光强度，所以其实LCD不存在刷新率的问题。\n视角：可视角度。\n响应时间：响应时间过长将导致画面快速变化时出现残影。\n亮度：亮度指画面的明亮程度，最大亮度通常由背光源来决定。\n对比度：指屏幕上同一点最亮时（白色）与最暗时（黑色）的亮度的比值。高对比度意味着有相对较高的亮度和艳丽程度。\n第3章 简述DDA算法、中点画线法、Bresenham算法的算法思想。 DDA算法称为数值微分画线算法，根据斜率的偏移程度，决定是以x为步进方向还是以y为步进方向，然后在相应的步进方向上，步进向量每次增加一个像素，而另一个相关坐标变量也可根据斜率求出。\n中点画线法假定直线斜率k在0~1之间，当前像素点为（xp，yp），则下一个像素点有两种可选择点P1（xp+1，yp）或p2（xp+1，yp+1）。若p1与p2的重点（xp+1，yp+0.5）称为M，Q为理想直线与x=xp+1垂线的交点，当M在Q的下方时，则取p2应为下一个像素点，当M在Q的上方时，则应取P1为下一个像素点，其他斜率同理。\nBresenham算法过各行、各列像素中心构造一组虚拟网格线，按直线从起点到终点的顺序计算直线各垂直网格线的交点，然后确定该列像素中与此交点最近的像素。可以采用增量计算，使得对于每一列，只要检查一个误差项的符号，就可以确定该列所求的像素。\n写出Bresenham画线算法的过程或画出其流程图。 直线起点赋予动点P(x,y)； 求端点坐标差：dx和dy； 求出循环总步数N 起点处的di的值； 循环计算中间插值点坐标： 若当前步数≥N，程序结束。 否则： 显示当前点P； 若di大于0，y坐标加1； 计算当前的di值； x坐标加1。 直线的属性有哪些？ 直线的属性包括线型、线宽和线的颜色等。\n线型：线型表示不同的实体形状。 线宽：用有宽度的线型表示实体表面的形状和位置。 线色：系统颜色，用颜色模型空间定义，如RGB模型等。调用方法，采用专用函数来设定不同的颜色值。图形用色，处理两种颜色，背景色和前景色。背景色，绘制系统背景界面所定义颜色。前景色，绘制图形所需要各种颜色。 圆弧生成的常用算法有哪些？ 逐点比较法、中点画圆法、Bresenham算法、角度离散法等。\n逐点比较法：设定在不同象限中的走步方向，原则使逼近的误差最小且走笔方向和画图的趋势一致，根据误差判别式确定下一个像素。\n中点画圆法：利用圆的8路对称方法，考虑圆心在原点，半径为R的圆在第一象限内的八分之一圆弧，从点（0, R）到点（R’ , R’ ）顺时针方向确定这段圆弧。假定某点Pi(xi, yi)已经是该圆弧上最接近实际圆弧的点，那么Pi的下一个点只可能是正右方的P1或右下方的P2两者之一。构造判别函数F(x, y）= x2 + y2 – R2，将重点M带入函数，若F(M)\u0026lt;0，M在圆内，此时下一个点取T；若F(M)≥0，M在圆上或圆外，此时下一个点取S，以此类推。\nBresenham算法：Bresenham画圆算法适合于生成整圆，用误差量来衡量点选取的逼近程度，它使用8路对称法，只计算出90°~45°内的点，移动方向为+x，-y。设（xi，yi）是扫描到第i步时选定的坐标，下一个被选定的可能是T或S。根据坐标到原点距离的平方与半径的平方之差的的关系可选择T或S继而可生成整圆。\n圆弧生成算法的误差判别采用哪种模型？ 当前点到圆心的距离与半径的平方差值。\n完整圆弧最快的算法是什么？ Bresenham算法。\n解释：逼近、插值、控制点、型值点等名词 逼近：通过建立数学模型，要求构造的曲线在某种意义下最为接近给定的数据点，称为对这些数据点进行逼近，所构造的曲线称为逼近曲线。\n插值：给定一组有序的数据点Pi(i=0，1，2，……，n)，通过建立数学模型构造一条曲线，使其顺序通过数据点，所构造的曲线称为插值曲线。\n拟合：插值和逼近方法的统称。\n型值点: 通过测量或计算得到的曲线上描述曲线几何形状的数据点。\n控制点: 用来控制或调整曲线形状的形状特殊点，而曲线本身不通过该点。\n解释名词：区域、区域填充、种子、活性边。 区域：一组相邻而且又相连的像素，而且具有相同属性的封闭区域。\n区域填充：在区域内确定种子，并将这种属性扩展到整个区域的过程。 种子：具有一定填充属性单位的像素或像素组合。\n活性边：与当前扫描线相交的边界线的边。\n掌握区域内点的测试方法。 射线法：从点P向任意方向发出一条射线，若该射线与多边形交点的个数为奇数，则P位于多边形内；若为偶数，则P位于多边形外部。但需注意射线与多边形边界点交点是顶点时（奇点），需根据极值点（顶点相邻的两边在射线的同侧）和非极值点采用不同方式计算（极值点交点按两个交点计算否则按一个计算）。\n弧长法：假定多边形是由有向边组成，以被测点为圆心作单位圆，将全部有向边向单位圆作径向投影，计算单位圆上各边投影的代数和。若代数和为0，则被测点在多边形之外；若代数和为2π，则被测点在多边形之内。\n综合：从起点P发出向右侧的射线，若遇到方向向上的边与射线相交，则计数器加1，遇到方向向下的边与射线相交，计数器减1。当最后的计数器为0时，P点在多边形的外部，但也需注意奇点的处理。\n能准确区分区域的连通性。 4连通区域：从区域上的一点出发，通过访问已知点的4邻接点，在不越出区域的前提下，遍历区域内的所有象素点。\n8连通区域：从区域上的一点出发，通过访问已知点的8邻接点，在不越出区域的前提下，遍历区域内的所有象素点。\n理解掌握区域、扫描线、边界连续性。 具有相同颜色或图案属性的连片像素即区域。对区域中所有像素填充着色的过程称为区域填充。区域的定义有两类：一类是给定顶点序列定义的封闭多边形。第二类区域是由所有已知边界像素包围起来的部分，它是由点阵方式描述的区域。第二类区域又有两种不同的定义：一种是边界定义的区域，另一种是内定义区域。\n扫描线算法利用区域的连续性、扫描线的连续性、边界连续性，确定水平扫描线与多边形的相交区间，把该区间内的所有像素一次性赋予新的颜色值。\n边界连续性：把边界的端点按其y坐标排列，y0,y1,…..,yi，yik≥yik+1，0 ≤ k ≤ n-1，交点数相等；同编号的点位于同一条边上。\n了解掌握扫描线填充算法的原理与步骤。 扫描线填充算法充分利用了多边形边界与上下两条相邻扫描线的交点之间的连续性以及同一扫描线上像素之间的连续性。\n对于每条扫描线，分以下3个步骤：\n求交点，计算当前扫描线与多边形所有边的交点。\n排序与配对，把所有交点按x值递增顺序排序，排序后的交点两两配成区间。\n填色，将各区间内的像素值设置为目标颜色值。\n把区域边界顶点按Y坐标排序； 确定扫描线的区间； 构建边界边的活性边表； 求交点； 交点排序； 交点配对； 填充颜色 写出DDA画线算法的原理。 写出DDA画线算法的原理。\n掌握区域填充算法的分类和扫描线算法的步骤。 区域填充算法\n扫描线填充算法——扫描线顺序 有序边表算法 边填充算法 种子填充算法——内部一个点出发 简单种子算法 扫描线种子算法 图案填充算法——填充有结构的图形 影线填充算法 图像填充算法 图形系统中常用的字符有几种？ 字符生成方法有点阵式、矢量式和编码式。\n常用的字符有：\nASCII码 汉字字符 其它字符 其它工程专用符号。 字符的图形表示方法有几种？有什么特点？ 点阵式字符将字符表示为一个矩形点阵，由点阵中点的不同值表达字符的形状。\n矢量式字符将字符表达为一个点坐标的序列，相邻两点表示一条矢量，字符的形状便由矢量序列刻划。\n第4章 熟记二维变换的基本变换矩阵及其几何特点。 平移变换 原始点：$P=\\begin{bmatrix} x \\\\ y \\end{bmatrix}$，变换点：$P\u0026rsquo;=\\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\end{bmatrix}$，变换矩阵：$T=\\begin{bmatrix} t_{x} \\\\ t_{y} \\end{bmatrix}$\n平移方程：$P\u0026rsquo;=P+T$\n绕坐标原点的旋转变换 原始点：$P=\\begin{bmatrix} x \\\\ y \\end{bmatrix}$，变换点：$P\u0026rsquo;=\\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\end{bmatrix}$，变换矩阵：$R=\\begin{bmatrix} \\cos \\theta \u0026amp; -\\sin \\theta \\\\ \\sin \\theta \u0026amp; \\cos \\theta \\end{bmatrix}$\n变换方程：$P\u0026rsquo;=R\\cdot P$、$\\begin{cases}x\u0026rsquo;=x\\cos \\theta -y\\sin \\theta \\\\ y\u0026rsquo;=x\\sin \\theta -y\\cos \\theta \\end{cases}$\n以坐标原点为基准点的缩放变换 原始点：$P=\\begin{bmatrix} x \\\\ y \\end{bmatrix}$，变换点：$P\u0026rsquo;=\\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\end{bmatrix}$，变换矩阵：$R=\\begin{bmatrix} s_{x} \u0026amp; 0 \\\\ 0 \u0026amp; s_{y} \\end{bmatrix}$\n变换方程：$P\u0026rsquo;=S\\cdot P$\n反射变换 变换方程：$P\u0026rsquo;=T\\cdot P$\n相对于y轴的反射 原始点：$P=\\begin{bmatrix} x \\\\ y \\end{bmatrix}$，变换点：$P\u0026rsquo;=\\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\end{bmatrix}$，变换矩阵：$S=\\begin{bmatrix} 1 \u0026amp; 0 \\\\ 0 \u0026amp; -1 \\end{bmatrix}$\n相对于x轴的反射 原始点：$P=\\begin{bmatrix} x \\\\ y \\end{bmatrix}$，变换点：$P\u0026rsquo;=\\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\end{bmatrix}$，变换矩阵：$S=\\begin{bmatrix} -1 \u0026amp; 0 \\\\ 0 \u0026amp; 1 \\end{bmatrix}$\n相对于坐标原点的反射 原始点：$P=\\begin{bmatrix} x \\\\ y \\end{bmatrix}$，变换点：$P\u0026rsquo;=\\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\end{bmatrix}$，变换矩阵：$S=\\begin{bmatrix} -1 \u0026amp; 0 \\\\ 0 \u0026amp; -1 \\end{bmatrix}$\n相对于任意点的反射 原始点：$P=\\begin{bmatrix} x \\\\ y \\end{bmatrix}$，变换点：$P\u0026rsquo;=\\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\end{bmatrix}$，变换矩阵：先平移再旋转再平移\n关于对角线y=x的反射 原始点：$P=\\begin{bmatrix} x \\\\ y \\end{bmatrix}$，变换点：$P\u0026rsquo;=\\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\end{bmatrix}$，变换矩阵：$S=\\begin{bmatrix} 1 \u0026amp; 0 \\\\ 0 \u0026amp; 1 \\end{bmatrix}$\n关于对角线y=-x的反射 先顺时针45°，对于y轴反射，最后逆时针旋转45°。\n原始点：$P=\\begin{bmatrix} x \\\\ y \\end{bmatrix}$，变换点：$P\u0026rsquo;=\\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\end{bmatrix}$，变换矩阵：$S=\\begin{bmatrix} 0 \u0026amp; -1 \\\\ -1 \u0026amp; 0 \\end{bmatrix}$\n关于任意直线y=mx+b的反射 原始点：$P=\\begin{bmatrix} x \\\\ y \\end{bmatrix}$，变换点：$P\u0026rsquo;=\\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\end{bmatrix}$，变换矩阵：平移-旋转-反射变换\n错切变换 x轴的x方向 原始点：$P=\\begin{bmatrix} x \\\\ y \\end{bmatrix}$，变换点：$P\u0026rsquo;=\\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\end{bmatrix}$，变换矩阵：$S=\\begin{bmatrix} 1 \u0026amp; sh_{x} \\\\ 0 \u0026amp; 1 \\end{bmatrix}$\n变换方程：$P\u0026rsquo;=S\\cdot P$、$x\u0026rsquo;=x+ sh_{x} \\cdot y$、$y\u0026rsquo;=y$\ny轴的y方向 原始点：$P=\\begin{bmatrix} x \\\\ y \\end{bmatrix}$，变换点：$P\u0026rsquo;=\\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\end{bmatrix}$，变换矩阵：$S=\\begin{bmatrix} 1 \u0026amp; 0 \\\\ sh_{y} \u0026amp; 1 \\end{bmatrix}$\n变换方程：$P\u0026rsquo;=S\\cdot P$、$x\u0026rsquo;=x$、$y\u0026rsquo;=y+ sh_{y} \\cdot x$\n变换通式 原始点：$P=\\begin{bmatrix} x \\\\ y \\end{bmatrix}$，变换点：$P\u0026rsquo;=\\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\end{bmatrix}$\n变换方程：$P\u0026rsquo;=M_{1}\\cdot P + M_{2}$\n齐次坐标的定义是什么？ 用n+1维矢量表示n维矢量的方法，称为齐次坐标表示法，n+1维空间的坐标被称为齐次坐标。\n将各种变换用阶数统一的矩阵来表示。 便于表示无穷远点。 齐次坐标变换矩阵是把直线变成直线段，平面变换成平面，多边形变换成多边形，多面体变换成多面体。 变换具有统一表示形式的优点，便于变换合成和硬件实现。 掌握二维、三维基本变换的齐次坐标形式。 平移变换 $\\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\\\ 1 \\end{bmatrix}=\\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; t_{x} \\\\ 0 \u0026amp; 1 \u0026amp; t_{y} \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\cdot \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix}$\n旋转变换 $\\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\\\ 1 \\end{bmatrix}=\\begin{bmatrix} \\cos \\theta \u0026amp; -\\sin \\theta \u0026amp; 0 \\\\ \\sin \\theta \u0026amp; \\cos \\theta \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\cdot \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix}$\n缩放变换 $\\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\\\ 1 \\end{bmatrix}=\\begin{bmatrix} s_{x} \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; s_{y} \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\cdot \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix}$\n反射变换 关于x轴的反射 $\\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\\\ 1 \\end{bmatrix}=\\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; -1 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\cdot \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix}$\n关于y轴的反射 $\\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\\\ 1 \\end{bmatrix}=\\begin{bmatrix} -1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 1 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\cdot \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix}$\n关于原点的反射 $\\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\\\ 1 \\end{bmatrix}=\\begin{bmatrix} -1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; -1 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\cdot \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix}$\n关于对角线y=x的反射 $\\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\\\ 1 \\end{bmatrix}=\\begin{bmatrix} 0 \u0026amp; 1 \u0026amp; 0 \\\\ 1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\cdot \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix}$\n关于对角线y=-x的反射 $\\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\\\ 1 \\end{bmatrix}=\\begin{bmatrix} 0 \u0026amp; -1 \u0026amp; 0 \\\\ -1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\cdot \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix}$\n错切变换 相对于线$y=y_{ref}$的x方向错切 $\\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\\\ 1 \\end{bmatrix}=\\begin{bmatrix} 1 \u0026amp; sh_{x} \u0026amp; -sh_{x}\\cdot y_{ref} \\\\ 0 \u0026amp; 1 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\cdot \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix}$\n相对于线$x=x_{ref}$的y方向错切 $\\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\\\ 1 \\end{bmatrix}=\\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \\\\ sh_{y} \u0026amp; 1 \u0026amp; -sh_{y}\\cdot x_{ref} \\\\ 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\cdot \\begin{bmatrix} x \\\\ y \\\\ 1 \\end{bmatrix}$\n熟记三维变换的基本变换矩阵及其几何特点。 平移变换 $\\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\\\ z\u0026rsquo; \\\\ 1 \\end{bmatrix}=\\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; t_{x} \\\\ 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; t_{y} \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; t_{z} \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\cdot \\begin{bmatrix} x \\\\ y \\\\ z \\\\ 1 \\end{bmatrix}$\n相对于原点的缩放变换 $\\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\\\ z\u0026rsquo; \\\\ 1 \\end{bmatrix}=\\begin{bmatrix} s_{x} \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; s_{y} \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; s_{z} \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\cdot \\begin{bmatrix} x \\\\ y \\\\ z \\\\ 1 \\end{bmatrix}$\n绕三维坐标轴的旋转变换 绕z轴旋转 $\\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\\\ z\u0026rsquo; \\\\ 1 \\end{bmatrix}=\\begin{bmatrix} \\cos \\theta \u0026amp; -\\sin \\theta \u0026amp; 0 \u0026amp; 0 \\\\ \\sin \\theta \u0026amp; \\cos \\theta \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\cdot \\begin{bmatrix} x \\\\ y \\\\ z \\\\ 1 \\end{bmatrix}$\n绕x轴旋转 $\\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\\\ z\u0026rsquo; \\\\ 1 \\end{bmatrix}=\\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; \\cos \\theta \u0026amp; -\\sin \\theta \u0026amp; 0 \\\\ 0 \u0026amp; \\sin \\theta \u0026amp; \\cos \\theta \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\cdot \\begin{bmatrix} x \\\\ y \\\\ z \\\\ 1 \\end{bmatrix}$\n绕y轴旋转 $\\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\\\ z\u0026rsquo; \\\\ 1 \\end{bmatrix}=\\begin{bmatrix} \\cos \\theta \u0026amp; 0 \u0026amp; \\sin \\theta \u0026amp; 0 \\\\ 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \\\\ -\\sin \\theta \u0026amp; 0 \u0026amp; \\cos \\theta \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\cdot \\begin{bmatrix} x \\\\ y \\\\ z \\\\ 1 \\end{bmatrix}$\n反射变换 关于xy平面 $\\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\\\ z\u0026rsquo; \\\\ 1 \\end{bmatrix}=\\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; -1 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\cdot \\begin{bmatrix} x \\\\ y \\\\ z \\\\ 1 \\end{bmatrix}$\n关于yz平面 $\\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\\\ z\u0026rsquo; \\\\ 1 \\end{bmatrix}=\\begin{bmatrix} -1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\cdot \\begin{bmatrix} x \\\\ y \\\\ z \\\\ 1 \\end{bmatrix}$\n关于xz平面 $\\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\\\ z\u0026rsquo; \\\\ 1 \\end{bmatrix}=\\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; -1 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\cdot \\begin{bmatrix} x \\\\ y \\\\ z \\\\ 1 \\end{bmatrix}$\n错切变换 z轴\n$\\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\\\ z\u0026rsquo; \\\\ 1 \\end{bmatrix}=\\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; sh_{zx} \u0026amp; -sh_{zx} \\cdot z_{ref} \\\\ 0 \u0026amp; 1 \u0026amp; sh_{zy} \u0026amp; -sh_{zy} \\cdot z_{ref} \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\cdot \\begin{bmatrix} x \\\\ y \\\\ z \\\\ 1 \\end{bmatrix}$\n变换通式 $T_{3D}=\\begin{bmatrix} a \u0026amp; b \u0026amp; c \u0026amp; l \\\\ d \u0026amp; e \u0026amp; f \u0026amp; m \\\\ h \u0026amp; i \u0026amp; j \u0026amp; n \\\\ p \u0026amp; q \u0026amp; r \u0026amp; s \\end{bmatrix}$\n其中$\\begin{bmatrix} a \u0026amp; b \u0026amp; c \\\\ d \u0026amp; e \u0026amp; f \\\\ h \u0026amp; i \u0026amp; j \\end{bmatrix}$产生比例、旋转、对称、错切等几何变换；$\\begin{bmatrix} 1 \\\\ m \\\\ n \\end{bmatrix}$产生平移变换；$\\begin{bmatrix} p \u0026amp; q \u0026amp; r \\end{bmatrix}$产生透视变换；$\\begin{bmatrix} s \\end{bmatrix}$产生整体比例变换。\n根据图形变化，写出二维组合的变换矩阵。 参考试卷变换综合应用题。\n第5章 Cohen-Sutherland编码裁剪有何缺点？Liang-Barsky参数化裁剪算法如何改进的？ 由于采用按位与运算，对程序的实现有特殊的要求，在有些高级语言中不便进行。\n全部舍弃的判断只适合于那些仅在同一窗口侧的线段，对于跨越了整个区域的线段，就不能一次做出判别而舍弃。\nLiang-Barsky参数化裁剪算法所需的计算量较小，每修改一次只需要一次除法，在u1及u2确定后，直线与窗口边界的交点只需计算一次。\n理解掌握坐标系统的5种坐标系的定义。 建模坐标系 建模坐标系是一个局部坐标系，同时也是一个典型的平面直角坐标系，它的出现主要是为了模型构建与变换的方便。\n世界坐标系 为了确定每一个对象的位置及其与其他对象的相对位置，就必须抛弃每一个对象的自身坐标系，将其纳入一个统一的坐标系，这个坐标系称为世界坐标系，也称用户坐标系，它是一个全局坐标系。\n观察坐标系 当二维图形场景确定后，用户可根据图形显示的要求定义观察区域与观察方向，得到所期望的显示结果，这其实是需要定义视点（或照相机）的位置与方向，完成从观察者角度对整个世界坐标系内的对象进行重新定位和描述，简化后续二维图形在投影面成像的推导和计算。因此，有必要引进观察坐标系。\n规范化设备坐标系 为了使观察处理独立于输出设备，我们可以将对象描述转换到一个中间坐标系，这个坐标系既独立于设备，又可容易地转变成设备坐标系。通常将这个中间坐标系称为规范化设备坐标系。\n设备坐标系 为了便于输出二维观察结果，设备坐标系用于定义图像空间，也可称为屏幕坐标系或像素坐标系。\n解释用户域、窗口、屏幕域和视区的概念。 用户域：用户空间，用户用来定义和设计对象的实数域，是连续的、无限的。 窗口区：用户把用户域中指定任意的区域输出到屏幕上。 屏幕域：图形设备上用来输出图形的最大区域，它是有限的、不连续的整数域。\n视图区：屏幕域中定义的显示图形的区域，称为视图区。\n理解掌握窗口到视区变换方程的矩阵形式。 窗口w，视区v：$\\begin{bmatrix} x_{v} \u0026amp; y_{v} \u0026amp; 1 \\end{bmatrix}=\\begin{bmatrix} x_{w} \u0026amp; y_{w} \u0026amp; 1 \\end{bmatrix} \\cdot \\begin{bmatrix} a \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; -c \u0026amp; 0 \\\\ b \u0026amp; d \u0026amp; 1 \\end{bmatrix}$\n$X_{v}=X_{v1}+\\dfrac{X_{v2}-X_{v1}}{X_{w2}-X_{w1}}(X_{w} - X_{w1})$\n$Y_{v}=Y_{v1}+\\dfrac{Y_{v2}-Y_{v1}}{Y_{w2}-Y_{w1}}(Y_{w} - Y_{w1})$\n若视区大小不变，窗口缩小或放大，会使图形放大或缩小。\n若窗口大小不变，视区缩小或放大，会使图形跟着缩小或放大。\n若窗口与视区大小相同时，则图形大小比例不变。\n若视区与窗口纵横比不同时，则图形会产生伸缩变形。\n写出直线段编码裁剪算法的原理和步骤。 编码裁剪算法 把窗口边界延长分成9个区，每个区用四位二进制数进行编码，根据编码的值或逻辑运算进行位置判断。\n如果线段两个端点的4位编码全为0，则此线段在窗口内，可直接输出； 若线段两端点的编码逻辑与（位乘）不为0，则线段全部在窗口之外，舍弃； 除上之外，线段与窗口有交点，求交点。求直线与窗口边界的交点，用交点分割线段，舍弃交点以外部分；以交点为界进一步求交判断，并进行分割；裁剪的次序：按编码值；结束标志：编码值全部为零。 中点分割算法 二分法递归搜索方法，看中点是否在区域内并递归计算。\n矢量(梁友栋)裁剪算法 确定始、终边；求直线与窗边交点；求始边两交点中距离P2最近点，赋予Ps；求终边两交点中距离P1最近点，赋予Pe；输出有效线段PsPe。\n快速裁剪算法 判断直线是否完全在窗内 端点的X坐标相同，若不成立 求P1 P2直线的斜率 根据k值计算判别式的值若不大于0 求直线和窗口四条边界的交点并单向排序 取出中间两点组成窗内线段输出。 排序裁剪算法 详见参考资料。\n写出多边形逐边裁剪算法的原理和步骤。 多边形的裁剪算法分为：逐边裁剪法和双边裁剪法。\n逐边裁剪法 先把待裁的多边形的顶点组成有序的点列； 相邻两点组成边，如P1P2,P3P4,…,PnP1，共N条边； 用窗口的四条边依次裁剪多边形的每个边，并求出有效交点。 把有效端点连接起来，组成新的多边形。 双边裁剪法 把多边形顶点按逆时针排成一个有序的点环； 按多边形的排序方法把窗口顶点排序； 从多边形的任意顶点出发，顺着环方向搜索多边形顶点，位于窗内的顶点和多边形与窗口的有效交点； 遇到入点时，不改变搜索方向。 遇到出点时，改变搜索方向： 在出点处转弯，转弯方向和顶点排序方向一致； 沿窗口有效边方向前进，搜索到该边和多边形的交点，直到遇到新交点时为止。 当遇到新交点时，抬笔返回到原来的出点。 然后沿原来方向继续搜索。 到达搜索起点使结束。 某直线端点的编码为0010，写出其端点坐标和窗口四条边界的关系？ 应在最右边中间区，在窗口之外。\n第6章 理解掌握投影的定义、分类。 通常把三维物体变为二维图形表示的过程称为投影变换。\n根据投影中心与投影平面之间距离的不同，投影可分为平行投影和透视投影。\n理解掌握三视图形成的变换矩阵。 主视图 $\\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\\\ z\u0026rsquo; \\\\ 1 \\end{bmatrix}=T_{v} \\cdot \\begin{bmatrix} x \\\\ y \\\\ z \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\cdot \\begin{bmatrix} x \\\\ y \\\\ z \\\\ 1 \\end{bmatrix}$\n俯视图 $\\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\\\ z\u0026rsquo; \\\\ 1 \\end{bmatrix}=T_{v} \\cdot \\begin{bmatrix} x \\\\ y \\\\ z \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; -1 \u0026amp; 0 \u0026amp; -z_{0} \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\cdot \\begin{bmatrix} x \\\\ y \\\\ z \\\\ 1 \\end{bmatrix}$\n侧视图 $\\begin{bmatrix} x\u0026rsquo; \\\\ y\u0026rsquo; \\\\ z\u0026rsquo; \\\\ 1 \\end{bmatrix}=T_{v} \\cdot \\begin{bmatrix} x \\\\ y \\\\ z \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} 0 \u0026amp; -1 \u0026amp; 0 \u0026amp; -x_{0} \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix} \\cdot \\begin{bmatrix} x \\\\ y \\\\ z \\\\ 1 \\end{bmatrix}$\n理解三维观察过程中的坐标形式及其转化。 轴侧图是用平行投影的方法在二维平面上产生同时反映物体长、宽、高三个方向形状的一种立体图。\n先使形体绕z轴正转α角： $T_{1}=\\begin{bmatrix} \\cos \\alpha \u0026amp; \\sin \\alpha \u0026amp; 0 \u0026amp; 0 \\\\ -\\sin \\alpha \u0026amp; \\cos \\alpha \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$\n再使形体绕x轴反转β（β\u0026lt;0）角 ： $T_{2}=\\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; \\cos \\beta \u0026amp; \\sin \\beta \u0026amp; 0 \\\\ 0 \u0026amp; -\\sin \\beta \u0026amp; \\cos \\beta \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$\n使形体向xoz面压缩 ： $T_{3}=\\begin{bmatrix} 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 1 \u0026amp; 0 \\\\ 0 \u0026amp; 0 \u0026amp; 0 \u0026amp; 1 \\end{bmatrix}$\n轴测图的变换矩阵 ： $T=T_{1}\\cdot T_{2}\\cdot T_{3}$\n第7章 什么是实体？实体有哪些属性？ 空间点的集合，或由封闭表面围成的空间，是非空、有界的封闭的点集。\n形状不变性：一个实体必须具有不变的形状，形状与实体的位置与方向无关。\n维度一致性：实体的各个部分均应是三维的，不存在孤点、悬边等。\n空间有限性：占有有限空间、边界确定且封闭。\n实体边界的性质：\n连通性：任意两点之间总存在一条路径。\n有界性：实体表面将空间分为两部分，其中一部分是有界的。\n定向性：表面两侧明显定义出属于实体的内侧和外侧。\n非自交性：实体表面不能自身相交。\n闭合性：每条边有两个且只有两个点，每条边连接两个或两个以上的面。\n构成实体基本元素有哪些？描述实体的信息哪几部分？ 构成实体的基本元素：点、边、环、面、体\n描述实体的信息：几何信息、拓扑信息\n欧拉公式是判断实体的条件和公式是什么？ 符合欧拉公式的多面体不一定是实体，欧拉计算公式只是检查实体有效性的必要条件\n简单多面体：\nV：顶点数，E：边数，F：表面数\n$$V-E+F=2$$非简单多面体：\nH：多面体表面上孔个数，G：贯穿多面体的孔个数，C：表示独立、不相连的多面体数。\n$$V–E+F–H=2(C–G)$$实体的表示方法有几种？ 边界表示 扫描表示 构造几何实体表示（CSG） 空间细分表示 理解参数曲线连续性的数学意义和几何意义。 工程上所用到的曲线一般要求为平滑曲线，且要按照指定的点序列来生成，这就是样条曲线。样条曲线是由多项式曲线段连接而成的曲线，要求相邻线段的边界处满足特定的连续定条件。\n掌握H曲线的矩阵形式和调和函数以及端点切矢对曲线形状的影响。 矩阵形式：\n$$Q(t)=\\begin{bmatrix} t^{3} \u0026 t^{2} \u0026 t \u0026 1 \\end{bmatrix} \\cdot \\begin{bmatrix} a \\\\\\ b \\\\\\ c \\\\\\ d \\end{bmatrix}(0 \\le t \\le 1)$$调和函数：\n$$\r\\begin{aligned}\rFh(t) \u0026= T \\cdot Mh \\\\\r\u0026= \\begin{bmatrix} t^3 \u0026 t^2 \u0026 t \u0026 1 \\end{bmatrix} \\cdot \\begin{bmatrix} 2 \u0026 -2 \u0026 1 \u0026 1 \\\\ -3 \u0026 3 \u0026 -2 \u0026 -1 \\\\ 0 \u0026 0 \u0026 1 \u0026 0 \\\\ 1 \u0026 0 \u0026 0 \u0026 0 \\end{bmatrix} \\\\\r\u0026= \\begin{bmatrix} Fh1 \u0026 Fh2 \u0026 Fh3 \u0026 Fh4 \\end{bmatrix}\r\\end{aligned}\r$$切线矢量：\n切线方向：当其长度不变时，随着切线的角度增加，切线的凸包性也增加。\n切线大小：曲线两端点的切矢为Q\u0026rsquo;(0)和Q\u0026rsquo;(1)，单位矢量分别为：$E_{0}=\\dfrac{Q\u0026rsquo;\\left( 0\\right) }{\\left| Q\u0026rsquo;\\left( 0\\right) \\right| }$、$E_{1}=\\dfrac{Q\u0026rsquo;\\left( 1\\right) }{\\left| Q\u0026rsquo;\\left( 1\\right) \\right| }$ 令：︱Q\u0026rsquo;(0)︱=k0，︱Q\u0026rsquo;(1)︱=k1，则：Q\u0026rsquo;(0)= R0=k0E0，Q\u0026rsquo;(1)=R1=k1E1，改变k0 k1值，改变切线长度，切线的凸包性也增加。\n掌握H曲线段的连续条件和边界条件？ 连续条件 在连接点处，二阶导数连续(一阶导数相等)。\n边界条件 边界条件分为自由端、夹持端、抛物线端和循环端。\n自由端：根据力学条件，两端点处二阶导数为0。\n理解掌握特征多边形与B曲线形状和次数的关系。 B曲线是通过一组多边形折线的顶点来定义的。如果折线的顶点固定不变，则由其定义的Bezier曲线是唯一的。在折线的各顶点中，只有第一点和最后一点在曲线上且作为曲线的起始处和终止处，其他的点用于控制曲线的形状及阶次。\n理解B曲线的性质和端点切矢与边长的关系。 端点性质 Bezier曲线在起点、终点与相应的控制多边形相切，且在起点和终点处的切线方向与控制多边形的第一条边和最后一条边的走向一致。\n对称性 只要保持特征多边形的顶点位置不变，但顺序颠倒，所得新的Beizer曲线形状不变，知识参数变化的方向相反。\n凸包性 Bezier曲线一定落在其控制多边形的凸包中。\n几何不变性 Beizer曲线的形状不随坐标变换而变化，只与各控制顶点的相对位置有关。\n端点处切线长度等于特征多边形首、末边长的n倍。\n工程上所使用的曲线次数不大于3。\n理解掌握B曲线拼接的条件。 在连接处满足C¹和C²连续。\n掌握Bezier和B样条曲线的矩阵形式。\n一次Bezier曲线：\n$Q(t)=\\begin{bmatrix} t \u0026amp; 1 \\end{bmatrix}\\begin{bmatrix} -1 \u0026amp; 1 \\\\ 1 \u0026amp; 0 \\end{bmatrix}\\begin{bmatrix} P_{0} \\\\ P_{1} \\end{bmatrix}$\n二次Bezier曲线：\n$Q(t)=\\begin{bmatrix} t^{2} \u0026amp; t \u0026amp; 1 \\end{bmatrix}\\begin{bmatrix} 1 \u0026amp; -2 \u0026amp; 1 \\\\ -2 \u0026amp; 2 \u0026amp; 0 \\\\ 1 \u0026amp; 0 \u0026amp; 0 \\end{bmatrix}\\begin{bmatrix} P_{0} \\\\ P_{1} \\\\ P_{2} \\end{bmatrix}$\n三次Bezier曲线：\n$Q(t)=\\begin{bmatrix} t^{3} \u0026amp; t^{2} \u0026amp; t \u0026amp; 1 \\end{bmatrix}\\begin{bmatrix} -1 \u0026amp; 3 \u0026amp; -3 \u0026amp; 1 \\\\ 3 \u0026amp; -6 \u0026amp; 3 \u0026amp; 0 \\\\ -3 \u0026amp; 3 \u0026amp; 0 \u0026amp; 0 \\\\ 1 \u0026amp; 0 \u0026amp; 0 \u0026amp; 0 \\end{bmatrix}\\begin{bmatrix} P_{0} \\\\ P_{1} \\\\ P_{2} \\\\ P_{3} \\end{bmatrix}$\n一次B样条曲线：\n$Q_{i,1}(t)=\\begin{bmatrix} t \u0026amp; 1 \\end{bmatrix}\\begin{bmatrix} -1 \u0026amp; 1 \\\\ 1 \u0026amp; 0 \\end{bmatrix}\\begin{bmatrix} P_{0} \\\\ P_{1} \\end{bmatrix}$\n二次B样条曲线：\n$Q_{i,2}(t)=\\begin{bmatrix} t^{2} \u0026amp; t \u0026amp; 1 \\end{bmatrix}\\begin{bmatrix} 1 \u0026amp; -2 \u0026amp; 1 \\\\ -2 \u0026amp; 2 \u0026amp; 0 \\\\ 1 \u0026amp; 1 \u0026amp; 0 \\end{bmatrix}\\begin{bmatrix} P_{0} \\\\ P_{1} \\\\ P_{2} \\end{bmatrix}$\n三次B样条曲线：\n$Q_{i,3}(t)=\\begin{bmatrix} t^{3} \u0026amp; t^{2} \u0026amp; t \u0026amp; 1 \\end{bmatrix}\\begin{bmatrix} -1 \u0026amp; 3 \u0026amp; -3 \u0026amp; 1 \\\\ 3 \u0026amp; -6 \u0026amp; 3 \u0026amp; 0 \\\\ -3 \u0026amp; 0 \u0026amp; 3 \u0026amp; 0 \\\\ 1 \u0026amp; 4 \u0026amp; 1 \u0026amp; 0 \\end{bmatrix}\\begin{bmatrix} P_{0} \\\\ P_{1} \\\\ P_{2} \\\\ P_{3} \\end{bmatrix}$\n掌握特征多边形与Bezier和B样条曲线形状和次数关系。 若给定m+n+1个顶点，则第i段n次等距离分割的B样条曲线函数为\n$$Q_{i,n}\\left( t\\right) =\\sum ^{n}_{i=0}P_{i+1}F_{l,n}\\left( t\\right) , l=0,l\\dots n, t\\in [0,1]$$理解Bezier和B样条曲线的性质和端点条件。 曲线的首末端点位于首末段的中点。\n理解掌握Bezier曲线拼接的条件。 在连接处具有一阶、二阶导数连续。\n熟练掌握3次B样条曲线段端点的作图方法和几何特性。 确定型值点Qi (i=1，2，……… ，n)； 根据曲线类型，建立反求特征点的矩阵形式； 求出多边形的顶点表； 根据精度要求确定插值点数，绘制样条曲线。 反向延伸：\n$P_{1} P_{0}$的延长线上取一点$P_{-1}$，使得： $$P_{-1} P_{0}= P_{0} P_{1}$$ $$P_{n} P_{n+1}= P_{n-1}P_{n}$$ 求得： $$P_{-1}= 2 P_{0} - P_{1}$$ $$P_{4}= 2 P_{3} - P_{2}$$ 重点技术：\n在首末端点处采用重合点，使得： $$P_{-2}\\equiv P_{-1} \\equiv P_{0}$$ $$P_{n+2}\\equiv P_{n+1} \\equiv P_{n}$$ $Q_{-1}$位于$P_{0} P_{1}$的三分之一处。\n理解掌握B样条曲线的局部修改和扩展性质。 当改变一个控制点的位置，最多影响四个曲线段 。\n增加一个控制点，增加一段B样条曲线，原有的B样条曲线不受影响，新增曲线段与原曲线在连接处具有一阶、二阶导数连续。\n理解掌握曲面片的构造条件 曲线相交构成空间网格，所有交点的集合构成了曲面片。\n掌握孔斯曲面的矩阵形式和边界条件 $C=\\begin{bmatrix} P_{00} \u0026amp; P_{01} \u0026amp; P_{00}^{v} \u0026amp; P_{01}^{v} \\\\ P_{10} \u0026amp; P_{11} \u0026amp; P_{10}^{v} \u0026amp; P_{11}^{v} \\\\ P_{00}^{u} \u0026amp; P_{10}^{u} \u0026amp; 0 \u0026amp; 0 \\\\ P_{10}^{u} \u0026amp; P_{11}^{u} \u0026amp; 0 \u0026amp; 0 \\end{bmatrix}$\n四个角点、四条边界、八个切线矢量\n能写出孔斯曲面边界上任意位置矢量的矩阵形式 参考课本与PPT\n理解掌握孔斯曲面片拼接的条件 在拼接处C1连续。\n$P_{10} \\equiv Q_{00}$、$P_{11} \\equiv Q_{01}$\n$P_{10}^{w} \\equiv Q_{00}^{w}$、$P_{11}^{w} \\equiv Q_{01}^{w}$\n$P_{1j}^{u} \\equiv Q_{0j}^{u}$\n$P_{1j}^{u} \\equiv a Q_{0j}^{u}$\n第8章 消隐算法可以分成几类？分类原则是什么？ 根据消隐对象：线消隐、面消隐\n根据消隐算法空间：物体空间消隐算法、图像空间消隐算法\n消隐：消除形体视图中隐藏线（面）的处理过程\n消隐的基本原则：排序、连贯性\n外法线消隐算法的基本原理是什么？写出其算法步骤。 根据外法线在投影方向上的方向余弦进行可见性判断。\n凸多面体 根据表面的数据结构，取顶点数据，计算表面的外法 线矢量； 计算外法线在投影方向上的分量的值; 根据分量的值判断表面的可见性； 当B\u0026gt;0时，0o≤a \u0026lt; 90o，表面面向观察者可见。 若表面可见画出该表面，否则处理下一个表面。 凹多面体 先求出表面的外法线，计算其投影方向上的方向余弦值cosa； 根据方向余弦值，进行可见性判断； 对朝前面计算其表面的最大深度值； 计算朝前面的盒子角点坐标； 取出最大深度值的表面作为当前面； 循环计算其他表面和当前表面的遮挡关系。 深度缓存消隐算法的基本原理是什么？写出其算法步骤。 对于屏幕上的每一个像素，记录位于该像素内最靠近观察者的景物面的深度值，同时相应记录该景物面的颜色(或灰度) 的所有记录值，根据记录的数据输出的图形。\n开辟内存数组；初始化数组；循环计算每个像素点的深度值。\n解释外法线、朝前面、凸多边形。 外法线：由形体内部指向外部，或由形体表面指向外部空间的线。\n朝前面：表示表面法线朝前，该表面可见。\n背向面：表示表面法线向后，该表面不可见。\n凸多边形：多边形任意两点连线均位于多边形内部。\n简述颜色模型，能解释RGB模型空间和常用颜色 颜色模型就是指某个三维颜色空间中的一个可见光子集，它包含某个颜色域的所有颜色。在大多数的彩色图形显示设备一般都是使用红、绿、蓝三原色，我们的真实感图形学中的主要的颜色模型也是RGB模型。\n解释：光照模型、泛光、纯镜面反射光 光照模型：根据光学物理的有关定律，计算物体表面各点投射到观察着眼中的光线的光亮强度和色彩组成的数学表达式。（在已知物体物理形态和光源性质的条件下，能够计算出场景的光照明效果的数学模型）\n$$入射光=漫反射光+镜面反射+环境光$$ 漫反射光：光照射到粗糙、无光泽表面的光现象。 特点：来源一个方向，向各个方向反射。 环境光（泛光）：光照射到粗糙、无光泽表面的光现象。（光源间接对物体的影响，是在物体和环境之间多次反射，最终达到平衡时的一种光） 特点：来源一个方向，向各个方向反射。 镜面反射光：光照射非常光滑的物体表面的光现象 特点：光源来自一个方向，反射光集中在反射方向。 简述简单光反射模型的组成以及构建步骤。 假设：\n光源是点光源 物体不透明 模拟光照射到物体表面产生的反射现象。\n$$入射光=漫反射光+镜面反射光+环境光$$简述双线性插值（亮度或法线）算法的计算过程。 亮度插值法 计算多边形表面的外法线向量； 求多边形各顶点的法矢； 求各顶点的亮度值； 求扫描线与多边形边交点的亮度值； 求扫描线上各点的亮度值。 法矢插值法 求根据顶点信息计算各多边形面的外法线向量； 求多边形各顶点的法向矢量； 求扫描线与多边形边交点的法矢； 求扫描线上点的法矢； 求扫描线上各点的亮度值。 第9章 基本交互技术包括那些技术？ 定位、选择、数值输入、文本输出。\n图形拾取的方式有哪几种？ 点拾取、直线段拾取、区域拾取、加速图形拾取。\n什么是橡皮筋和双缓存技术？二者有何关系？ 橡皮筋技术：橡皮筋是指在绘图时跟随光标的直线和曲线，当光标移动时形状随之变化 即动态变化的过程。\n双缓存技术：在内存中另建一块缓存，当屏幕上图形发生改变时，帧缓存的刷新会在后台执行，在屏幕上看到的只是刷新后并重新绘制后的图形，屏幕变化就会连贯柔和。\n什么是图元组？ 图元组：将一组相关的图元合并成的组\n几何约束主要包括哪几种约束？ 定位约束、方向约束、规则性约束。\n名词解释 构造曲线 给定一组有序的离散点Pi (i=0,1,……，n)，通过这些控制点，可以构造出一条曲线。\n插值曲线 通过建立数学模型构造一条曲线，使曲线顺序通过给定的数据点, 所构造的曲线称为插值曲线。\n型值点 在构造曲线时，曲线顺序通过每一个给定点，这些点称为型值点。\n曲线逼近 当用一组给定的离散点，通过建立数学模型，要求构造的曲线在某种意义下最为接近给定的数据点，称为对这些数据点进行逼近，所构造的曲线称为逼近曲线。\n控制点 用来控制或调整曲线形状的形状特殊点，而曲线本身不通过该点。\n拟合 插值和逼近方法的统称。\n计算机图形学 用计算机建立、存储、处理某个对象的模型，并根据模型产生该对象图形输出的有关理论、方法与技术，称为计算机图形学。 计算机图形标准 计算机图形标准是指图形系统及其相关应用程序中各界面之间进行数据传送和通信的接口标准。 图形消隐 计算机为了反映真实的图形，把隐藏的部分从图中消除。 几何变换 几何变换的基本方法是把变换矩阵作为一个算子，作用到图形一系列顶点的位置矢量，从而得到这些顶点在几何变换后的新的顶点序列，连接新的顶点序列即可得到变换后的图形。 计算几何 计算几何研究几何模型和数据处理的学科，讨论几何形体的计算机表示、分析和综合，研究如何方便灵活、有效地建立几何形体的数学模型以及在计算机中更好地存贮和管理这些模型数据。 裁剪 识别图形在指定区域内和区域外的部分的过程称为裁剪算法，简称裁剪。\n透视投影 空间任意一点的透视投影是投影中心与空间点构成的投影线与投影平面的交点。 投影变换 把三维物体变为二维图形表示的变换称为投影变换。 走样 在光栅显示器上绘制非水平且非垂直的直线或多边形边界时，或多或少会呈现锯齿状。这是由于直线或多边形边界在光栅显示器的对应图形都是由一系列相同亮度的离散像素构成的。这种用离散量表示连续量引起的失真，称为走样（aliasing）。\n反走样 用于减少和消除用离散量表示连续量引起的失真效果的技术，称为反走样。 窗口 世界坐标的范围是无限大的。为了使规格化设备坐标上所显示的世界坐标系中的物体有一个合适的范围与大小，必须首先对世界坐标系指定显示范围，它通常是一个矩形，这个矩形被称为窗口。 视区 在规格化设备坐标系上也要指定一个矩形区域与窗口对应，显示窗口里的内容，这个矩形被称为视区。 坐标系统 为了描述、分析、度量几何物体的大小、形状、位置、方向以及相互之间的各种关系使用的参考框架叫做坐标系统。 用户坐标系 用户坐标系用户为处理自已的图形时所采用的坐标系，单位由用户自己决定。 规范化设备坐标系 将各个设备坐标系中的数据化为统一的数据范围从而得到的设备坐标系。 规格化变换 图形软件根据窗口与视区的一一对应关系，自动实现从世界坐标到规格化设备坐标的转换，这种从窗口到视区的变换，称为规格化变换。\n算法分析题 数值微分法 DDA算法称为数值微分画线算法，是根据直线的微分方程来画直线。根据斜率的偏移程度，决定是以x为步进方向还是以y为步进方向，然后在相应的步进方向上，步进向量每次增加一个像素，而另一个相关坐标变量也可根据斜率求出。\n求得根据直线斜率是否大于1求得dm=max(|△x|,|△y|)。 求得计长方向另一方向的变化步长。 根据计长方向变化为1及求得的另一方向变化步长，循环画点直到计长方向上达到dm结束。 逐点比较法 在绘图的过程中，把每画一笔(走一步)都和标准图形进行比较，然后 确定下一步的走向，用步步逼近的方法画出规定图形。\n设定在不同象限中的走步方向，原则上使逼近的误差最小且使走笔方向和画图的趋势一致。 从起点出发开始画线：开始抬笔到起点。 偏差计算：计算当前点相对于直线的位置偏差。 根据偏差判断公式计算。 根据递推公式计算。 终点判断。 坐标判断：Xm≥Xa，Ym≥Ya 走步数控制：即单向步数和总步数。 Bresenham算法 Bresenham算法是DDA算法的改进，是应用最广泛的直线生成算法，它采用加减与乘2运算（即移位运算来实现）。\n过各行、各列像素中心构造一组虚拟网格线，按直线从起点到终点的顺序计算直线各垂直网格线的交点，然后确定该列像素中与此交点最近的像素。可以采用增量计算，使得对于每一列，只要检查一个误差项的符号，就可以确定该列所求的像素。\n直线起点赋予动点P(x,y)； 求端点坐标差：dx和dy； 求出循环总步数N，起点处的di的值； 循环计算中间插值点坐标： 若当前步数≥N，程序结束。否则：\n显示当前点P； 若di大于0，y坐标加1； 计算当前的di值； x坐标加1。 中点画线法 中点画线法：假定直线斜率k在0~1之间，当前像素点为（xp，yp），则下一个像素点有两种可选择点P1（xp+1，yp）或p2（xp+1，yp+1）。若p1与p2的重点（xp+1，yp+0.5）称为M，Q为理想直线与x=xp+1垂线的交点，当M在Q的下方时，则取p2应为下一个像素点，当M在Q的上方时，则应取P1为下一个像素点，若M与Q重合，则P1或P2任取一点，其他斜率同理。\n中点画线法的算法步骤：\n输入直线段的两个端点P1(x1, y1)和P2(x2, y2)，通过比较保证x1\u0026lt;x2。 初始化：dy，dx，d=dy+0.5dx，x=x1，y=y1，画点(x, y)，若-1\u0026lt;k\u0026lt;0，则x=x2，y=y2。 循环画点。 0≤k≤1 若x\u0026lt;x2，则执行下列各步，否则算法结束。 判断d的符号；若d\u0026lt;0，则(x, y)更新为(x+1, y+1)，d更新为d+a+b；否则(x, y)更新为(x+1, y)，d更新为d+a。 画点(x, y)。 1\u0026lt;k\u0026lt;0 若x\u0026gt;x1，则执行下列各步，否则算法结束。 判断d的符号；若d\u0026lt;0，则(x, y)更新为(x-1, y+1)，d更新为d-a+b；否则(x, y)更新为(x-1, y)，d更新为d-a。 画点(x, y)。 简单种子填充算法 假设区域内一点已知，以此为种子。从该点出发，沿着区域连通的方向搜索与种子相邻且位于区域内的点，使其成为新种子，接着继续递归地搜索下去。若相邻的点不在区域内，即达到边界。\n确定边界和边界的属性； 确定区域填充的属性值； 测试区域内一点的属性值，判定其是否在填充区域内；且未被填充， 若在区域内且和边界的属性值不同，赋予填充属性，以此点为种子； 沿四连通(或八连通)方向，测试其它点； 每测试一个点都与边界属性比较，若不同，赋予填充属性； 若相同，即到达边界，然后转向另一种连通方向； 整个点的测试采用循环递归的方式实现。 扫描线种子填充算法 用扫描线从上到下扫描由点线段构成的多段多边形。每根扫描线与多边形各边产生一系列交点。将交点按照x(或y)坐标进行分类，然后成对取出，作为两个端点，用填充颜色画水平直线。\n当给定种子点时，首先填充种子点所在的扫描线上的位于给定区域的一个区段，然后确定与这一区段相通的上下两条扫描线上位于给定区域内的区段，并依次保存下来。反复这个过程，直到填充结束。\n扫描线算法 利用区域的连续性、扫描线的连续性、边界连续性。\n把区域边界顶点按Y坐标排序； 确定扫描线的区间； 构建边界边的活性边表； 求交点，计算当前扫描线与多边形所有边的交点； 交点排序，把所有交点按x值递增顺序排序； 交点配对，排序后的交点两两配对成区间； 填充颜色，将各区间内的像素值设置为目标颜色值。 具体算法步骤如下：\n初始化边表ET：将多边形各条边按照该边的ymin值存放至ymin所对应的ET存储桶中。 初始化活动边表AET为空表。 将y值设置成为ET中所列的最小y值，即第一个非空存储桶的y值。 重复执行以下各步，直至AET和ET都为空： 当扫描线的y值开始大于或等于ET中某个y桶的值时，将该桶的所有结点加入到AET中（同时要从ET中删去），并将AET中的记录按x值排序。 对于扫描线y，在一对交点之间填充所需要的像素值。 删去AET中y\u0026gt;ymax的项。 更新AET中所有剩余结点的x值，用x+1/m代替x。（当一个结点是在本轮循环中才进入AET时，它记录的x值为xmin。） 对AET中的各结点按x值重新排序。 y增1后进入下一轮循环。 直线编码裁剪算法 把窗口边界延长分成9个区，每个区用四位二进制数进行编码，根据编码的值或逻辑运算进行位置判断。\n端点编码\n排位从左开始：第1位为1,端点在yT上,即y\u0026gt;yT，第2位为1,端点在yB下,即y\u0026lt;yB，第3位为1,端点在xR右,即x\u0026gt;xR，第4位为1,端点在xL左,即x\u0026lt;xL，否则，相应位置为0。 根据编码的值或逻辑运算进行位置判断。 如果线段两个端点的4位编码全为0，则此线段在窗口内，可直接输出； 若线段两端点的编码逻辑与（位乘）不为0，则线段全部在窗口之外，舍弃； 除上之外，线段与窗口有交点，求交点。 求交过程 求直线与窗口边界的交点，用交点分割线段，舍弃交点以外部分 以交点为界进一步求交判断，并进行分割 剪的次序：按编码值； 结束标志：编码值全部为零。 外法线消隐算法 外法线消隐算法：用于平面立体消隐处理\n任意平面立体消隐算法步骤：\n先求出表面的外法线，计算其投影方向上的方向余弦值cosa； 根据方向余弦值，进行可见性判断：cosa\u0026gt;0 朝前面；cosa≤0朝背面 对朝前面计算其表面的最大深度值； 计算朝前面的盒子角点坐标； 取出最大深度值的表面作为当前面; 循环计算其他表面和当前表面的遮挡关系； 提取表面的每一个边，判断和当前面的关系：完全挡住、完全未被挡住或部分挡住； 若完全挡住视为不可见边，做删除或改变线性处理； 若完全不被挡住，视为可见边，绘制该边； 若部分挡住，利用线段裁剪求出多边形之外的部分线段：可见线段，绘制； 对多边形之内的部分线段：不可见线段，作删除或改变线型处理 深度缓存消隐算法 深度缓存消隐算法的基本思想是：将投影平面每个像素所对应的所有面片（平面或曲面）的深度进行比较，然后取离视线最近面片的属性值作为该像素的属性值。\n初始时，深度缓冲器所有单元均设置为最小z值，帧缓冲器各单元均至为背景色，然后逐个处理多边形表中的各面片。每扫描一行，计算该行各像素点(x,y)所对应的深度值z(x,y)，并将深度与深度缓冲器中该像素单元所存储的深度值ZB(x,y)进行比较。\n若Z\u0026gt;ZB(x,y)，则ZB(x,y)=z，同时将该像素的属性值I(x,y)写入帧缓冲器，即FB(x,y)=i(x,y)；否则不变。\n","date":"2018-04-30T00:00:00+08:00","permalink":"https://boiltask.com/knowledge/computer-graphics-note/","title":"计算机图形学复习笔记"},{"content":"发现上个发的日志竟然已经是去年招新结束后发的，一年时间又过去了…确实似乎周围人发的日志也越来越少了，很多事情说说里发一下也基本够了。不过对于这种写之前就知道会写很多的来说，日志可能会更好一些，估计大概也赶不上2017最后一班车了，就当做2018的开端吧。\n再往前的一篇也是关于ACM的，本来今年之前的几场区域赛打完就想打个日志记录一下的，然而确实还有些遗憾吧，实在是提不出来兴致写东西。昨天的生日本来也准备做个总结，结果也是突然没有心情，感觉今年不趁着元旦写点什么，后面可能再也不会写了，所以能留下点什么还是留下点吧。\n先来看ACM吧，很遗憾并没有完成去年的目标，可见老天还是很公平的，好运不会一直眷顾。犹记得去年侥幸得到铜奖之后的欣喜，今年得到铜奖却毫无感觉。毕竟又是一年过去了，最终还是没能为我校拿到第一枚区域赛银牌，祝愿后面的学弟学妹们能继承历代学长学姐的遗志吧。\n其余的来说，自己在之前也订过一些20岁之前的小目标，本来阳历生日的时候还想还没20岁我还有时间。不过阴历生日也过了，就没办法啦得承认自己20岁了。\n首先说自己想要20岁之前靠专业知识挣得第一桶金，不知道算不算完成了。强行算完成的话，真能说是挣的就算是给谷歌当了一年的广告狗吧，也算挣了几十块美金，虽然一直没收到验证的邮件，不知道发到哪里去了。\n再来说想要做个游戏，嗯…QT消消乐不知道算不算哎。自己还是太懒，说要学unity，结果干了几天又不想动了。还是缺乏动力吧，没有人来逼迫一把，毕竟QT也是差不多的东西，被老师逼得也速成了。\n嗯…女朋友…那行吧…算是没毛病的完成一件事情了，立了一两年的flag了…\n平均一年发一篇日志哎，不过随着时间流逝，每一次写日志都有可能是最后一篇，谁能说得准呢。行啦，写着写着又不想写了，感觉这是好事，说明也没憋多少话吧，有地方倾吐总是好的。\n再立点2018年的flag呗，虽说在这种地方立大概率会被打脸。\n首先2018年又是人生中重要的一年，后面的好多事应该在这一年都会有所分晓。\n不行，不能立flag，悄悄想一想目标与希望就好了，说出来就不灵了。\n就这样吧，想到新的再来更新，虽然估计也不会更新了，前几年的还没补完呢，嘻嘻。\n总之，努力做好之前做得不是很好的那些事，尝试之前没做好的那些事，大家2018继续共勉。\n","date":"2017-12-31T16:33:45Z","permalink":"https://boiltask.com/record/qzone-1514738005/","title":"不知道是不是在空间的最后一篇日志呢"},{"content":"虽然这篇日志发出的时候，圣诞节已经过了，但总感觉在这个满世界苹果的节日配上小石榴很酷，虽然之前一直没用过这个称呼。\n圣诞节能在机房坐一下午，或许还很痛苦很焦灼地做题，想想也是个难忘的回忆。虽然是在群里讲题目出的有些难度，但我认为我内心最多把难度从简单升级为不难。毕竟，说的招新招新，从暑假一直说到了寒假。\n当看到一个作为C语言基础题的B题一半人不会的时候，尤其是看到隔壁友校新生赛几百个人规模的时候，当想到水平不够都没法和别人玩的时候，确实内心还是很难受的。\n记得大一临近暑假的时候，越发感觉到了ACM靠某一个学生是很难把一个学校的水平提升上去的。大概从那个时候就开始想，有机会的话我会好好带下一届学弟学妹的。\n暑假里面找时间研究OJ，经过几次通宵总算有了雏形，然后php js什么的一通乱学，也是把界面改的面目全非了（我应该是想表达褒义）。后来开学之后尝试搭建学校OJ，依照着hustoj的开源代码，也算是做出了一些不一样的东西。至于后来的solution什么的，那也算是对我个人的一点考验吧。\n记得从暑假还没结束时候起，虽然还没开学，但已经认识了一些学弟学妹。后来军训、国庆、百团大战什么的，一路走来也是建立了很大的友谊。时常说的事情也是，真要说踢掉谁的话我估计已经下不去手了。\n什么时候说明投入了很大精力，大概就是如果没有ACM估计我就废了。基本上所有的圈子已经围绕了ACM，但…那又怎么样呢，我又不后悔。\n人们常说，这世界有舍有得。就我个人而言，也确实是得到了很多，也失去了不少。或许是不接触这种东西的人很难体会的一种情感，或许刚开始是好奇，后来有趣，又或者是被虐的死去活来的痛心，但又很难割舍开来。\n因为，把一切都投注了其中。事业与情感，都注定了会把自己绑在上面。\n想想，这是招新后的鼓励与期待，不是回忆录，所以就这样子吧。\n上面有句话说得挺好的，\u0026ldquo;那又怎么样呢，我又不后悔\u0026rdquo;。\n","date":"2016-12-25T17:00:54Z","permalink":"https://boiltask.com/record/qzone-1482685222/","title":"招新之后写给圣诞节的ACM小石榴"},{"content":"(写完之后补充一句，如果这篇日志伤害到了一些身边的人，先说声抱歉)\n自从去年学习了这句话，每次想时都觉很有道理。差不多去年的今天，学长终于通知本周ACM协会招新，最终也没什么悬念的，成为了我大学唯一加入的组织。\n说起来这个没有悬念，我写下的时候还是纠结了一下这样说会不会被打，但想了想确实是没有悬念。这点自信还是要有，要不也对不起我这些年和我爸的“斗争”。想起来前几天为了准备今天写点什么，特意翻了翻六号群里的东西。很可惜，聊天记录是肯定找不到了，不过群文件里还有去年11月份初做的AC小助手。想来，那时候也还是一直想要做应用的。\nACM是什么？能吃吗？\n凌晨时候逛知乎，大概是一个有关家境的问题，问家境不好的人在哪方面会输给家境好的人。诚然，我应该不算家境不好的人，嗯。但如果有个问题叫做“什么时候你意识到家境不好”的话，我想，我心中还是有些答案的。\n当知道世界上还有OI这种东西的时候吧，或者说，当知道OI距离我如此近又如此之远。近到别人初中时打代码时我也在打代码，远到别人在打比赛时我在被我爸打。现在想想，因为计算机的事情确实有段时期“众叛亲离”(想了想还是加了引号，也没那么夸张)，只能无奈地说句，小城市毕竟还是小城市，虽然我依旧以她为荣。\n我爷爷常说，只有受教育的家庭才是有未来的家庭。很多事情，我不说，但越长大越沉思。至少，我爸走进了城市，自然而然地也要求一辈比一辈好。然而，计算机的到来，打破了信息流通的屏障，让我提前知道了，世界还有许多的东西。\n计算机再晚来十年会怎样呢，不知道，也不想做出假设了。\n羡慕那些由由信息学入门接触计算机的人，然而我的确和大多数人一样由游戏入门。中国的电子游戏，经过这些年的风风雨雨，也算坎坷崎岖，不过确实也造就了电脑等于游戏机的观念。\n这就很尴尬了，嗯。\n想想小学时候的微机课(很幸运的四年级是有微机课的，虽然还是爱上不上的课)，摆弄金山打字和金山画王。直接导致了后来，家里装上电脑，也是对这俩软件爱不释手级别。\n(说到画画，一直耿耿于怀还是五年级暑假扔下的画笔再也没能拿起来。理由是因为一百分的英语最多只能考八十多，拉去学新概念。暑假开学拒绝继续去学，被我爸打得现在对英语依旧有心理阴影。)\n后来初中，很幸运拷到了一份课本附带光盘的资料。(为什么要拷，因为书就一份直接留在机房的…里面是word的教程)至少，每一次微机课上机课(开玩笑，怎么可能每个星期都让上机)，都是我最开心的时候(毕竟这是一种你不教的我也知道的喜悦)。\n九年级，还是我每一次写东西都要说的事情(这篇日志只讲事业的好吧)。上学期，做flash,建九二联盟，搞事情。下学期又沉迷贴吧，无法自拔。然后那天看思品老师不爽，晚上偷偷把她上传到多媒体系统里的课件改了，第二天上课一阵骚动的时候成就感还是很高的。(这事似乎也就那几个人知道，都没敢往外说…)\n至于后来高中时候因为计算机的问题和家里边的人闹矛盾，我准备下一篇日志再写。\n这一年多的大学还是让我认识到一些事情的，很重要的一点就是，我心态确实爆炸了。虽然依旧能写代码写一晚上，但已经不止是只有写代码才能熬一晚上。\nACM带来了什么，前几天说到，让我找到了小时候心目中的大学感觉。这种感觉是在你看到神奇的课程安排、厉害的讲课态度和开一次机死机三次的机房电脑之后自然而然梦寐以求的感觉。至少，保护我了不用去纠结那些神奇的事情。\n——2016.11.12于北京\n下为2016.11.15补\n写了一半感觉没写完，后面两天也没找到感觉就没有继续写，所以也没有发出来。\n不过既然写了，那就不妨继续补充一些吧。\n去年的今天，星期日，ACM协会第一次招新结束了。回忆起这一年，确实比起很多强校，浪费了太多太多时间。或许，有朝一日我们学校不在需要以C语言知识来招新，那么协会才真正发展起来了吧。\n这次去北京，虽然号称是内心毫无波动，但对于一个第一次进入首都的小青年，还是依旧地难免激动。虽然已经尽量找北大的不好了，但…你懂得…确实没找到。\n比赛能获奖也很开心，虽然之前一直说有机会获奖，不过也一直说百分之十的概率…所以当最终一题一题AC，排名稳定在铜牌区的时候，还是有些难以置信到爆的。\n不过发现，确实没啥说的了，补充这几段也是为了在比赛结束之后补充一下比赛结果。想来，一个铜奖，弱校开心到爆，但对于强校巨巨来说，这根本还是没什么值得说的安慰奖。特别是当自己内心明白这种水平根本在强校连ACM队都进不去，不过…加油吧。\n比赛出发前，用港港的话录了个flag，爆零回来剃光头，看来头发是保住了，拿不了奖就不谈恋爱，现在奖也拿了。\n所以，总得来看，虽然鲜克有终，但还是希望，如果最后有句号，那么就让句号更圆满些吧。\n","date":"2016-11-15T14:13:30Z","permalink":"https://boiltask.com/record/qzone-1479219219/","title":"靡不有初，鲜克有终，ACM入坑一周年纪念"},{"content":"问题描述 LT说我不服\r时间限制：1 Sec内存限制：128 MB\rDescription 对于上一道题目LT不服，表示那么简单的题目不屑于去做，所以我们决定加大一下题目的难度，下面是我们LT出的题目： 假如给你一个由n个数组成的序列A1, A2, A3, A4 …… An。你可以选择任意一个大小的区间，将其中的每一个数x变成(x*1888+101)%14507。 求这n个数的最大和可能是多少。\nInput 输入有多组数据 每组数据第一行输入一个整数n为序列元素个数。(1 \u0026lt;= n \u0026lt;= 100000) 第二行n个整数A1, A2, A3, A4 …… An。(0 \u0026lt;= Ai \u0026lt;= 10000)\nOutput 每组样例输出一行答案。\nSample Input 1 2 3 4 2 10000 9999 5 1 9999 1 9999 1 Sample Output 1 2 19999 21989 HINT 范围在int内\n问题分析 这一题可以转化为求最大子串和问题\n因为若不改变值，则结果为a1~n的和\n若求出每一个数的(x*1888+101)%14507与x的差值\n改变某一区间的值，则可以表示为选取一个子串\n若想要最终结果最大，很显然要让选取的这个子串和最大\n所以dp求解，复杂度O(n)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include\u0026lt;stdio.h\u0026gt; int a[100200]; int main() { int n; while(scanf(\u0026#34;%d\u0026#34;,\u0026amp;n)!=EOF) { int sum=0,res=0,x=0; for(int i=0; i\u0026lt;n; i++) { scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]); sum+=a[i]; if(x\u0026gt;0) { x+=(a[i]*1888+101)%14507-a[i]; } else x=(a[i]*1888+101)%14507-a[i]; if(res\u0026lt;x) res=x; } printf(\u0026#34;%d\\n\u0026#34;,sum+res); } return 0; } 题目地址:【郑轻】[1837]LT说我不服\n","date":"2016-09-02T03:16:15+08:00","permalink":"https://boiltask.com/oj/zzuli/1837/","title":"【郑轻】[1837]LT说我不服"},{"content":"问题描述 问题分析 最小子序列和的dp问题\n这里分别考虑取第j个数为子序列第i个数\n则dp[1][j]=dp[0][j-1]+a[j]*j\n其中dp[0][j-1]保存的是1~j-1中的数作为第i-1个的最小值\n可以结合代码理解：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; int a[10200]; int dp[2][10200]; int main() { int n,k; while(scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;k)!=EOF) { memset(dp,0,sizeof(dp)); for(int i=1; i\u0026lt;=n; i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]); int res; for(int i=1; i\u0026lt;=k; i++) { res=999999999; for(int j=i; j\u0026lt;=n; j++) { dp[1][j]=dp[0][j-1]+a[j]*i; dp[0][j-1]=res; if(res\u0026gt;dp[1][j]) res=dp[1][j]; } } printf(\u0026#34;%d\\n\u0026#34;,res); } return 0; } ","date":"2016-09-02T02:40:05+08:00","permalink":"https://boiltask.com/oj/zzuli/2146/","title":"【SDUT】[2146]最小子序列和"},{"content":"问题描述 so easy！麻麻再也不用担心我的数学了！\r时间限制：1 Sec内存限制：128 MB\rDescription 咱们来一发so easy的数学题，这样麻麻再也不用担心我们的数学不及格了。\n现在给你一个方程A[i] = (A[i-1]+A[i+1])/2 - c[i](1 \u0026lt;= i \u0026lt;= n);, 然后给你A[0]和A[n+1]\n求A[1] = ?。\nInput 包括多个测试样例。\n对于每一个实例，第一行输入一个正整数n(1 \u0026lt;= n \u0026lt;= 3000)，第二行输入两个实数A[0], A[n+1]，接下来每一行输入一个实数c[i](1 \u0026lt;= i \u0026lt;= n)。\nOutput 对于每个测试实例，用一行输出所求得的a1(保留2位小数).\nSample Input 1 2 3 4 5 6 1 50 25 10 2 50 25 10 20 Sample Output 1 2 27.50 15.00 问题分析 是一个比较不容易思考的题。\n根据公式：\n可以得到：\n所以：\n……\n所以可得\n由此可直接得出结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include\u0026lt;stdio.h\u0026gt; double a[3020]; int main() { int n; while(scanf(\u0026#34;%d\u0026#34;,\u0026amp;n)!=EOF) { double f0,fn1; scanf(\u0026#34;%lf %lf\u0026#34;,\u0026amp;f0,\u0026amp;fn1); for(int i=1; i\u0026lt;=n; i++) scanf(\u0026#34;%lf\u0026#34;,\u0026amp;a[i]); double sum=0; for(int i=1; i\u0026lt;=n; i++) sum+=2*(n-i+1)*a[i]; printf(\u0026#34;%.2lf\\n\u0026#34;,(fn1+n*f0-sum)/(n+1)); } return 0; } 题目地址:【郑轻】[1841]so easy！麻麻再也不用担心我的数学了！\n","date":"2016-09-02T01:12:58+08:00","permalink":"https://boiltask.com/oj/zzuli/1841/","title":"【郑轻】[1841]so easy！麻麻再也不用担心我的数学了！"},{"content":"本篇文章讲解题目：小学求和1到n\n推荐先独立进行解题尝试，然后再阅读本篇讲解！\n注意观察这道题与上一个求和的差别。\n首先从一组数据变为了多组数据，但这一点在学习了循环之后应该已经不再是问题了。\n我们只需要读取一个变量T记录组数，然后使用语句：\n1 2 3 while(T--) { } 在大括号里写程序即可。\n这道题给的范围为$0 \u0026lt; n \u0026lt; 10 ^ 9$，所以如果依旧使用for的话循环最大要进行$10^9$次\n评测机一秒大概可运行$10 ^ 7 \\sim 10 ^ 8 $次 ，所以O(n)的复杂度是不行的\n(推荐先自己查阅时间复杂度相关资料)\n事实上，如果让小学生来解，这便是一道很简单的等差数列求和，所以可用求和公式直接算出答案。\n当然，还需要注意数据范围的问题。\n再次举这一题的例子也是想再次说明思维的重要性。\n一道题随着题目描述的不同，解答方式也许有着差异，所以不要局限于某一种解法，多加尝试才能处变不惊。\n","date":"2016-08-29T16:00:57Z","permalink":"https://boiltask.com/tutorial/iwbtg/15/","title":"【愿成其身】[15]思维的优化 – 数学的魅力"},{"content":"本篇文章讲解题目：大学求和1到n\n推荐先独立进行解题尝试，然后再阅读本篇讲解！\n依旧是一道小学题目。\n本篇文章有过激言论，请谨慎阅读。\n这一题一般常用做初讲for循环的例题，而这道题也确实很合适，因为这标志着思考问题解决方案的可行性，由优先思考数学方法转变为思考时间复杂度。\n而有争议的地方，便是for循环的写法。\n首先是基本结构如下：\n1 2 3 for(/*起始语句*/; /*判断语句*/; /*修正语句*/) { /*循环语句*/ } 同样画出它的流程图：\n(参考文章《for,(do-)while的循环体执行》)\nfor循环比while好在它能清晰的操作循环变量，比如下面代码：\n1 2 3 4 int i; for(i=0; i\u0026lt;n; i++) { /*循环语句*/ } 这便是让循环语句循环n次的写法，同样的操作可写为while(n\u0026ndash;)。\n但是如果我们在循环中用到了i，比如我们想让奇数次时执行某一语句，偶数时执行另一语句，就可以写为：\n1 2 3 4 5 6 7 8 int i; for(i=0; i\u0026lt;n; i++) { if(i%2==0) { /*偶数时操作*/ } else { /*奇数时操作*/ } } 所以具体什么时候该用哪种循环，取决于哪一种可以使代码简洁、写起来方便，可以进行互相转换。\n上边代码就等同于：\n1 2 3 4 5 6 7 8 9 int i=0; while(i\u0026lt;n) { if(i%2==0) { /*偶数时操作*/ } else { /*奇数时操作*/ } i++; } 而至于for循环有争议的地方，便是for循环中的i=0。\n在C++中，我们可以在循环的初始语句里写成：for(int i=0; i\u0026lt;n; i++)，也就是把定义变量放在循环内部，这样的话变量作用范围就仅限于这个循环里面。如此做，可以防止循环与循环之间的干扰，特别是需要函数互相调用时，防止变量因为已被占用而发生错误。\n(关于变量的作用范围，可参考我之前写过的一些文章《for循环中的定义变量》《关于for循环中定义变量的后续讨论》)\n然而，在标准C中不允许这么写，可以尝试把代码保存为.c和.cpp来查看编译区别。\n所以如果需要使用在for中定义变量的形式，提交时需要选C++，事实上我认为最好以后默认选C++。\n这不是C语言课……\n这不是C语言课……\n这不是C语言课……\n所以我认为，只要自己在使用时清楚地认识到哪部分是C++特有的，那么我们大可放心使用C++。毕竟我依旧认为，我们不应该在语言层面纠结太长时间。\n这些问题需要在今后的学习过程中自己体会与抉择，这里不多说了……\n注意事项：\n多条循环语句不要忘了加大括号！\n不要忘了加大括号！\n加大括号！\n剩下的就没有什么了，在掌握了循环之后，已经可以开始尝试一些入门级水题了。\n这条路，长且艰……\n","date":"2016-08-28T16:00:46Z","permalink":"https://boiltask.com/tutorial/iwbtg/14/","title":"【愿成其身】[14]for循环 – 另一种表达方法"},{"content":"本篇文章讲解题目：蜗牛爬树\n推荐先独立进行解题尝试，然后再阅读本篇讲解！\n一道小学数学题，但对于计算机来说，却是直接模拟这一过程更为简洁。\n很明显的一个思路是，对高度不断模拟上升下落的这一过程，然后统计次数，直到高度达到树的高度。\n简单的画一个流程图：\n分析可以发现，这里的循环是由一个条件控制的。如果满足某一条件则一直循环，否则退出循环。\n在C语言里，这种形式可以使用while语句表达，其基本形式为：\n1 2 3 while(/*条件*/) { /*语句*/ } 可以发现与if语句形式类似，也是很好理解，若满足条件，则不断执行语句，每次执行之后判断条件是否成立，然后选择继续执行或者跳出循环。\n有了上面的基础知识，我们再来思考这道题，发现上面的程序流程图对于一些情况是没有考虑到的。\n首先是Impossible不可能的情况，下降比上升的幅度还大，那么很显然是不可能的。但是有一种却要排除在外，也就是第一天白天就能够爬到树顶的情况，那么应该输出1。 考虑到如果白天就爬到，那么晚上就不用掉落，很显然我们在白天爬完之后应该判断，是否已经到了树顶，如果到了，那么就不需要晚上掉落这一部分了。 加上这些考虑，我们改进流程图如下： 有了这些思考，AC还是件难事吗-.-。\n嗯……似乎还有些问题。\n首先是对于输出不可能判定的条件有两个，在C语言里我们使用两个\u0026amp;号，也就是“\u0026amp;\u0026amp;”来表示并且，而用“||”来表示或者。这个条件就可以写为n\u0026lt;h\u0026amp;\u0026amp;n≤m。\n再来是循环内的判断，如何终止循环呢？我们可以使用continue与break来控制循环。\ncontinue的作用是跳过continue下面的部分直接回到循环条件那里判断是否需要进行下一次循环。\nbreak的作用就是直接跳出循环。\n测试代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include\u0026lt;stdio.h\u0026gt; int main() { int T=10; while(T--) { /* if(T==5) continue; */ /* if(T==5) break; */ printf(\u0026#34;%d\\n\u0026#34;,T); } return 0; } 这里还顺带写了while的一种常见用法while(T\u0026ndash;)，可先自己理解理解其中含义，在后面输入输出系列中会详细说明。\n写到这里，这一题就算告一段落了。\n事实上，while还有一种变形，do-while，其基本形式为：\n1 2 3 do { /*语句*/ } while(/*条件*/); 也就是判断循环条件是否成立之前，先执行一次循环体，这在解决一些问题的时候很方便。\n也许你可以自己尝试画出它的流程图呀~\n","date":"2016-08-27T16:00:42Z","permalink":"https://boiltask.com/tutorial/iwbtg/13/","title":"【愿成其身】[13]循环结构 – 计算机的神奇"},{"content":"本篇文章讲解题目：交换输出\n推荐先独立进行解题尝试，然后再阅读本篇讲解！\n这也是一道经典问题，今天就从它谈起。\n$a \\rightleftharpoons b$\n首先分析题目，下面这种写法肯定是错的。\n1 2 3 4 5 6 7 8 9 #include\u0026lt;stdio.h\u0026gt; int main() { int a,b; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a,\u0026amp;b); a=b; b=a; printf(\u0026#34;%d %d\\n\u0026#34;,a,b); return 0; } 因为在a=b的时候，a的值已经被替换成b了。\n这个时候我们想，若把a的值提前记录下来便可以了。\n也就是int t=a;a=b;b=t;\n事实上，还有一种更为酷炫的不借助其它变量的写法如下。\n1 2 3 a+=b; b=a-b; a=a-b; 也就是直接把b的值存在a里面，然后a-b便是a的值——赋值给b，然后此时a-b便是b的值——赋值给a。\n同样按照这种思路，有依靠于二进制运算的更为酷炫的写法：\n1 2 3 a^=b; b^=a; a^=b; 因为对计算机来说二进制更为快速，所以这种写法也是更省时间的。\n下面还有一个最终版本。\n在前面说过，黑盒测试是给输入数据然后比较输出数据是否一样，而这一道问题的输出是a和b交换值之后输出a和b的值。\n那么我们便可以提交如下代码：\n1 2 3 4 5 6 7 #include\u0026lt;stdio.h\u0026gt; int main() { int a,b; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a,\u0026amp;b); printf(\u0026#34;%d %d\\n\u0026#34;,b,a); return 0; } 同样是符合题意的一种代码。\n在分析这道题的过程中。\n首先，根据最简单的题意我们写出了一份代码。 然后，根据数学知识做出了优化(所用空间减少)。 之后，根据同样地思想用二进制优化了计算过程(所用时间减少)。 最后，依照黑盒测试的特点写出了最简代码。 当然，对于这一题来说，即使是最初的代码所用的时间与空间也是非常少的，所以优化对这一题来说也许没必要。\n但是这种思想是我们应该学习的，正是在这种优化中，自身的编码能力及思考问题的能力会有显著的提高。\n而实际比赛中，我们也可以根据题意，在符合要求的前提下，选取那个最容易想出且容易写成的方案来实现。\n","date":"2016-08-26T16:00:45Z","permalink":"https://boiltask.com/tutorial/iwbtg/12/","title":"【愿成其身】[12]从交换输出谈起 – 黑盒的漏洞"},{"content":"本篇文章讲解题目：比较字符\n推荐先独立进行解题尝试，然后再阅读本篇讲解！\n细想之下，计算机能储存字符是一件非常了不起的事情，毕竟它不同于数字。\n数字还可以使用二进制转换，而字符怎么办……\n为了解决这一问题，在C语言里，字符是被存储为数字的，其可像数字一样参与运算。\n我们可以使用类似于下面的代码来查看代表字符的数字是多少：\n1 2 3 4 5 6 7 8 9 10 #include\u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;%d\\n\u0026#34;,\u0026#39;A\u0026#39;); printf(\u0026#34;%d\\n\u0026#34;,\u0026#39;B\u0026#39;); printf(\u0026#34;%d\\n\u0026#34;,\u0026#39;C\u0026#39;); printf(\u0026#34;%d\\n\u0026#34;,\u0026#39;a\u0026#39;); printf(\u0026#34;%d\\n\u0026#34;,\u0026#39;b\u0026#39;); printf(\u0026#34;%d\\n\u0026#34;,\u0026#39;c\u0026#39;); return 0; } 所以这一题便可以方便的进行比较。\n字符的类型为char，格式化输入输出使用%c。\n1 2 3 4 5 6 7 #include\u0026lt;stdio.h\u0026gt; int main() { char c; scanf(\u0026#34;%c\u0026#34;,\u0026amp;c); printf(\u0026#34;%c\\n\u0026#34;,c); return 0; } 需要注意的是，小写字母ASCII值是大于大写字母ASCII值的，而题目定义为小写字母小于大写字母，所以对于这种情况应该特殊判断。\n","date":"2016-08-25T16:00:15Z","permalink":"https://boiltask.com/tutorial/iwbtg/11/","title":"【愿成其身】[11]字符的本质 – ASCII的作用"},{"content":" 君甚屌,令堂可知？\n第十篇文章，能看到这里，说明已经基本上踏入了这道大门。虽然路还很长，但是已经走在了路上。\n所以这一篇文章讲一个虽然不影响解题，但是熟练运用会让代码看起来很酷炫的小知识点：问号表达式。\n其基本形式如下：\n1 (/*条件*/)?(/*语句1*/):(/*语句2*/) 当条件1成立的时候，表达式的值取决于语句1，否则取决于语句2。\n例子：\n1 printf(\u0026#34;%s\\n\u0026#34;,a\u0026gt;b?\u0026#34;A\u0026#34;:\u0026#34;B\u0026#34;); 具体的如何运用，还是需要自己在实践中多多尝试。\n如果能运用的非常自如，那么说明对程序的结构把握的很好，也有利于进一步的学(zhuang)习(bi)。\n练习题：\n三个数的最值\n","date":"2016-08-24T16:00:02Z","permalink":"https://boiltask.com/tutorial/iwbtg/10/","title":"【愿成其身】[10]问号表达式 – 酷炫的利器"},{"content":"本篇文章讲解题目：两数的距离\n推荐先独立进行解题尝试，然后再阅读本篇讲解！\n由数学知识得，两点在数轴对应点的距离为$\\left| x_{1}-x_{2}\\right|$。\n相减没什么难度，所以这一题实际上在于求绝对值。\n事实上，这是一个逻辑问题，也就是如果a\u0026lt;0，那么应该输出-a，如果a\u0026gt;0，那么应该输出a，如果a=0，那么应该输出0。\nC语言对于分支结构有两种常用表达：\n是if-else、switch，其中前者因为便于理解而更为常用，今后也将重点使用if-else，switch在可以方便使用时再讲解，可以自行百度。\nif-else的大概结构如下：\n1 2 3 4 5 6 7 if(/*条件1*/) { /*语句1*/ } else if(/*条件2*/) { /*语句2*/ } else { /*语句3*/ } if顾名思义，是如果的意思，这段代码的意思也就是：\n如果条件1成立执行语句1；如果条件2成立执行语句2；否则执行语句3。\n若条件下只有一条语句，则大括号可以省略。\n若一个条件下有多条语句，则大括号不可省略(因为如果省略，编译器便把它当成只有一条语句在该条件下)。\n所以这道题的代码就很好写了。\n数据范围很小，用int型就足够了，然后就是进行判断求解。\n","date":"2016-08-23T16:00:14Z","permalink":"https://boiltask.com/tutorial/iwbtg/9/","title":"【愿成其身】[9]分支结构 – 程序的魅力"},{"content":"本篇文章讲解题目：愿成其身A÷B\n推荐先独立进行解题尝试，然后再阅读本篇讲解！\n我们知道C语言中用\u0026quot;/\u0026ldquo;来表示相除，整数的除法是采用的舍尾的方式。\n$5 \\div 2 = 2 \\ldots \\ldots 1$\n$5 / 2 = 2$\n所以对于这一题来说，题目要求输出A÷B的结果并保留到整数位。\n如果写成A/B，A,B都是整数的话，那么会得出结果的整数部分，小数部分会被舍弃，而这一题应该四舍五入。\n所以如下面代码是错误的。\n1 2 3 4 5 6 7 #include\u0026lt;stdio.h\u0026gt; int main() { int A,B; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;A,\u0026amp;B); printf(\u0026#34;%d\\n\u0026#34;,A/B); return 0; } 为了表示小数，我们可以使用double(float因为精度问题一般不使用)。\n提到了精度问题，请百度double的注意事项，应重点关注double的表示范围与计算误差。\n在这里暂时不对这一问题进行深入研究。\n声明一个double型变量依旧类似。\n1 double a; 在格式化输入输出里用%lf表示(有些标准对于有些情况使用%f，但一般统一写作%lf)。\n那么如何表示精确到整数呢？\n我们可以使用printf(\u0026rdquo;%.lf\\n\u0026quot;,a);\n可以注意到在%与lf中间加了一个点，这个便表示四舍五入到整数输出。\n这也是格式化输出的一种运用，在后面会再细讲。\n类似的还有：\nprintf(\u0026quot;%.2lf\\n\u0026quot;,a); 四舍五入到小数点后两位数字输出。\nprintf(\u0026quot;%.3lf\\n\u0026quot;,a); 四舍五入到小数点后三位数字输出。\n等等……\n还有一点需要注意：\n此题的的输入数据描述，由两个整数变为了两个数。\n所以输入数据有可能为小数，这个时候便不可以用整数来读取。\n","date":"2016-08-22T16:00:47Z","permalink":"https://boiltask.com/tutorial/iwbtg/8/","title":"【愿成其身】[8]实数的运用 – 整数化作的实数"},{"content":"本篇文章讲解题目：最后一位\n推荐先独立进行解题尝试，然后再阅读本篇讲解！\n在C语言中，除了加减乘除运算之外，还有一个较为常用的运算，取余\u0026quot;%\u0026quot;。\n$$5 \\% 2 = 1$$由数学知识得，一个整数对10取余即可得到最后一位数字。\n$$12345 \\% 10 = 5$$这一题便可使用这一种方法轻松得出答案。\n从上一篇文章中学到，这里如果计算A×B的话，依旧应该使用long long，然后对结果进行取余运算即可。\n1 printf(\u0026#34;%d\\n\u0026#34;,(A*B)%10); 因为最后一位数字肯定是int范围内的数字，所以可以直接以int型输出。\n对于这一题来说还有一种避免使用long long的方法。\n我们想到，对于乘法，其结果的最后一位只取决于A和B的最后一位，所以我们可以先分别求出A与B的最后一位，然后求出最后一位相乘的最后一位。\n这种把$\\left( A\\times B\\right) \\% 10$转变为$\\left[ \\left( A\\% 10 \\right) \\times \\left( B\\% 10 \\right) \\right] \\% 10$的思维，对于ACM来说很重要，因为通过各种转化，我们可以突破题目的一些数据限制，从而得到正确答案。\n思考，若题目的数据范围是$0 \\leq a,b \\leq 10^{18}$，那么我们便不能使用第一种方法，而使用后一种方法便可以轻松得到正确答案。\n这才是这一题的意义！\n","date":"2016-08-21T16:00:32Z","permalink":"https://boiltask.com/tutorial/iwbtg/7/","title":"【愿成其身】[7]整数的魅力 – 数字的最后一位"},{"content":"本篇文章讲解题目：愿成其身A×B\n推荐先独立进行解题尝试，然后再阅读本篇讲解！\n对于这一题，因为C语言中用\u0026quot;*\u0026ldquo;号来表示乘法，所以我们很容易写出以下代码。\n1 2 3 4 5 6 7 #include\u0026lt;stdio.h\u0026gt; int main() { int A,B; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;A,\u0026amp;B); printf(\u0026#34;%d\\n\u0026#34;,A*B); return 0; } 提交发现wrong answer答案错误。\n分析题目数据范围：$-10^9\u0026lt;a,b\u0026lt;10^9$。\n我们知道int类型在电脑中的范围是$-2^{32}\\leq int \\leq2^{32}-1$。\n大概约为2147483648～2147483647(PS：可以自己想办法求求看哦~)\n而很显然a,b是在int范围内的，那么为什么会出现答案错误呢……\n计算A×B的范围是$-10^{18}\u0026lt;a,b\u0026lt;10^{18}$。\n超出了int范围了！\n我们可以试着输入测试数据：\n100000000 100000000\n上述程序输出了错误答案……\n怎么解决呢？\n有一种比int类型范围更大的数据类型long long(__int64)类型。\n写成两种形式是因为C语言的标准不同，导致不同的编译器版本可能有不一样的规定，具体使用哪一种类型，需要查看OJ的FAQ，一般都会特别说明(此题所使用的OJ采取long long)。\nlong long的范围大概为$-2^{64}\\leq long long \\leq 2^{64}-1$。\n使用时与int类似，声明写为：\n1 long long a; 代表声明一个名称为a的long long型变量。\n在格式化输入输出函数里，正如%d代表int型，我们用%lld代表long long型(%I64d代表__int64型)。\n所以此题即可使用long long解决。\n因为若非必要，应该优先使用int型，所以若感觉此题可用int读取a,b，则也可进行解题。\n但输出时需要注意！\n如果写作\n1 printf(\u0026#34;%lld\\n\u0026#34;,a*b); 测试发现依旧会出现错误，因为编译器计算时，a与b都是int型，则a*b就会以int型计算，这样写只不过是把这个int型以long long型输出。\n而实际上，在a*b时就已经超过int型了，所以会出现错误答案，这就属于中间结果溢出。\n那么应该怎么写呢？\n我们可以使用类型转换写为：\n1 printf(\u0026#34;%lld\\n\u0026#34;,(long long)a*b); 此语句表示把a转换为long long类型，然后与b进行乘法运算，并且结果以long long型输出。\nlong long型与int相乘，会把int型先转换为long long型，然后变成两个long long型相乘，从而得到正确结果。\n","date":"2016-08-20T16:00:01Z","permalink":"https://boiltask.com/tutorial/iwbtg/6/","title":"【愿成其身】[6]A×B的学问 – 较大数的处理"},{"content":" 凡邦之有疾病者，疕疡者造焉，则使医分而治之，是亦不自医也。\n― 清·俞樾, 《群经平议·周官二》 0000|0000|0000|0000\n上次提到了C语言中的数据类型，这部分应该是比较难讲有趣的，为了防止沦落成为教学文章，只好强行引用了一句“分而治之”。事实上，我认为这也能很好地理解数据在计算机中的存储。\n首先我们应该知道，计算机是不知道怎么存储数据的，所有数据在内部都会表示成二进制\u0026quot;0\u0026quot;\u0026ldquo;1\u0026rdquo;。所以C语言中的数据结构，也便是给这些数据一个划分，比如4个一组(0000~1111[0,15])，8个一组(00000000~11111111[0,255])。这也方便理解为什么可以“自定义类型”。\n原理就讲这么多，再往深层次的讲就跑题了。-.- 事实上，这种知识也没办法投机取巧，只能在学习中进行记忆。所以我认为一个比较高效的方式就是：“用到哪里学哪里”，这就要求自己多找机会去用，否则的话便容易跟不上进度。\n了解了各种数据类型，我们也知道格式化输入输出函数。\n那么在格式化输入输出函数中的参数便可以随心所欲的使用了，比如%d代表int型，%c代表char型等。\n后面还是以例题来从使用出发讲解各个常用的类型。\n参考文章：\nC语言基本数据类型简介 - onedime\nC语言基本数据类型详解 - woods2001的专栏\n","date":"2016-08-19T16:00:49Z","permalink":"https://boiltask.com/tutorial/iwbtg/5/","title":"【愿成其身】[5]数据类型 – 装数据的盒子"},{"content":"有人说：“程序员总难免开始于A+B。”\n说了这么多，我们还是停留在“定量”阶段。前面说过，黑盒测试应该是根据系统给的输入数据来进行输出数据的比较。那么，如何获取输入数据呢？\n在stdio.h中，与格式化输出printf()相对的，有格式化输入scanf()。\n对比一下两者的标准格式。\nprintf(格式化文本,参数1,参数2,……);\n其中格式化文本控制了输出的格式，在其中可以使用如\u0026quot;%d\u0026quot;这样的格式说明来替换后面的参数，第几个%d便可以指定使参数几替换它。\n这样说有点绕……\n例如：printf(\u0026quot;%d\u0026quot;,1); 的输出结果便是 1\n如果参数是个变量，比如提前建立一个整型的变量a=5(int a = 5 ;)。\n那么：printf(\u0026quot;%d\u0026quot;,a); 的输出结果便是 5\n1 2 3 4 5 6 #include\u0026lt;stdio.h\u0026gt; int main() { int a=5; printf(\u0026#34;%d\\n\u0026#34;,a); return 0; } 同理，对于scanf()函数。\nscanf(格式化文本,参数1,参数2,……);\n格式化文本代表输入的格式，参数1、2……代表变量的地址。\n-.-好 什么叫地址？暂且理解为门牌号吧。\n同样的建立一个整型的变量a，然后从键盘读取一个数赋值给他。\nscanf(\u0026quot;%d\u0026quot;,\u0026amp;a);\n好，\u0026amp;是什么意思？\n\u0026amp;a也就是取a变量的地址，这句话的意思就是从键盘读取一个数存储到a的地址。那么很显然，a变量的值也就变成了从键盘读取的值。\n1 2 3 4 5 6 7 #include\u0026lt;stdio.h\u0026gt; int main() { int a; scanf(\u0026#34;%d\u0026#34;,\u0026amp;a); printf(\u0026#34;%d\\n\u0026#34;,a); return 0; } PS：试一试从键盘输入1234567890987654321会出现什么结果，思考为什么。\n了解了如何读取数据，就可以尝试完成这道A+B问题了。\n每个OJ都要有A+B\n同样的，还是请先尝试之后再继续阅读。\n对于这一题……\r没什么说的-.-科科\r","date":"2016-08-18T16:00:36Z","permalink":"https://boiltask.com/tutorial/iwbtg/4/","title":"【愿成其身】[4]从A+B谈起 – 一切的开端"},{"content":"本篇文章讲解题目：打印键盘\n推荐先独立进行解题尝试，然后再阅读本篇讲解！\n题目要求按照顺序输出键盘上的字符。\n这一道题并非难题，然而确实好多人都容易被坑到。\n其中的原因就是涉及到了转义字符的知识，所以当输出 \\ 和 \u0026quot; 时，如果不注意的话便容易出现问题。\n错误代码示例：\n1 2 3 4 5 6 7 8 9 10 11 12 #include\u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;`1234567890-=\u0026#34;); printf(\u0026#34;~!@#$%^\u0026amp;*()_+\u0026#34;); printf(\u0026#34;qwertyuiop[]\\\u0026#34;); printf(\u0026#34;QWERTYUIOP {}|\u0026#34;); printf(\u0026#34;asdfghjkl; \u0026#39;\u0026#34;); printf(\u0026#34;ASDFGHJKL:\u0026#34;\u0026#34;); printf(\u0026#34;zxcvbnm,./\u0026#34;); printf(\u0026#34;ZXCVBNM\u0026lt;\u0026gt;?\u0026#34;); return 0; } 这段代码编译会发现报错。\n为什么呢？\n在C语言中，输出时为了表示如换行，缩进等普通字符无法表示的字符时，引入了“转义字符”这一概念。\n因此如果直接输出\\，便会把它与后边字符加在一起理解为转义字符，如果想输出\\则可表示为\\。\n同理如果直接打\u0026quot;，则会认为是提前把\u0026quot;\u0026ldquo;结束了，如果想输出字符\u0026rdquo;，则需要表示为\u0026quot;。\n所以按照这个表进行改动。\n这个时候运行发现还是和结果不相同，因为所输出的字符全部在同一行。\n而我们想让它们一行输出一行，也就是“换行”。不过，多个printf是无效的，因为它只会“忠实”地执行你的代码。所以对于每一个printf来说，输出结束，它的“光标”是在输出之后的字符后面的。\n现在我们回忆起来，当我们自己输入完一行之后，我们会按回车键来使光标移到下一行。那么再看上面的表，发现换行键的转义字符为 \\n 。\n所以便可以完整的写出正确代码，就是在原代码的基础上，每输出一行便在后面加一个 \\n 即可。\n","date":"2016-08-17T16:00:52Z","permalink":"https://boiltask.com/tutorial/iwbtg/3/","title":"【愿成其身】[3]转义字符 – 格式化输出"},{"content":"你听说过黑盒测试吗？\nOnlineJudge就是一个黑盒测试系统，也就是不管程序内部是如何运行的，它只判断你的程序的输出是否与输入相对应。当然，为了检测程序的效率，OnlineJudge也会加入运行时间、占用内存等评判标准。\n所以对于一道程序设计题目，我们以上一篇文章中提到的“I wanna be the guy”为例，介绍一下OJ的基础使用方式。\n在开始之前，先进入一段日常题外话。\n有没有见到过这个提示呢：\n也就是提示少了一个\u0026quot;;\u0026quot;，我们发现C语言中，每一个语句之后都有一个\u0026quot;;\u0026quot;，这是因为在C语言中，多余的这些空格、空行等是无效的(我说的是“多余的”)，所以如果不加分号，计算机编译时也不知道你这一句已经结束了，从而会报错。\n少分号错误也是新手常见错误，而且最无奈的是把中文分号当成英文分号，这个时候一般还不容易检查出来，所以在刚开始的时候就应该注意。\n言归正传(1/1)\n对于一道题，它应该有题目描述、输入描述、输出描述、样例输入、样例输出等几部分。\n题目描述：提供了这道题的背景说明，一般会讲述一个故事来吸引做题者兴趣。\n输入描述：提供了输入数据的格式、范围等信息。\n输出描述：提供了输出所要求的格式，内容等信息。\n示例输入、输出：一般会给几组测试用的数据，也就是程序把示例输入数据输进去，输出结果应该和示例输出相同(SpecialJudge也许不同)。\n提示：包含出题人对这一题的提示。\n就这一题而言，因为是一个简单的示范，所以没有输入数据，直接进行输出即可。\n从上一篇文章中学到，输出语句printf()，在这里就可以使用。\n现在假设你在本地编译器中写好了代码。\n1 2 3 4 5 #include\u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;I wanna be the guy!\u0026#34;); return 0; } 那么接下来，点击“提交”，出现提交页面，只需要把代码复制进去，进行提交即可。\n之后便会进入运行状态页面，我们可以看到程序的评判结果。\n具体结果是什么意思-.-自己探索吧。\n系统帮助 \u0026amp; FAQ\n杭州电子科技大学(hdoj)FAQ\n剩下的就是自己动手，先完成这个简单的题目吧。\n【愿成其身】I wanna be the guy\n","date":"2016-08-16T16:00:51Z","permalink":"https://boiltask.com/tutorial/iwbtg/2/","title":"【愿成其身】[2]有趣的练习方式 – OnlineJudge"},{"content":" 子曰：“工欲善其事，必先利其器。居是邦也，事其大夫之贤者，友其士之仁者。”\n看到这里，想必是对ACM感兴趣的。而想要“善其事”，则必然要先了解必要的工具。对于ACM，我指的自然就是编程语言。就目前看来常用的语言有C/C++、JAVA、PASCAL等，其中C/C++就个人而言更为常用，也广泛应用于其它领域，所以这里重点以C/C++作为入门讲解。\n然而，正文却依旧不能继续，有一点非常重要。\n“语言毕竟只是算法竞赛的工具——尽管这个工具非常重要，却不是核心。”这是刘汝佳《算法竞赛入门经典(第2版)》前言中的一句话。我感觉对于ACM入门者来说非常重要，这也是很多人半途而废的原因之一。可能很多人认为ACM便是研究编程，但是我不得不说，语言入门之后离真正的算法程序还有一段距离。或者说，如果只是为了学习语言，那么ACM可能会让你失望，因为这并不是ACM的本意。甚至于在ACM中的一些常用写法，在做应用项目时可能会进行避免，因为这是两种不同的编程要求。\n但我相信，在ACM都能学好，其它领域怎么会学不好呢？\n所以人工重要的事情重复三遍。\n但我相信，在ACM都能学好，其它领域怎么会学不好呢？\n所以人工重要的事情重复三遍。\n语言毕竟只是算法竞赛的工具——尽管这个工具非常重要，却不是核心。\n语言毕竟只是算法竞赛的工具——尽管这个工具非常重要，却不是核心。\n语言毕竟只是算法竞赛的工具——尽管这个工具非常重要，却不是核心。\n我个人对C语言的看法，所谓一门“语言”，它有自己的“语法”与“单词”。我们要做的，就是遵循它的语法，用它提供的单词组合成自己“文章”。\n而作为一门实用性的学科，我主张还是“学以致用，以用促学”，所以先来看一篇“文章”。\n1 2 3 4 5 #include\u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;I wanna be the guy!\u0026#34;); return 0; } 这段简单的代码展示了C的一些基础结构，下面逐句分析。\n第一行“#include\u0026lt;stdio.h\u0026gt;”按照我们的语法喜欢，很明显这句话要分成两部分来看“#include\u0026lt;\u0026gt;”和被尖括号括在里面的“stdio.h”。这一句代表声明一个“stdio.h”的头文件，什么叫头文件……继续看下面。\n按照同样的思路，很显然下面是一个 int main(){ }和被大括号括在里面的一些句子。这里的main被称为主函数，程序的开始便是从main()函数为起点的。\n什么叫函数？-.-||\n数学里的函数见过吧……$f(x)=x+1$ 这个函数是什么意思呢，我们给这个函数一个“参数”x，那么它便会给我们一个“返回值”x+1。比如我们给个参数3，那么它便会告诉我们4，这就是函数。\n同样的，对于C语言来说，这些函数我们可以给它们传递参数，它们也会有返回值，而返回值具体是什么，自然也是可以有我们来控制。这就是编程的魅力，就是那种，“想显示什么结果，你说的不算，要看我怎么写”的霸气。\n言归正传，对于main()函数而言，我们看到它前面有个int，这就是代表的它的返回值的类型，而具体是什么类型，这将在后面数据类型中详细讲。(PS：int又被称为整型哦~)\n那么main()←这个括号呢，就如$f(x)$，这个括号自然是让你传递参数用的，而main函数作为一个特殊的“主”函数，它的参数可以省略不写。\n那你想写……那么它的参数形如“int argc,char *argv[]”……\n这都是啥啥啥……\n-.-所以我不是很想提前说这么多的嘛，你先默认把它理解为空好了。\n这样参数的问题也解决了，怎么控制返回值具体是什么呢。看一看main函数括号里面，以小学英语水平，可以明显发现一个单词“return - 返回”，那么就是翻译为返回0。\n-0是啥？\n-整数嘛。\n-所以是什么类型？\n-整型嘛。\n-所以返回值类型怎么写？\n-int嘛。\nC语言就是这么简单。 -.-\n接下来就只剩下最后一句话了“printf(\u0026ldquo;I wanna be the guy!\u0026quot;)”，很明显也是printf()与“I wanna be the guy!”组合。上面学习了函数的基本结构，那么这个printf后面也是有个括号，它与函数有没有关系。很显然我这么说了，它必然是有的。\n按照刚才的理解，括号里面的\u0026quot;I wanna be the guy!\u0026ldquo;也就是它的参数了，那么这个函数有什么用呢。\nprint-f继续按照小学英语理解，明显和印刷、打印有关系，所以这个函数也是就把它的参数“I wanna be the guy!”“打印”到屏幕上，这叫格式化输出。当然，具体怎么用，还需要进一步学习。\n我们知道，你如果想要用一个函数，你应该先把这个函数定义好。\n还是比如你输入x，想让函数返回给你x+1，那么这个函数就应该定义成$f(x)=x+1$。 可以这个printf在哪里定义的呢，为什么写上这一句话，计算机就知道把它的参数打印到屏幕上。这个时候我们再来看程序开头的那一句“#include\u0026lt;stdio.h\u0026gt;”，突然意识到了什么.jpg。\n没错，这个被叫做头文件的东西就包含了C语言一些默认的“标准库”，需要的时候只需要先声明你想要用哪些头文件，然后在你的程序里就可以调用它的函数啦(当然不只是函数，还有其他的一些东西)。\n声明方法就是#include\u0026lt;头文件名\u0026gt;。\nstdio.h就是包含了标准输入输出的一个头文件，也是常用到作为模板的一个头文件。\n更多的头文件在后面接触到的时候会继续说。\n下面就可以再来重新看一下这个代码了，很显然，这个程序可以完成把“I wanna be the guy!”这句话输出到屏幕的这个任务。\n-.-好，问题来了，怎么运行。\n这一部分我不是很想详细说，毕竟我感觉讲太详细是件不负责任的事情，因为剥夺了自己探索的乐趣。\n所以这里只提供一个下载链接，其余的……\nDev-C++(C++开发工具)V5.11.0中文免费版(不可调试)\nDev C++ V5.9.2 绿色中文版(可调试)\n接下来，怎么知道自己的程序标不标准，怎么训练自己的编程能力。\n这里涉及到ACM常用的一个训练工具，OnlineJudge。\n下面是这一个程序的题目，在题解里会详细介绍OJ的用法：\n【愿成其身】I wanna be the guy\n","date":"2016-08-15T16:00:19Z","permalink":"https://boiltask.com/tutorial/iwbtg/1/","title":"【愿成其身】[1]工欲善其事，必先利其器"},{"content":" I wanna be the guy - 愿成其身\n昨天想写文章时突然想起来了这个游戏，原因却不是清楚太多……想了想，大概是这个标榜难度巨高无比游戏的背景也是个励志故事吧，所以当人物一次次的死亡时，你就会心生敬佩(虽然应该是敬佩那些能把这游戏死上一万次来通关的人)。\n其实ACM大概也是这个道理，虽然明知道一路上布满坎坷，明知道自己也许坚持不到关底，但自己也愿意去尝试一下。我很遗憾直到去年的今天都还不知道ACM是什么东东，虽然从小就标榜喜欢计算机，但却也是因为种种原因而胡乱摸索不得要领。所以，当大一时进入这个大门，人生中第一次有一群人愿意和你交流这些你喜欢的，表演真正的技术，内心才会产生出一丝激动。\n爱上ACM，大抵也就是如此。\n我以为在有一个教师老爸的前提下，在有一个万般告诫我不要当老师的老爸的前提下，在自己自认为对当老师完全不感兴趣的前提下，自己应该是对教东西不感什么兴趣的。然而慢慢发现，自己虽然对当老师不怎么感兴趣，但是对于能把自己所知道的知识讲给别人这件事，我确实还是很痴迷的。\n这也就是我想写这个系列的原因。\n与此同时，我感觉到自己也需要有所提高，所以写下这篇前言，也算是告诫自己吧。\n这个系列的文章，我的定位是作为一个餐后读物，特别是在已经看了很多专业性书之后来看，也许会更有感觉一些。强调的是“共鸣”，而非教学，所以大可把它当做一篇“ACM——我刚开始就是这么想的”。\n如果在看的时候偶然发现，“哎呀，我也是这么认为的。”，那么也算是我的荣幸了。\n点此查看本系列导读目录\nPS：\n因为文章内可能大量使用Katex渲染数学公式，所以请使用新版浏览器阅读。\n如果遇到加载失效，请刷新页面重试。\n","date":"2016-08-14T16:00:19Z","permalink":"https://boiltask.com/tutorial/iwbtg/0/","title":"【愿成其身】I wanna be the guy"},{"content":" 本系列文章中涉及到的图片与链接因为年久可能出现失效，有需要可联系作者交流。\n====入门导读===== 电子科技大学CDOJ：\n【Step-By-Step】\nhttps://acm.uestc.edu.cn/\n南阳理工学院NYOJ：\n【进阶计划】\nhttp://acm.nyist.net/JudgeOnline/step.php\n====愿成其身===== 【前言】 I wanna be the guy\n【入门】 工欲善其事，必先利其器\n有趣的练习方式 – OnlineJudge\n转义字符 – 格式化输出\n从A+B谈起 – 一切的开端\n数据类型 – 装数据的盒子\nA×B的学问 – 较大数的处理\n整数的魅力 – 数字的最后一位\n实数的运用 – 整数化作的实数\n分支结构 – 程序的魅力\n问号表达式 – 酷炫的利器\n字符的本质 – ASCII的作用\n从交换输出谈起 – 黑盒的漏洞\n循环结构 – 计算机的神奇\nfor循环 – 另一种表达方法\n思维的优化 – 数学的魅力\n未完待续……\nPS 因为文章内可能大量使用Katex渲染数学公式，所以请使用新版浏览器阅读。\n如果遇到加载失效，请刷新页面重试。\n公式显示测试\n这是公式f(x)=x+1 : $f \\left( x \\right) = x + 1$\n如果显示不全请刷新页面或者更换浏览器\n=====若无意外-三日一更===== 很显然，大概有很大的意外……\n可使用rss阅读器订阅\nrss订阅地址如下，推荐使用一览阅读订阅\nRSS已废弃，可查看标签：愿成其身\n","date":"2016-08-13T16:00:25Z","permalink":"https://boiltask.com/tutorial/iwbtg/introduction/","title":"【愿成其身】导读目录"},{"content":"问题描述 序列变换\r[hdu-5256] [3299176657482508] @vjudge\r问题分析 考虑序列限制条件为a[i]-a[j]\u0026gt;=i-j\na[i]-i\u0026gt;=a[j]-j\n所以考虑建数组b[i]=a[i]-i\n则问题转换为求数组b[i]的不递减序列的长度l\n则最后结果为n-l\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include \u0026lt;stdio.h\u0026gt; int inf=99999999; int n,l; int a[100200]; int s[100200]; int find(int m) { int la=0,lb=l; while(lb\u0026gt;=la) { int mid=(la+lb)\u0026gt;\u0026gt;1; if(s[mid]\u0026gt;m) lb=mid-1; else la=mid+1; } return la; } int main() { int T,kase=0; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i=1; i\u0026lt;=n; i++) { int t; scanf(\u0026#34;%d\u0026#34;,\u0026amp;t); a[i]=t-i; } s[0]=-inf; l=1; for(int i=1; i\u0026lt;=n; i++) { s[l]=inf; int t=find(a[i]); if(t==l) l++; s[t]=a[i]; } printf(\u0026#34;Case #%d:\\n\u0026#34;,++kase); printf(\u0026#34;%d\\n\u0026#34;,n-l+1); } return 0; } ","date":"2016-08-11T20:09:55+08:00","permalink":"https://boiltask.com/oj/hdu/5256/","title":"【杭电】[5256]序列变换"},{"content":" 有n件物品，第i件物品(I = 1,2,3…n)的价值是vi, 重量是wi,我们有一个能承重为m的背包，我们选择一些物品放入背包，每样只能放一个，显然放入背包的总重量不超过m。我们要求选择物品的总价值最大，请问如何选择？这里我们假设所有出现的数都是正整数。\n背包问题如果没有认真理解的话，第一种思路应该会往贪心的方面思考。\n比如先以物品贵重程度排序，先选比较贵重的。\n然而对于数据:\nn = 3, m = 3\nv = （2，2，3）\nw = （1，2，3）\n按照先选贵重物品的策略，会先选择价值为3的那个，并且背包装满了，但是如果我们选取前两个物品，总价值可以达到4。\n如果按照性价比排序：\n对于数据\nn = 3, m = 7\nv = （2，3，4）\nw = （3，4，5）\n按这种方法因为2/3 \u0026lt; 3/4 \u0026lt; 4 / 5，我们先选择第三件物品，但是选了它之后别的东西放不下了！总价值是4，但如果我们选择前两件物品可以拿到总价值5。\n造成这种现象的原因是贪心的原则为：通过每一步的最优解推导出整体的最优解，然而对于背包问题，因为每一步取或者不取的最优解取决于整体，也就是“动态”的。所以，背包问题成为了一个经典的动态规划问题。\n再看一道部分背包问题\n一个旅行者有一个最多能装m公斤的背包，然后又n重物品，它们的重量和价值分别为w[i],c[i]，问旅行者能获得的最大价值\n这一题便是贪心问题，因为我们可以一直选性价比高的直到填满，所以是否贪心取决于每种物品是否只取走一部分。\n而背包问题又衍生出了很多变形，动态规划的方法也不尽相同，所以需要多加练习才能掌握这一题型。\n参考文章：\n51NOD\n百度知道\n百度文库\n","date":"2016-08-09T18:14:29+08:00","permalink":"https://boiltask.com/knowledge/knapsack-problem/","title":"背包——误认为贪心的陷阱"},{"content":"问题描述 最少拦截系统\r[hdu-1257] [3123535222321891] @vjudge\r问题分析 考虑若使炮弹命中最多，则炮弹命中导弹的导弹递减\n所以需要发射LIS次，以为代表无法调整使其命中更多\nn2一般dp算法：\n对于每一个a[i]判断a[0i]能否把它更新成dp[j]+1\n也就是看a[i]能否加在a[0i]中的某个数之后\n达到一个新的最大值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include\u0026lt;stdio.h\u0026gt; int a[30200],dp[30200]; int main() { int n; while(scanf(\u0026#34;%d\u0026#34;,\u0026amp;n)!=EOF) { for(int i=0; i\u0026lt;n; i++) { dp[i]=1; scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]); } int res=0; for(int i=1; i\u0026lt;n; i++) for(int j=0; j\u0026lt;i; j++) if(a[i]\u0026gt;a[j]\u0026amp;\u0026amp;dp[i]\u0026lt;dp[j]+1) { dp[i]=dp[j]+1; if(res\u0026lt;dp[i]) res=dp[i]; } printf(\u0026#34;%d\\n\u0026#34;,res); } return 0; } nlogn二分算法：\n建一个数组保存取的数列的可能性\n然后每判断到一个a[i]在s中找到一个s[k]\u0026lt;a[i]\u0026lt;s[k+1]的位置\n然后用a[i]替换掉s[k+1]\n也就是尽量用小的把使子序列相同的长度替换掉\n这样可以保证后面的数比前面的数大的可能性提升\n如果查找到s最后还没有a[i]\u0026lt;s[k+1]\n则说明a[i]比目前s[k]的每一个数都大\n这时候显然要把a[i]加到s的最后面\n因为s中的数必然是单调递增的\n所以在寻找位置的时候可以进行二分搜索优化时间\n二分搜索的实现可以自己写函数\n也可以调用C++中的lower_bound\n自建函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;stdio.h\u0026gt; int inf=99999999; int n,l; int a[30200]; int s[30200]; int find(int m) { int la=0,lb=l; while(lb\u0026gt;=la) { int mid=(la+lb)\u0026gt;\u0026gt;1; if(s[mid]==m) return mid; else if(s[mid]\u0026gt;m) lb=mid-1; else la=mid+1; } return la; } int main() { while(scanf(\u0026#34;%d\u0026#34;,\u0026amp;n)!=EOF) { for(int i=1; i\u0026lt;=n; i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]); s[0]=-1; l=1; for(int i=1; i\u0026lt;=n; i++) { s[l]=inf; int t=find(a[i]); if(t==l) l++; s[t]=a[i]; } printf(\u0026#34;%d\\n\u0026#34;,l-1); } return 0; } 运用C++函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;algorithm\u0026gt; using namespace std; int inf=99999999; int a[30200],s[30200]; int main() { int n; while(scanf(\u0026#34;%d\u0026#34;, \u0026amp;n)!=EOF) { for(int i=1; i\u0026lt;=n; i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]),s[i]=inf; int l=1; for(int i=1; i\u0026lt;=n; i++) { int k=lower_bound(s+1,s+n+1,a[i])-s; if(k==l) l++; s[k]=a[i]; } printf(\u0026#34;%d\\n\u0026#34;,l-1); } return 0; } ","date":"2016-08-09T17:23:55+08:00","permalink":"https://boiltask.com/oj/hdu/1257/","title":"【杭电】[1257]最少拦截系统"},{"content":"问题描述 计算直线的交点数\r[hdu-1466] [3210787742804115] @vjudge\r问题分析 因为并非每对直线都互相相交，所以就要判断平行线的个数\n对于每个n，若有j条平行线，则可进行循环判断\n很显然对于平行的线相交的点为\n平行线个数*非平行线个数\n而非平行线又能有多种相交点个数组合\n于是可以进行递归相加，把非平行线的可能个数加上\n也就是dp[i]=(i-j)*j+dp[i-j]\n很明显发现这种方法把非平行线包含平行线的方案也加上了\n但是对于结果没有影响，只不过会造成重复输出\n所以进行判断这种点数方案有无用过就好\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include\u0026lt;stdio.h\u0026gt; int a[21][200]; int main() { for(int i=0; i\u0026lt;=20; i++) for(int j=0; j\u0026lt;i; j++) if(j==0) a[i][j]=1; else for(int k=0; k\u0026lt;=i*(i-1)/2; k++) if(a[i-j][k]==1) a[i][(i-j)*j+k]=1; int n; while(scanf(\u0026#34;%d\u0026#34;,\u0026amp;n)!=EOF) { for(int i=0; i\u0026lt;=n*(n-1)/2; i++) { if(a[n][i]==1) printf(\u0026#34;%d%c\u0026#34;,i,i==n*(n-1)/2?\u0026#39;\\n\u0026#39;:\u0026#39; \u0026#39;); } } return 0; } ","date":"2016-08-08T15:38:15+08:00","permalink":"https://boiltask.com/oj/hdu/1466/","title":"【杭电】[1466]计算直线的交点数"},{"content":"问题描述 Genealogical tree\r[poj-2367] [3153661691732363] @vjudge\r问题分析 拓扑排序水题\n给出n行\n每行有以0结束的若干行数字，第i行的数字表示i排在这些数字前面\n所以根据题意进行拓扑排序即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; int n,headcnt; int cnt[120]; int topo[120]; int head[120]; struct node { int next; int to; } a[120]; void toposort() { int top,t=0; for(int i=1; i\u0026lt;=n; i++) { for(int j=1; j\u0026lt;=n; j++) { if(cnt[j]==0) { top=j; break; } } topo[t++]=top; cnt[top]=-1; for(int j=head[top]; j!=-1; j=a[j].next) { cnt[a[j].to]--; } } } int main() { while(scanf(\u0026#34;%d\u0026#34;,\u0026amp;n)!=EOF) { memset(cnt,0,sizeof(cnt)); memset(head,-1,sizeof(head)); headcnt=0; for(int i=1; i\u0026lt;=n; i++) { int v; while(scanf(\u0026#34;%d\u0026#34;,\u0026amp;v),v) { a[headcnt].to=v; a[headcnt].next=head[i]; head[i]=headcnt++; cnt[v]++; } } toposort(); for(int i=0; i\u0026lt;n; i++) printf(\u0026#34;%d%c\u0026#34;,topo[i],i==n-1?\u0026#39;\\n\u0026#39;:\u0026#39; \u0026#39;); } return 0; } ","date":"2016-08-08T11:39:03+08:00","permalink":"https://boiltask.com/oj/poj/2367/","title":"【POJ】[2367]Genealogical tree"},{"content":"问题描述 Window Pains\r[poj-2585] [3219815653601074] @vjudge\r问题分析 理解之后算是道比较水的题。\n因为对于每一个网格，如果网格内的数字不是相同的，则网格内的数字必然出现的比应该出现的那个晚，这样把map遍历一遍，便可得到关于1~9的有向图，剩下就是看其能否topo排序，如果无环则这个图形就能出现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; char s[20]; int map[5][5]; int edge[12][12]; int cnt[12]; bool topo() { int num=0; for(int i=1; i\u0026lt;=9; i++) { for(int j=1; j\u0026lt;=9; j++) { if(cnt[j]==0) { cnt[j]--; num++; for(int k=1; k\u0026lt;=9; k++) { if(edge[j][k]==1) { cnt[k]--; } } break; } } } return num==9; } int main() { while(scanf(\u0026#34;%s\u0026#34;,s),strcmp(s,\u0026#34;ENDOFINPUT\u0026#34;)!=0) { memset(edge,0,sizeof(edge)); memset(cnt,0,sizeof(cnt)); for(int i=1; i\u0026lt;=4; i++) for(int j=1; j\u0026lt;=4; j++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;map[i][j]); scanf(\u0026#34;%s\u0026#34;,s); for(int i=1; i\u0026lt;=3; i++) { for(int j=1; j\u0026lt;=3; j++) for(int in=0; in\u0026lt;2; in++) { for(int im=0; im\u0026lt;2; im++) { if(map[i+in][j+im]==j+(i-1)*3) continue; else if(edge[map[i+in][j+im]][j+(i-1)*3]==0) { edge[map[i+in][j+im]][j+(i-1)*3]=1; cnt[j+(i-1)*3]++; } } } } printf(\u0026#34;%s\\n\u0026#34;,topo()?\u0026#34;THESE WINDOWS ARE CLEAN\u0026#34;:\u0026#34;THESE WINDOWS ARE BROKEN\u0026#34;); } return 0; } ","date":"2016-08-08T10:04:07+08:00","permalink":"https://boiltask.com/oj/poj/2585/","title":"【POJ】[2585]Window Pains"},{"content":"问题描述 Rank of Tetris\r[hdu-1811] [3106675065054036] @vjudge\r问题分析 这题拓扑排序只需要判断是否能进行排序和排序是否唯一\n与正常的区别是这里有相等的情况\n因为相等时互相是按照编号进行排列，所以对于其它元素来说，这些相等的元素是一样的，可以把他们当成一个整体，所以思考使用并查集。\n在判断是，只需要考虑i==find(i)的元素，为了判断是否唯一，可以使用队列，当队列中全程同时只有一个元素时，这个排序便是唯一的，若排序完成发现还有元素没有排序(num\u0026gt;0)则说明关系有环，则无法进行排序。\n依旧使用邻接表储存边与点的信息。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; #include\u0026lt;queue\u0026gt; using namespace std; int n,headcnt; int cnt[10200]; int head[10200]; int par[10200]; struct node { int next; int to; } edge[20200]; struct cmpop { int x; char op; int y; } a[20200]; void add(int u,int v) { edge[headcnt].to=v; edge[headcnt].next=head[u]; head[u]=headcnt++; cnt[v]++; } int find(int m) { if(par[m]==m) return m; else return par[m]=find(par[m]); } bool unite(int x,int y) { x=find(x); y=find(y); if(x==y) return false; par[y]=x; return true; } int main() { int m; while(scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m)!=EOF) { memset(head,-1,sizeof(head)); memset(cnt,0,sizeof(cnt)); headcnt=0; for(int i=0; i\u0026lt;n; i++) par[i]=i; int num=n; for(int i=0; i\u0026lt;m; i++) { scanf(\u0026#34;%d %c %d\u0026#34;,\u0026amp;a[i].x,\u0026amp;a[i].op,\u0026amp;a[i].y); if(a[i].op==\u0026#39;=\u0026#39;) if(unite(a[i].x,a[i].y)) num--; } for(int i=0; i\u0026lt;m; i++) { if(a[i].op!=\u0026#39;=\u0026#39;) { int x=find(a[i].x),y=find(a[i].y); if(a[i].op==\u0026#39;\u0026gt;\u0026#39;) add(x,y); else add(y,x); } } queue\u0026lt;int\u0026gt;q; for(int i=0; i\u0026lt;n; i++) { if(!cnt[i]\u0026amp;\u0026amp;i==find(i)) { q.push(i); } } bool flag=false; while(!q.empty()) { if(q.size()\u0026gt;1) flag=true; int top=q.front(); q.pop(); num--; for(int i=head[top]; i!=-1; i=edge[i].next) { cnt[edge[i].to]--; if(!cnt[edge[i].to]) q.push(edge[i].to); } } if(num\u0026gt;0) printf(\u0026#34;CONFLICT\\n\u0026#34;); else if(flag) printf(\u0026#34;UNCERTAIN\\n\u0026#34;); else printf(\u0026#34;OK\\n\u0026#34;); } return 0; } ","date":"2016-08-06T16:36:05+08:00","permalink":"https://boiltask.com/oj/hdu/1811/","title":"【杭电】[1811]Rank of Tetris"},{"content":"问题描述 逃生\r[hdu-4857] [3192632012314298] @vjudge\r问题分析 明显的拓扑排序，但是这一题的条件有两个，除了给的限定条件外还应该优先按照从1~n输出。\n所以考虑使用优先队列来取合适的点\n考虑前面的应该尽量比后面的大，所以若用优先队列，则若正向建边，会导致队列中已有的上一层元素比后推入的元素大，从而使队列完全按照从大到小输出，产生错误结果。\n所以考虑反向建边，则先取最一小级中最大的，并且每一次取当前队列中的最大的，则可以保证在按照1~n的顺序的情况下，按照特殊条件排序。\n因为是反向建边，所以要把得到的结果倒序输出。\n测试数据:\n1 2 3 4 5 6 10 6 4 6 3 3 1 5 4 4 2 输出：\n1 6 3 1 5 4 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;queue\u0026gt; using namespace std; int n; int cnt[30200]; int topo[30200]; struct node { int next; int to; } a[100200]; int head[30200]; void toposort() { priority_queue\u0026lt;int\u0026gt;q; for(int i=1; i\u0026lt;=n; i++) if(!cnt[i]) { q.push(i); } int t=0; while(!q.empty()) { int ttop=q.top(); q.pop(); topo[t++]=ttop; for(int i=head[ttop]; i!=-1; i=a[i].next) { cnt[a[i].to]--; if(!cnt[a[i].to]) q.push(a[i].to); } } } int main() { int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { int m; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m); memset(cnt,0,sizeof(cnt)); memset(head,-1,sizeof(head)); for(int i=0; i\u0026lt;m; i++) { int u,v; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;u,\u0026amp;v); a[i].to=u; a[i].next=head[v]; head[v]=i; cnt[u]++; } toposort(); for(int i=n-1; i\u0026gt;=0; i--) printf(\u0026#34;%d%c\u0026#34;,topo[i],i==0?\u0026#39;\\n\u0026#39;:\u0026#39; \u0026#39;); } return 0; } ","date":"2016-08-06T11:27:26+08:00","permalink":"https://boiltask.com/oj/hdu/4857/","title":"【杭电】[4857]逃生"},{"content":"问题描述 Reward\r[hdu-2647] [3099759746423843] @vjudge\r问题分析 给出某个工人的工资应该比另一个人高\n问最低一共应该发多少工资\n拓扑排序问题\n若把工资最低的那些人标记为入度为0\n第二低的标记为1\n则每个人的工资应该为888+入度\n运用了队列和邻接表优化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstring\u0026gt; #include\u0026lt;queue\u0026gt; using namespace std; int n; int sum[10200]; int cnt[10200]; int head[10200]; struct node { int next; int to; } a[20200]; int res; int toposort() { res=0; queue\u0026lt;int\u0026gt;q; memset(sum,0,sizeof(sum)); for(int i=1; i\u0026lt;=n; i++) { if(cnt[i]==0) { q.push(i); sum[i]=888; } } int t=0; while(!q.empty()) { int top=q.front(); q.pop(); t++; res+=sum[top]; for(int i=head[top]; i!=-1; i=a[i].next) { if(--cnt[a[i].to]==0) { q.push(a[i].to); sum[a[i].to]=sum[top]+1; } } } return t\u0026lt;n?-1:res; } int main() { int m; while(scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m)!=EOF) { memset(cnt,0,sizeof(cnt)); memset(head,-1,sizeof(head)); for(int i=0; i\u0026lt;m; i++) { int u,v; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;u,\u0026amp;v); a[i].to=u; a[i].next=head[v]; head[v]=i; cnt[u]++; } printf(\u0026#34;%d\\n\u0026#34;,toposort()); } return 0; } ","date":"2016-08-06T09:58:38+08:00","permalink":"https://boiltask.com/oj/hdu/2647/","title":"【杭电】[2647]Reward"},{"content":"问题描述 确定比赛名次\r[hdu-1285] [3122403987687238] @vjudge\r问题分析 拓扑排序模板题\n寻找入度为0的点，存入topo数组，删除它与它相连的边，然后把与它相连的点入度减少1\n最终topo即为所求排序后的数组\n运用邻接表优化存储\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include\u0026lt;cstdio\u0026gt; #include\u0026lt;cstdlib\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; int n; int cnt[520]; int topo[520]; struct node { int next; int to; } a[520]; int head[520]; void toposort() { int top,t=0; for(int i=0; i\u0026lt;n; i++) { for(int j=1; j\u0026lt;=n; j++) { if(cnt[j]==0) { top=j; break; } } topo[t++]=top; cnt[top]=-1; for(int j=head[top]; j!=-1; j=a[j].next) { cnt[a[j].to]--; } } } int main() { int m; while(scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m)!=EOF) { memset(cnt,0,sizeof(cnt)); memset(head,-1,sizeof(head)); for(int i=0; i\u0026lt;m; i++) { int u,v; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;u,\u0026amp;v); a[i].to=v; a[i].next=head[u]; head[u]=i; cnt[v]++; } toposort(); for(int i=0; i\u0026lt;n; i++) printf(\u0026#34;%d%c\u0026#34;,topo[i],i==n-1?\u0026#39;\\n\u0026#39;:\u0026#39; \u0026#39;); } return 0; } ","date":"2016-08-05T18:08:15+08:00","permalink":"https://boiltask.com/oj/hdu/1285/","title":"【杭电】[1285]确定比赛名次"},{"content":"问题描述 统计难题\r[hdu-1251] [3150964048920354] @vjudge\r问题分析 字典树模板题，对每个节点记录cnt\n最后一个字母的cnt便是以s为前缀的单词个数\n注意释放内存\n杭电G++一直爆内存……C++可以AC\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; struct Trie { int cnt; Trie *next[26]; }*root; void Insert(char *s) { Trie *p,*t; int l=strlen(s); p=root; for(int i=0; i\u0026lt;l; i++) { if (p-\u0026gt;next[s[i]-\u0026#39;a\u0026#39;]==NULL) { t=new Trie; t-\u0026gt;cnt=1; for (int j=0; j\u0026lt;26; j++) t-\u0026gt;next[j]=NULL; p-\u0026gt;next[s[i]-\u0026#39;a\u0026#39;]=t; } else p-\u0026gt;next[s[i]-\u0026#39;a\u0026#39;]-\u0026gt;cnt++; p=p-\u0026gt;next[s[i]-\u0026#39;a\u0026#39;]; } } int Search(char *s) { Trie *p; int l=strlen(s); p=root; for(int i=0; i\u0026lt;l; i++) { if (p-\u0026gt;next[s[i]-\u0026#39;a\u0026#39;]==NULL) return 0; p=p-\u0026gt;next[s[i]-\u0026#39;a\u0026#39;]; } return p-\u0026gt;cnt; } void Release(Trie *p) { if (p==NULL) return ; for (int i=0; i\u0026lt;26; i++) if (p-\u0026gt;next[i] != NULL) Release(p-\u0026gt;next[i]); free(p); root = NULL; return ; } void Init() { root=new Trie; root-\u0026gt;cnt=0; for (int i=0; i\u0026lt;26; i++) root-\u0026gt;next[i]=NULL; } int main () { char str[15]; Init(); while (gets(str),strcmp(str,\u0026#34;\u0026#34;)!=0) Insert(str); while (scanf (\u0026#34;%s\u0026#34;,str)!=EOF) printf (\u0026#34;%d\\n\u0026#34;,Search(str)); Release(root); return 0; } ","date":"2016-08-05T16:36:41+08:00","permalink":"https://boiltask.com/oj/hdu/1251/","title":"【杭电】[1251]统计难题"},{"content":"问题描述 985的数学难题\r时间限制：2 Sec内存限制：128 MB\rDescription 985有n个正整数，他想快速知道下面函数的返回值\n1 2 3 4 5 6 7 8 9 10 11 int a[N+1]; long long Solve() { int i, j; long long ans = 0; for(i = 1; i \u0026lt;= N; i++) { for(int j = i + 1; j \u0026lt;= N; j++) { ans += a[i] + a[j] + (a[i] ^ a[j]) + (a[i] | a[j]) + (a[i] \u0026amp; a[j]); } } return ans; } 注：^表示异或运算。\nInput 第一行输入一个整数t，代表有t组测试数据。\n每组数据第一行输入一个整数代表元素个数，接下来一行输入n个正整数a[]。\n注：1 \u0026lt;= t \u0026lt;= 30，1 \u0026lt;= n，a[] \u0026lt;= 100000。\nOutput 一个整数代表最后的返回值ans。\nSample Input 1 2 3 4 5 2 1 10 2 1 1 Sample Output 1 2 0 4 问题分析 很显然不能直接写函数计算\n这种类型的题目涉及到二进制运算\n有定理\nx^y+x\u0026amp;y==x|y\n考虑二进制的每一位对结果的影响\n比如1101、1001、1010进行上述运算\n则可发现\n从右到左每一位上有1的个数记为\ncnt[0]~cnt[3]分别为\n2、1、1、3\n因为或运算除了0|0==0\n其余都为1\n也就是0|1+1|1\n所以对于最右边运算后有效的1个数\n为 cnt[0](n-cnt[0])+(cnt[0](cnt[0]-1))/2\n而这些1所代表的个数要转变为十进制\n则要乘上其对应的1\u0026laquo;0\n所以核心代码为\n1 2 3 for(int i=0; i\u0026lt;lx; i++) { res+=(1\u0026lt;\u0026lt;i)*(cnt[0][i]*cnt[1][i]+(cnt[1][i]-1)*cnt[1][i]/2); } 其中lx代表最大数的二进制位数\n至于求a[i]+a[j]\n只需要把a[1~n]相加求和之后乘(n-1)\n也就是每个数用了n-1次\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; long long a[100200]; int main() { int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i=0; i\u0026lt;n; i++) { scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]); } sort(a,a+n); long long cnt[2][50]; int lx=0; memset(cnt,0,sizeof(cnt)); for(; a[n-1]\u0026gt;\u0026gt;lx!=0; lx++) for(int i=0; i\u0026lt;n; i++) cnt[a[i]\u0026gt;\u0026gt;lx\u0026amp;1][lx]++; long long res=0; for(int i=0; i\u0026lt;lx; i++) { res+=(1\u0026lt;\u0026lt;i)*(cnt[0][i]*cnt[1][i]+(cnt[1][i]-1)*cnt[1][i]/2); } res*=2; for(int i=0; i\u0026lt;n; i++) { res+=(n-1)*a[i]; } printf(\u0026#34;%lld\\n\u0026#34;,res); } return 0; } 题目地址: 【郑轻】[1893]985的数学难题\n","date":"2016-08-04T00:05:26+08:00","permalink":"https://boiltask.com/oj/zzuli/1893/","title":"【郑轻】[1893]985的数学难题"},{"content":"问题描述 985的“树”难题\r时间限制：1 Sec内存限制：128 MB\rDescription 985给你一棵“树”以及它的根节点，要求你先判定它是否是一棵树，其次他想知道每个节点的“太子”数目以及它的父亲（root的话输出自己）。\n“太子判定条件”：\n一、若x是y的孩子节点，那么x是y的“太子”；\n二、若x是y的“太子”且y是z的“太子”，那么x是z的“太子”。\nInput 第一行输入一个整数t，代表有t组测试数据。\n每组数据第一行输入两个整数n，root分别代表树的节点数目以及根节点的编号。\n接下来n-1行，每行输出两个整数u，v代表u节点和v节点之间有一条树边。\n注：1 \u0026lt;= t \u0026lt;= 20，1 \u0026lt;= n \u0026lt;= 1e4，1 \u0026lt;= root \u0026lt;= n，1 \u0026lt;= u，v \u0026lt;= n。\nOutput 对每一组数据，若给定的“树”不合法输出NO即可，反之输出YES，接下来输出占两行：\n第一行输出n个整数代表每个节点的“太子”数目，\n第二行输出n个整数代表每个节点的父亲节点编号。\n输出顺序从1到n，每两个数之间有一个空格，最后一个数后面没有空格。\nSample Input 1 2 3 4 5 6 2 3 1 1 2 2 3 2 1 1 1 Sample Output 1 2 3 4 YES 2 1 0 1 1 2 NO 问题分析 -.-证明我不适合比赛的一题\n宇神称之为签到题\n事实上涉及到了一些知识点也不复杂\nDFS、并查集、邻接表\nDFS用来递归查找下一节点\n并查集用来更新节点的深度和父节点的信息\n邻接表用来优化数据结构\n1、读取输入存入邻接表\n2、以root为起点DFS下一节点\n3、以并查集思想把下一节点的父节点设为这一节点\n最后用find函数来更新根的深度\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; int head[10200]; int headcnt; bool win; struct List { int u,v; int next; } edge[20200]; int n,root; int par[10200]; int ran[10200]; int flag[10200]; int find(int m) { if(m==par[m]) return m; else { ran[par[m]]++; return find(par[m]); } } void unite(int x,int y) { par[y]=x; } void dfs(int u) { for(int i=head[u]; i!=-1; i=edge[i].next) { if(!flag[edge[i].v]\u0026amp;\u0026amp;edge[i].v!=par[u]) { unite(u,edge[i].v); flag[edge[i].v]=1; dfs(edge[i].v); } } } void add(int u,int v) { edge[headcnt].u=u; edge[headcnt].v=v; edge[headcnt].next=head[u]; head[u]=headcnt++; } int main() { int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;root); headcnt=0; memset(head,-1,sizeof(head)); memset(flag,0,sizeof(flag)); for(int i=1; i\u0026lt;=n; i++) { par[i]=i; ran[i]=0; } for(int i=1; i\u0026lt;n; i++) { int u,v; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;u,\u0026amp;v); add(u,v); add(v,u); } win=true; flag[root]=1; dfs(root); if(win) { for(int i=1; i\u0026lt;=n; i++) if(find(i)!=root) { win=false; break; } } if(win) { printf(\u0026#34;YES\\n\u0026#34;); for(int i=1; i\u0026lt;=n; i++) { printf(\u0026#34;%d\u0026#34;,ran[i]); if(i==n) printf(\u0026#34;\\n\u0026#34;); else printf(\u0026#34; \u0026#34;); } for(int i=1; i\u0026lt;=n; i++) { printf(\u0026#34;%d\u0026#34;,par[i]); if(i==n) printf(\u0026#34;\\n\u0026#34;); else printf(\u0026#34; \u0026#34;); } } else printf(\u0026#34;NO\\n\u0026#34;); } return 0; } 题目地址:【郑轻】[1900]985的“树”难题\n","date":"2016-08-03T20:55:51+08:00","permalink":"https://boiltask.com/oj/zzuli/1900/","title":"【郑轻】[1900]985的“树”难题"},{"content":"问题描述 985的因子对难题\r时间限制：2 Sec内存限制：128 MB\rDescription 985有n个正整数，他想知道存在多少个不同的因子对(a[i], a[j])使得\n1 \u0026lt;= i, j \u0026lt;= n \u0026amp;\u0026amp; i != j \u0026amp;\u0026amp; a[j] % a[i] == 0，其中i和j是元素的下标。\n特别地，他认为（a[i]，a[j]）与（a[j]，a[i]）是一样的因子对。\nInput 第一行输入一个整数t，代表有t组测试数据。\n每组数据占两行，第一行输入一个n代表元素个数，下面一行输入n个整数a[]。\n注：1 \u0026lt;= t \u0026lt;= 30，1 \u0026lt;= n \u0026lt;= 1e5，1 \u0026lt;= a[] \u0026lt;= 1e6。\nOutput 一个整数代表最后的答案。\nSample Input 1 2 3 4 5 2 5 1 2 3 4 5 5 2 2 2 2 2 Sample Output 1 2 5 10 问题分析 很明显直接$n^2$会爆TL\n宇神：\n这道题相当于是求所有数的因子个数之和，但注意（a[i]，a[i]）是不合法的。\n这里姑且说一个比较好想的思路：\n首先我们可以升序排列并去重，用num[i]记录元素i出现的次数，sum[i]表示元素i的因子个数其中不含i自己。\n在统计a[i]的时候，它的贡献为：sum[a[i]] * num[a[i]] + num[i] * (num[i] - 1) / 2。\n考虑从前往后做，在统计a[i]时，可以把a[i]的倍数a[i] * j统计上即sum[a[i] * j] += num[a[i]]（j \u0026gt;= 2）。\n这样在求解a[i]的贡献时，sum[a[i]]的值已经求出来了，只需累加贡献即可，而且时间复杂度是调和级数级别的。\n时间复杂度：O(T * n * log(n))。其实可以先用类似素数筛预处理，这样会更快。\n菜鸡：\n考虑每个数最其倍数的影响\n采取类似素数筛法的思路\n每次遇见一个数t\n则把t的所有倍数都加上t的个数\n所以结果加上(t的个数*t的这个倍数的个数)\n因为t本身也是本身的因数\n所以需要res+=n*(n-1)/2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; int a[1000020]; int main() { int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { memset(a,0,sizeof(a)); int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); int max=0; for(int i=0; i\u0026lt;n; i++) { int t; scanf(\u0026#34;%d\u0026#34;,\u0026amp;t); a[t]++; if(max\u0026lt;t) max=t; } int sum=0; for(int i=1; i\u0026lt;=max; i++) { if(a[i]) { for(int j=i+i; j\u0026lt;=max; j+=i) { if(a[j]) { sum+=a[i]*a[j]; } } sum+=(int)(((long long)a[i]*(a[i]-1))/2); } } printf(\u0026#34;%d\\n\u0026#34;,sum); } return 0; } 题目地址:【郑轻】[1902]985的因子对难题\n","date":"2016-08-03T20:55:51+08:00","permalink":"https://boiltask.com/oj/zzuli/1902/","title":"【郑轻】[1902]985的因子对难题"},{"content":"问题描述 985的数字难题\r时间限制：1 Sec内存限制：128 MB\rDescription 985有n个数，已知每次操作可以将其中不相同的两个数一个加一、一个减一，操作次数不限。\n问他最多可以得到多少个相同的数。\nInput 第一行输入一个整数t，代表有t组测试数据。\n每组数据占两行，第一行输入一个n代表元素个数，下面一行输入n个整数a[]。\n注：1 \u0026lt;= t \u0026lt;= 30，1 \u0026lt;= n \u0026lt;= 1e4，1 \u0026lt;= a[] \u0026lt;= 1e3。\nOutput 输出一个整数代表最多可以得到多少个相同的数。\nSample Input 1 2 3 4 5 2 3 1 1 1 2 2 3 Sample Output 1 2 3 1 问题分析 因为一加一减总数不变\n可知最后的数与sum/n也就是平均数有关\n当sum%n==0时最终必能化为n个相同的数\n否则最后必然多出一个sum-sum/n*n\n所以最终只能化为n-1个相同的数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; int main() { int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); int sum=0; for(int i=0; i\u0026lt;n; i++) { int t; scanf(\u0026#34;%d\u0026#34;,\u0026amp;t); sum+=t; } if(sum%n==0) printf(\u0026#34;%d\\n\u0026#34;,n); else printf(\u0026#34;%d\\n\u0026#34;,n-1); } return 0; } 题目地址:【郑轻】[1898]985的数字难题\n","date":"2016-08-03T20:32:30+08:00","permalink":"https://boiltask.com/oj/zzuli/1898/","title":"【郑轻】[1898]985的数字难题"},{"content":"问题描述 985的红绿灯难题\r时间限制：1 Sec内存限制：128 MB\rDescription 已知红、绿、黄灯各持续r、g、y秒，985发现此时灯刚刚变绿，他想知道x秒后灯是什么颜色。\nInput 第一行输入一个整数t，代表有t组测试数据。\n每组数据输入四个整数x，g，y，r。\n注：1 \u0026lt;= t \u0026lt;= 30，1 \u0026lt;= x，g，r，y \u0026lt;= 1e9。\nOutput 若x秒后变成红色输出R，变成绿色输出G，反之输出Y。\nSample Input 1 2 3 4 3 5 5 2 8 7 5 2 8 16 5 2 8 Sample Output 1 2 3 Y R G HINT 红绿灯顺序:绿-\u0026gt;黄-\u0026gt;红-\u0026gt;绿 问题分析 签到水题\nx%(r+y+g)后推算即可\n注意r+y+g是可以爆int的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include\u0026lt;stdio.h\u0026gt; int main() { int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { long long x,r,g,y; scanf(\u0026#34;%lld %lld %lld %lld\u0026#34;,\u0026amp;x,\u0026amp;g,\u0026amp;y,\u0026amp;r); x%=r+g+y; if(x\u0026lt;g) printf(\u0026#34;G\\n\u0026#34;); else { x-=g; if(x\u0026lt;y) printf(\u0026#34;Y\\n\u0026#34;); else printf(\u0026#34;R\\n\u0026#34;); } } return 0; } 题目地址:【郑轻】[1897]985的红绿灯难题\n","date":"2016-08-03T20:16:01+08:00","permalink":"https://boiltask.com/oj/zzuli/1897/","title":"【郑轻】[1897]985的红绿灯难题"},{"content":"问题描述 985的0-1串难题\r时间限制：1 Sec内存限制：128 MB\rDescription 985有一个长度为n的0-1串，已知他最多可以修改k次（每次修改一个字符即0-\u0026gt;1 或者 1-\u0026gt;0），他想知道连续的全1子串最长是多少。\nInput 第一行输入一个整数t，代表有t组测试数据。\n每组数据第一行输入两个整数n，k分别代笔上面的信息。\n注：1 \u0026lt;= t \u0026lt;= 12，1 \u0026lt;= n \u0026lt;= 100000，0 \u0026lt;= k \u0026lt;= 100000。\nOutput 一个整数代表可以得到的最大长度。\nSample Input 1 2 3 4 5 2 6 3 010100 6 2 010100 Sample Output 1 2 5 4 问题分析 宇神：\n解法一：发现最后的结果是线性的，我们二分答案，把问题变成判定性问题。\n对于当前的二分值mid，判断它的合法性即：是否存在一个mid的连续段使得该段的0字符总数 \u0026lt;= k。\n时间复杂度：O(T * n * log(n))。\n解法二：考虑dp，dp[i]表示以第i个字符开始的最优连续段。\n那么我们只要找到最大的j（i \u0026lt;= j \u0026lt;= n）使得[i, j]里面0字符总数 \u0026lt;= k即可。\n可以先统计0字符的前缀和，然后每次二分即可。最后结果就是max(dp[i]) （1 \u0026lt;= i \u0026lt;= n）。\n时间复杂度：O(T * n * log(n))。\n菜鸡：\n记录0~i之间有多少0保存才cnt[i]中\n则区间[n,m]中有a[m]-a[n-1]个0\n长度(含有字符数)为n-m+1\n所以比较k与a[m]-a[n-1]从而进行区间更新\n并记录出现过的最大长度即为结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; char s[100200]; int cnt[100200]; int main() { int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { int n,k; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;k); scanf(\u0026#34;%s\u0026#34;,s); cnt[0]=(s[0]==\u0026#39;0\u0026#39;?1:0); for(int i=1; i\u0026lt;n; i++) { cnt[i]=cnt[i-1]; if(s[i]==\u0026#39;0\u0026#39;) cnt[i]++; } if(cnt[n-1]\u0026lt;=k) printf(\u0026#34;%d\\n\u0026#34;,n); else { int l=0,res=0; for(int i=0; i\u0026lt;n; i++) { while(k\u0026lt;cnt[i]-(l==0?0:cnt[l-1])) l++; res=max(res,i-l+1); } printf(\u0026#34;%d\\n\u0026#34;,res); } } return 0; } 题目地址：[1895]985的0-1串难题\n","date":"2016-08-03T20:09:30+08:00","permalink":"https://boiltask.com/oj/zzuli/1895/","title":"【郑轻】[1895]985的0-1串难题"},{"content":"问题描述 985的最大和难题\r时间限制：1 Sec内存限制：128 MB\rDescription 985有2 * n - 1个整数，他每次可以将其中n个数变号，操作次数不限，问他可以得到的最大和。\nInput 第一行输入一个整数t，代表有t组测试数据。\n每组数据占两行，第一行输入一个整数n，下面一行输入2*n-1个整数a[]。\n注：1 \u0026lt;= t \u0026lt;= 32，1 \u0026lt;= n \u0026lt;= 1e3，-1e3 \u0026lt;= a[] \u0026lt;= 1e3。\nOutput 输出一个整数代表可以得到的最大和。\nSample Input 1 2 3 4 5 2 2 1 1 1 2 -10 20 -10 Sample Output 1 2 3 40 问题分析 n=3时的负数变化\n(0为负数1为正数)\n有一个：\n1 2 3 4 0 1 1 1 1 1 0 0 1 1 1 0 1 0 0 1 1 1 1 1 有两个：\n1 2 3 4 0 0 1 1 1 0 1 0 0 1 1 1 1 1 1 有三个：\n1 2 3 0 0 0 1 1 1 1 1 1 1 总结规律：\n负数 正数 0 2n-1 n n-1 1 2n-2 n-1 n 3 2n-4 n-3 n+2 …… …… 可发现若n为奇数时\n总可以把负数全部变为正数\n当n为偶数时\n每次能改变偶数个负数\n所以若负数的个数为偶数个\n也能全部变为正数\n当负数的个数为奇数个 总会留下一个数为负数\n(但不一定是原来就有的负数)\n为了让总和最大\n可以使绝对值最小的数为负数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include\u0026lt;stdio.h\u0026gt; int main() { int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); int l=2*n-1; int sum=0,cnt=0,res=99999999; for(int i=0; i\u0026lt;l; i++) { int t; scanf(\u0026#34;%d\u0026#34;,\u0026amp;t); if(t\u0026lt;0) { cnt++; t=-t; } if(res\u0026gt;t) res=t; sum+=t; } if(n\u0026amp;1||cnt%2==0) printf(\u0026#34;%d\\n\u0026#34;,sum); else printf(\u0026#34;%d\\n\u0026#34;,sum-2*res); } return 0; } 题目地址:【郑轻】[1899]985的最大和难题\n","date":"2016-08-03T20:00:54+08:00","permalink":"https://boiltask.com/oj/zzuli/1899/","title":"【郑轻】[1899]985的最大和难题"},{"content":"问题描述 985的买饮料难题\r时间限制：1 Sec内存限制：128 MB\rDescription 天气太热了，985制定了对未来的规划即第i天喝a[i]瓶饮料。为了节约开支，他打听到了第i天每瓶饮料的价格p[i]。\n为了不让自己的规划落空，他想知道这n天他至少要花多少钱。\n精明的985可以选择在任意一天买数目不限的饮料，而且他有一个神奇的冰箱，可以将提前购买的饮料保存下来（至少在这n天里是可以饮用的）。\nInput 第一行输入一个整数t，代表有t组测试数据。\n每组数据第一行输入一个整数n代表规划的总天数，接下来有n行，每行输入两个整数a[]，p[]分别代表上面提到的信息。\n注：1 \u0026lt;= t \u0026lt;= 30，1 \u0026lt;= n \u0026lt;= 1000，1 \u0026lt;= a[]，p[] \u0026lt;= 100。\nOutput 输出一个整数代表最后的结果。\nSample Input 1 2 3 4 5 6 7 8 9 10 2 2 25 56 94 17 5 39 21 95 89 73 90 9 55 85 32 Sample Output 1 2 2998 6321 问题分析 是第i天购买的最优单价是min(p[j]) （1 \u0026lt;= j \u0026lt;= i）\n所以统计一遍即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;algorithm\u0026gt; int a[1200],p[1200]; int main() { int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a[i],\u0026amp;p[i]); int res=0; for(int i=n-1; i\u0026gt;=0; i--) { int max=p[0]; for(int j=1; j\u0026lt;=i; j++) { if(max\u0026gt;p[j]) max=p[j]; } res+=max*a[i]; } printf(\u0026#34;%d\\n\u0026#34;,res); } return 0; } 题目地址: 【郑轻】[1896]985的买饮料难题\n","date":"2016-08-03T19:47:40+08:00","permalink":"https://boiltask.com/oj/zzuli/1896/","title":"【郑轻】[1896]985的买饮料难题"},{"content":"问题描述 985的方格难题\r时间限制：1 Sec内存限制：128 MB\rDescription 985走入了一个n * n的方格地图，他已经知道其中有一个格子是坏的。现在他要从(1, 1)走到(n, n)，每次只可以向下或者向右走一步，问他能否到达（n，n）。若不能到达输出-1，反之输出到达（n，n）的方案数。\nInput 第一行输入一个整数t，代表有t组测试数据。\n每组数据第一行输入三个整数n，x，y，分别代表方格地图的大小以及坏掉格子的位置。\n注：1 \u0026lt;= t \u0026lt;= 20，1 \u0026lt;= n \u0026lt;= 30，1 \u0026lt;= x，y \u0026lt;= n。\nOutput 若可以到达（n，n）则输出方案数对1e9 + 7取余的结果，反之输出-1。\nSample Input 1 2 3 2 2 1 2 2 2 2 Sample Output 1 2 1 -1 问题分析 解法一：考虑dp，dp[i][j]表示到达位置（i，j）的方案数，\ndp[i][j] = -1 表明该位置未被访问，直接暴力转移就可以啦。\n时间复杂度：O(T * n * n)。\n解法二：抛开坏的位置不说，发现从（1，1）到达每个位置的方案数都是杨辉三角里面的某个组合数。\n而且达到位置(n, m)的方案数是C(n + m - 2，m - 1)。\n记ans[1][1][n][m]为（1，1）到（n，m）的方案数。\n这样结果就是ans[1][1][n][n] - ans[1][1][x][y] * ans[x][y][n][n]。防止出错，要用逆元。\n时间复杂度：O(T * log(1e9 + 5)^4)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include\u0026lt;stdio.h\u0026gt; int map[32][32]; int main() { int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { int n,x,y; scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;n,\u0026amp;x,\u0026amp;y); for(int i=1; i\u0026lt;=n; i++) { for(int j=1; j\u0026lt;=n; j++) { if(i==x\u0026amp;\u0026amp;j==y) map[i][j]=0; else { if(i==1) if(j==1) map[i][j]=1; else map[i][j]=map[i][j-1]; else if(j==1) map[i][j]=map[i-1][j]; else map[i][j]=(map[i-1][j]+map[i][j-1])%1000000007; } } } printf(\u0026#34;%d\\n\u0026#34;,map[n][n]==0?-1:map[n][n]); } return 0; } 题目地址:【郑轻】[1894]985的方格难题\n","date":"2016-08-03T19:42:27+08:00","permalink":"https://boiltask.com/oj/zzuli/1894/","title":"【郑轻】[1894]985的方格难题"},{"content":"问题描述 Highways\r[poj-2485] [3154968811769274] @vjudge\r问题分析 给出一个n*n的列表\n第i行第j列代表 i - j 的距离\n求使n个点连通的总距离最小的路中最大的距离\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; struct edge { int u,v,dis; } e[520*520]; int par[520]; int ran[520]; int find(int m) { if(m==par[m]) return m; else return par[m]=find(par[m]); } void unite(int x,int y) { x=find(x); y=find(y); if(x==y) return; if(ran[x]\u0026lt;ran[y]) par[x]=y; else { par[y]=x; if(ran[x]==ran[y]) ran[x]++; } } bool cmp(edge A,edge B) { return A.dis\u0026lt;B.dis; } int main() { int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { int N; scanf(\u0026#34;%d\u0026#34;,\u0026amp;N); for(int i=1; i\u0026lt;=N; i++) { par[i]=i; ran[i]=0; } int cnt=0; for(int i=1; i\u0026lt;=N; i++) { for(int j=1; j\u0026lt;=N; j++) { scanf(\u0026#34;%d\u0026#34;,\u0026amp;e[cnt].dis); e[cnt].u=i; e[cnt++].v=j; } } sort(e,e+cnt,cmp); int res=0; for(int i=0; i\u0026lt;cnt; i++) { if(find(e[i].u)!=find(e[i].v)) { if(res\u0026lt;e[i].dis) res=e[i].dis; unite(e[i].u,e[i].v); } } printf(\u0026#34;%d\\n\u0026#34;,res); } } ","date":"2016-08-03T11:48:35+08:00","permalink":"https://boiltask.com/oj/poj/2485/","title":"【POJ】[2485]Highways"},{"content":"问题描述 Computer\r[hdu-2196] [3153444422576675] @vjudge\r问题分析 求树中所有点的最远距离\n先找任意点的最远点u，在找u的最远点v，在这个过程中记录u到每个点的距离dis[0][i]，再以v为起点寻找最远点，记录v到每个点的距离dis[1][i]，则各个点的最远距离为max(dis[0][i],dis[1][i])\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; int n,m; int t,max; int dis[2][10200]; int head[10200]; int headcnt; struct List { int u,v,w; int next; } edge[20200]; int f(int a,int b) { return a\u0026gt;b?a:b; } void dfs(int u,int v,int w,int flag) { if(max\u0026lt;w) max=w,t=u; dis[flag][u]=w; for(int i=head[u]; i!=-1; i=edge[i].next) { if(edge[i].v!=v) { dfs(edge[i].v,u,w+edge[i].w,flag); } } } void add(int u,int v,int w) { edge[headcnt].u=u; edge[headcnt].v=v; edge[headcnt].w=w; edge[headcnt].next=head[u]; head[u]=headcnt++; } int main() { while(scanf(\u0026#34;%d\u0026#34;,\u0026amp;n)!=EOF) { headcnt=0; memset(head,-1,sizeof(head)); for(int i=2; i\u0026lt;=n; i++) { int v,w; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;v,\u0026amp;w); add(i,v,w); add(v,i,w); } max=0; dfs(1,0,0,0); max=0; dfs(t,0,0,0); dfs(t,0,0,1); for(int i=1; i\u0026lt;=n; i++) { printf(\u0026#34;%d\\n\u0026#34;,f(dis[0][i],dis[1][i])); } } return 0; } ","date":"2016-08-03T10:30:02+08:00","permalink":"https://boiltask.com/oj/hdu/2196/","title":"【杭电】[2196]Computer"},{"content":"问题描述 Labyrinth\r[hdu-1383] [3225955975161902] @vjudge\r问题分析 依照树的直径的思路\n先找出任意一点的最远点u，再找出u的最远点v，u-v距离即使最远距离，这题同样按照这种思路进行搜索\n不过虽然题目说容易栈溢出，但是提交时也没有这种错误情况\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; int max,tn,tm; int W,H; int flag[1200][1200]; char map[1200][1200]; int tmove[4]= {1,-1,0,0}; void dfs(int n,int m,int cnt) { if(max\u0026lt;cnt) { max=cnt,tn=n,tm=m; } for(int i=0; i\u0026lt;4; i++) { int moven=n+tmove[i],movem=m+tmove[(i+2)%4]; if(moven\u0026gt;=0\u0026amp;\u0026amp;moven\u0026lt;H\u0026amp;\u0026amp;movem\u0026gt;=0\u0026amp;\u0026amp;movem\u0026lt;W\u0026amp;\u0026amp;map[moven][movem]==\u0026#39;.\u0026#39;\u0026amp;\u0026amp;!flag[moven][movem]) { flag[moven][movem]=1; dfs(moven,movem,cnt+1); } } } int main() { int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;W,\u0026amp;H); getchar(); for(int i=0; i\u0026lt;H; i++) { for(int j=0; j\u0026lt;W; j++) { scanf(\u0026#34;%c\u0026#34;,\u0026amp;map[i][j]); if(map[i][j]==\u0026#39;.\u0026#39;) { tn=i; tm=j; } } getchar(); } max=0; memset(flag,0,sizeof(flag)); flag[tn][tm]=1; dfs(tn,tm,0); memset(flag,0,sizeof(flag)); flag[tn][tm]=1; dfs(tn,tm,0); printf(\u0026#34;Maximum rope length is %d.\\n\u0026#34;,max); } return 0; } ","date":"2016-08-03T09:39:09+08:00","permalink":"https://boiltask.com/oj/hdu/1383/","title":"【POJ】[1383]Labyrinth"},{"content":"问题描述 Roads in the North\r[poj-2631] [3153072516177712] @vjudge\r问题分析 运用DFS求树的直径\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; int head[10200]; int headcnt; int max,t; struct List { int u,v,w; int next; } edge[10200]; void add(int u,int v,int w) { edge[headcnt].u=u; edge[headcnt].v=v; edge[headcnt].w=w; edge[headcnt].next=head[u]; head[u]=headcnt++; } void dfs(int u,int v,int w) { if(max\u0026lt;w) max=w,t=u; for(int i=head[u]; i!=-1; i=edge[i].next) { if(edge[i].v!=v) dfs(edge[i].v,u,w+edge[i].w); } } int main() { headcnt=0; memset(head,-1,sizeof(head)); int u,v,w; while(scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;u,\u0026amp;v,\u0026amp;w)!=EOF) { add(u,v,w); add(v,u,w); } max=0; dfs(1,0,0); dfs(t,0,0); printf(\u0026#34;%d\\n\u0026#34;,max); return 0; } ","date":"2016-08-03T08:59:06+08:00","permalink":"https://boiltask.com/oj/poj/2631/","title":"【POJ】[2631]Roads in the North"},{"content":"问题描述 棋盘问题\r[poj-1321] [3166263531764621] @vjudge\r问题分析 不算太难的搜索题\n但是心里一慌就容易乱\n而且就被别人代码干扰没自己思路了\n搜索还是采取看有几个能达到$n==k$\n所以设置好搜索条件即可 详细看代码注释\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include\u0026lt;stdio.h\u0026gt; char map[10][10]; bool flag[12]; int n,k; int cnt; void dfs(int m,int x) { if(m==k) { cnt++; return; //有一种方案达到了k个棋子 } if(x==n) return ; //到达边界而退出 for(int i=0; i\u0026lt;n; i++) { //在当前行尝试各个列能否放棋子 if(map[x][i]==\u0026#39;#\u0026#39;\u0026amp;\u0026amp;!flag[i]) { flag[i]=true; dfs(m+1,x+1); flag[i]=false; } } dfs(m,x+1); // 与八皇后问题不同的一点 // 因为当前行也许可以不放棋子 // 所以跳过这一行搜索下一行 } int main() { while(scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;k),n!=-1||n!=-1) { getchar(); for(int i=0; i\u0026lt;n; i++) { flag[i]=false; for(int j=0; j\u0026lt;n; j++) { scanf(\u0026#34;%c\u0026#34;,\u0026amp;map[i][j]); } getchar(); } cnt=0; dfs(0,0);//从第0行0个棋子开始搜索 printf(\u0026#34;%d\\n\u0026#34;,cnt); } return 0; } ","date":"2016-08-03T08:52:17+08:00","permalink":"https://boiltask.com/oj/poj/1321/","title":"【POJ】[1321]棋盘问题"},{"content":"问题描述 Cow Marathon\r[poj-1985] [3149017016675183] @vjudge\r问题分析 给一个树，让寻找树中两点的最大距离\n也就是求树的直径\n思路：找出任意一点的最远点u，在找出u的最远点v，则n-v的距离即是最大距离。\n可以运用DFS||BFS来进行搜索\n因为时间类似而DFS比较简洁\n所以这里运用DFS\n储存树使用了邻接表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; int n,m; int t,res; int head[100200]; int headcnt; struct List { int u,v,w; int next; } edge[100200]; void dfs(int u,int v,int w) { if(w\u0026gt;res) { res=w; t=u; } for(int i=head[u]; i!=-1; i=edge[i].next) { if(edge[i].v!=v) { dfs(edge[i].v,u,w+edge[i].w); } } } void add(int u,int v,int w) { edge[headcnt].u=u; edge[headcnt].v=v; edge[headcnt].w=w; edge[headcnt].next=head[u]; head[u]=headcnt++; } int main() { while(scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m)!=EOF) { headcnt=0; memset(head,-1,sizeof(head)); while(m--) { int u,v,w; scanf(\u0026#34;%d %d %d %*c\u0026#34;,\u0026amp;u,\u0026amp;v,\u0026amp;w); add(u,v,w); add(v,u,w); } res=0; dfs(1,0,0); dfs(t,0,0); printf(\u0026#34;%d\\n\u0026#34;,res); } return 0; } ","date":"2016-08-02T17:51:52+08:00","permalink":"https://boiltask.com/oj/poj/1985/","title":"【POJ】[1985]Cow Marathon"},{"content":" 邻接表是图论中常用的一种数据结构。\n如何构建邻接表【模板】【邻接表与邻接矩阵的选择】\n邻接表与邻接矩阵有相似的作用：用于储存一个图中所有的节点，但是邻接矩阵比较浪费内存，当数据较小时，邻接矩阵还可以计算\n但是一旦数据较大，用邻接矩阵往往就会超时或者超内存，这时就要使用邻接表来存图了；为方便理解邻接矩阵与邻接表的储存方式。\n我们先规定一组数据\n1 10 3 5 8 9\n我们将所给的点标记为1，其余为0 （1）邻接矩阵（适合小数据点稠密型图）\n/ 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 我们可以看到虽然只有三个点我们却不得不开一个10x10的二维数组来存放数据这极大的浪费了空间\n当遍历图时如果数据过大还可能会超时；那么邻接表呢？\n（2）邻接表：（适合大数据点稀疏型图）\n还是以上三个点\nV1————\u0026gt;V10\nV3————\u0026gt;V5\nV8————\u0026gt;V9\n只需要一个链即可完成 大大的节省了内存 ;详情如下图：\n下边附上构建邻接表的通用模板：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; int n,m; int head[10010];//表头，head[i]代表起点是i的边的编号 int headcnt;//代表边的总编号 struct List { int u,v,w;//分别为边的起边、终点、权值 int next;//代表调用时下一条边的编号 //也就是当前边的上一条边的编号 } edge[10010];//结构体记录边 void add(int u,int v,int w) { edge[headcnt].u=u; edge[headcnt].v=v; edge[headcnt].w=w; //把u、v、w、存入边的信息中 edge[headcnt].next=head[u]; //把这条边的上一条(调用时的下一条边)存入信息 head[u]=headcnt++; //记录这条以u为顶点的边的编号 //并使总编号+1 } int main() { while(scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m)!=EOF) { headcnt=0; memset(head,-1,sizeof(head)); while(m--) { int u,v,w; scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;u,\u0026amp;v,\u0026amp;w); add(u,v,w);//读取u、v、w存入表中 } int t; scanf(\u0026#34;%d\u0026#34;,\u0026amp;t); //找到以t为顶点的最大编号边并一直向前寻找 //直到当前边之前无边 for(int i=head[t]; i!=-1; i=edge[i].next) { printf(\u0026#34;%d %d\\n\u0026#34;,edge[i].v,edge[i].w); } } return 0; } 参考文章:如何构建邻接表【模板】【邻接表与邻接矩阵的选择】\n","date":"2016-08-02T16:51:35+08:00","permalink":"https://boiltask.com/knowledge/adjacency-list/","title":"邻接表的创建与使用"},{"content":"问题描述 Karate Competition\r[lightoj-1198] [3128193304390688] @vjudge\r问题分析 与田忌赛马的贪心策略类似\n不过因为输了不扣分平局加一分\n所以对平局的优先级需要提升一些\n【杭电】[1052]Tian Ji — The Horse Racing\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; int a[55],b[55]; int main() { int T,kase=0; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;b[i]); sort(a,a+n); sort(b,b+n); int cnt=0; int al=0,ar=n-1,bl=0,br=n-1; for(int i=0; i\u0026lt;n; i++) { if(a[ar]\u0026gt;b[br]) { ar--,br--; cnt+=2; } else if(a[ar]\u0026lt;b[br]) { al++,br--; } else if(a[al]\u0026gt;b[bl]) { al++,bl++; cnt+=2; } else { if(a[al]==b[br]) cnt++; al++,br--; } } printf(\u0026#34;Case %d: %d\\n\u0026#34;,++kase,cnt); } return 0; } ","date":"2016-08-02T09:23:40+08:00","permalink":"https://boiltask.com/oj/lightoj/1198/","title":"【LightOJ】[1198]Karate Competition"},{"content":"问题描述 青蛙的约会\r[poj-1061] [3158014367453028] @vjudge\r问题分析 很容易想到与扩展欧几里德有关\n由题意可得到\n$$\\begin{align*} \u0026 \\left( x+m\\cdot t\\right) -\\left( y+n\\cdot t\\right) =k\\cdot L\\\\ \u0026 \\Rightarrow \\\\ \u0026 \\left( m-n\\right) t-k\\cdot L=y-x\\end{align*}$$把它化成\t$a\\cdot x+b\\cdot y=gcd\\left( a,b\\right)$\n则\n$$\\begin{cases} a=m-n \\\\ b=-L\\\\ x=t \\\\ y=k \\end{cases}$$ 所以可判断(y-x)是否能整除gcd(m-n,-L)\n因为L必然大于0\n所以把公式写为\t$\\left( n-m\\right) t+k\\cdot L=x-y$\n用扩展欧几里德算法求出x y\n剩下可求出了t\n然后考虑t\u0026lt;0的情况\n引用一段题解\n定理一：如果d =gcd(a, b)，则必能找到正的或负的整数k和l，使d = ax+ by。\n定理二：若gcd(a,b) = 1，则方程ax ≡ c (mod b)在[0, b-1]上有唯一解。\n定理三：若gcd(a,b) = d，则方程ax ≡ c (mod b)在[0, b/d - 1]上有唯一解。\n证明：上述同余方程等价于ax + by = c，如果有解，两边同除以d，就有a/d * x + b/d * y = c/d，即a/d * x ≡ c/d (modb/d)，显然gcd(a/d, b/d) = 1，所以由定理二知道x在[0, b/d - 1]上有唯一解。所以ax + by = c的x在[0, b/d - 1]上有唯一解，即ax ≡ c (mod b)在[0, b/d - 1]上有唯一解。\n如果得到ax ≡ c (mod b)的某一特解X，那么令r = b/gcd(a, b)，可知x在[0, r-1]上有唯一解，所以用x = (x% r + r) % r就可以求出最小非负整数解x了！（X % r可能是负值，此时保持在[-(r-1), 0]内，正值则保持在[0, r-1]内。加上r就保持在[1, 2r - 1]内，所以再模一下r就在[0, r-1]内了）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include\u0026lt;stdio.h\u0026gt; long long exgcd(long long a,long long b,long long \u0026amp;x,long long \u0026amp;y) { if(b==0) { x=1,y=0; return a; } long long d=exgcd(b,a%b,y,x); y-=x*(a/b); return d; } int main() { long long x,y,m,n,L; while(scanf(\u0026#34;%lld %lld %lld %lld %lld\u0026#34;,\u0026amp;x,\u0026amp;y,\u0026amp;m,\u0026amp;n,\u0026amp;L)!=EOF) { long long t1,t2; long long d=exgcd(n-m,L,t1,t2); if((y-x)%d!=0) printf(\u0026#34;Impossible\\n\u0026#34;); else { t1=t1*((x-y)/d); long long r=L/d; t1=(t1%r+r)%r; printf(\u0026#34;%lld\\n\u0026#34;,t1); } } return 0; } 推荐文章:POJ 1061 青蛙的约会 - w446506278的博客\n","date":"2016-08-01T23:48:55+08:00","permalink":"https://boiltask.com/oj/poj/1061/","title":"【POJ】[1061]青蛙的约会"},{"content":"问题描述 domino\r[hdu-5777] [3260602101437425] @vjudge\r问题分析 中文题意：\n小白在玩一个游戏。桌子上有n张多米诺骨牌排成一列。它有k次机会，每次可以选一个还没有倒的骨牌，向左或者向右推倒。每个骨牌倒下的时候，若碰到了未倒下的骨牌，可以把它推倒。小白现在可以随意设置骨牌的高度，但是骨牌高度为整数，且至少为1，并且小白希望在能够推倒所有骨牌的前提下，使所有骨牌高度的和最小。\n官方题解：\n首先骨牌只要考虑都往右推，其次能带倒骨牌的前提是高度大于等于距离+1。\n所以如果推一次，那么就是骨牌高度=离下一块骨牌距离+1. 把第一块左边距离设为无穷大，能推nk次，那么就是找nk块左边距离最大的向右推倒即可，所以只需要排序找到前nk-1大的距离。\n有个小trick，推的次数可能大于骨牌数量 复杂度 O（nlogn）\n由题意可知需要尽量使距离大的浪费掉\n所以把累加（距离+1）再尽量减去最大距离\n就可以取得最小高度\nPS：注意数据范围 int 存不下sum\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; bool cmp(int a,int b) { return a\u0026gt;b; } __int64 a[100200]; int main() { int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { int n,k; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;k); n--; __int64 sum=0; for(int i=0; i\u0026lt;n; i++) { scanf(\u0026#34;%I64d\u0026#34;,\u0026amp;a[i]); sum+=a[i]+1; } sum++; sort(a,a+n,cmp); for(int i=0; i\u0026lt;k-1\u0026amp;\u0026amp;i\u0026lt;n; i++) sum=sum-a[i]; printf(\u0026#34;%I64d\\n\u0026#34;,sum); } return 0; } ","date":"2016-08-01T18:04:37+08:00","permalink":"https://boiltask.com/oj/hdu/5777/","title":"【杭电】[5777]domino"},{"content":"问题描述 sum\r[hdu-5776] [3260613266726679] @vjudge\r问题分析 中文题意：\n给定一个数列，求是否存在连续子列和为m的倍数，存在输出YES，否则输出NO\n官方题解：\n预处理前缀和，一旦有两个数模m的值相同，说明中间一部分连续子列可以组成m的倍数。 另外，利用抽屉原理，我们可以得到，一旦n大于等于m，答案一定是YES 复杂度 O（n）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; int flag[10000]; int main() { int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { int n,m; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m); memset(flag,0,sizeof(flag)); flag[0]=1; bool win=false; int sum=0; for(int i=0; i\u0026lt;n; i++) { int t; scanf(\u0026#34;%d\u0026#34;,\u0026amp;t); sum=(sum+t)%m; if(flag[sum]==1) win=true; flag[sum]=1; } if(win) printf(\u0026#34;YES\\n\u0026#34;); else printf(\u0026#34;NO\\n\u0026#34;); } return 0; } ","date":"2016-08-01T18:02:05+08:00","permalink":"https://boiltask.com/oj/hdu/5776/","title":"【杭电】[5776]sum"},{"content":"问题描述 Work\r[hdu-5326] [3291376764281254] @vjudge\r问题分析 寻找父节点时则把父节点的层数加1\n这样ran数组中便可保存其下面有多少人\n最后查找ran[i]==k的个数即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include\u0026lt;stdio.h\u0026gt; int par[120],ran[120]; void find(int m) { if(m!=par[m]) { ran[par[m]]++; find(par[m]); } } void unite(int x,int y) { if(x!=y) par[y]=x; } int main() { int n,k; while(scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;k)!=EOF) { for(int i=1; i\u0026lt;=n; i++) { ran[i]=0; par[i]=i; } for(int i=1; i\u0026lt;n; i++) { int a,b; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a,\u0026amp;b); unite(a,b); } for(int i=1; i\u0026lt;=n; i++) find(i); int res=0; for(int i=1; i\u0026lt;=n; i++) { if(ran[i]==k) res++; } printf(\u0026#34;%d\\n\u0026#34;,res); } return 0; } ","date":"2016-08-01T17:59:19+08:00","permalink":"https://boiltask.com/oj/hdu/5326/","title":"【杭电】[5326]Work"},{"content":"问题描述 Pet\r[hdu-4707] [3174814046439670] @vjudge\r问题分析 这一题感觉并查集不是很好\n代码似乎很容易出BUG\n不过题目数据好像给的不是很严(还是很多的)\n直接暴力深搜也会超时\n如果dfs的话也需要先建树\n用带权并查集的话主要是要注意\n不能把0的父节点设为其它点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include\u0026lt;stdio.h\u0026gt; int par[100200],ran[100200]; int find(int m) { if(m==par[m]) return m; else { ran[m]+=ran[par[m]]; return par[m]=find(par[m]); } } void unite(int x,int y) { if(x\u0026gt;y) { int t=x; x=y; y=t; } int a=find(x); int b=find(y); if(x==y) return ; else { par[b]=a; ran[b]=ran[x]-ran[y]+1; } } int main() { int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { int n,d; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;d); for(int i=0; i\u0026lt;n; i++) { ran[i]=0; par[i]=i; } for(int i=1; i\u0026lt;n; i++) { int a,b; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a,\u0026amp;b); unite(a,b); } int res=0; for(int i=0; i\u0026lt;n; i++) { if(find(i)==0\u0026amp;\u0026amp;ran[i]\u0026gt;d) res++; } printf(\u0026#34;%d\\n\u0026#34;,res); } return 0; } 参考博客:hdu 4707 Pet【带权并查集】 – mengxiang000000\n","date":"2016-08-01T17:56:59+08:00","permalink":"https://boiltask.com/oj/hdu/4707/","title":"【杭电】[4707]Pet"},{"content":"问题描述 How Many Tables\r[hdu-1213] [3107206738359983] @vjudge\r问题分析 基础并查集题目\n合并同关系的\n然后查找共有多少顶点(i==find(i))\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include\u0026lt;stdio.h\u0026gt; int par[1200]; int find(int m) { if(m==par[m]) return m; else return par[m]=find(par[m]); } void unite(int x,int y) { x=find(x); y=find(y); if(x==y) return ; else par[y]=x; } int main() { int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { int n,m; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m); for(int i=1; i\u0026lt;=n; i++) par[i]=i; while(m--) { int a,b; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a,\u0026amp;b); unite(a,b); } int res=0; for(int i=1; i\u0026lt;=n; i++) if(i==find(i)) res++; printf(\u0026#34;%d\\n\u0026#34;,res); } return 0; } ","date":"2016-08-01T17:31:22+08:00","permalink":"https://boiltask.com/oj/hdu/1213/","title":"【杭电】[1213]How Many Tables"},{"content":"问题描述 Ice_cream\u0026#39;s world I\r[hdu-2120] [3097640482522631] @vjudge\r问题分析 其实也就是找出成环个数\n已经在同一集合中的又进行合并\nfind(x)==find(y)\n则形成一个环 res++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include\u0026lt;stdio.h\u0026gt; int par[1200]; int res; int find(int m) { if(m==par[m]) return m; else return par[m]=find(par[m]); } void unite(int x,int y) { x=find(x); y=find(y); if(x==y) res++; else { par[y]=x; } } int main() { int n,m; while(scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m)!=EOF) { for(int i=0; i\u0026lt;n; i++) { par[i]=i; } res=0; while(m--) { int a,b; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a,\u0026amp;b); unite(a,b); } printf(\u0026#34;%d\\n\u0026#34;,res); } return 0; } ","date":"2016-08-01T16:31:04+08:00","permalink":"https://boiltask.com/oj/hdu/2120/","title":"【杭电】[2120]Ice_cream's world I"},{"content":"问题描述 More is better\r[hdu-1856] [3158601350563004] @vjudge\r问题分析 要求集合中的元素的最大值\n这里可以借助ran数组储存树的高度\n(详见并查集防树形退化讲解)\n在合并的时候可以对最大高度进行记录\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include\u0026lt;stdio.h\u0026gt; int par[10000020],ran[10000020]; int res; int find(int m) { if(m==par[m]) return m; else return par[m]=find(par[m]); } void unite(int x,int y) { x=find(x); y=find(y); if(x==y) return ; else { if(ran[x]\u0026lt;ran[y]) { par[x]=y; ran[y]+=ran[x]; if(ran[y]\u0026gt;res) res=ran[y]; } else { par[y]=x; ran[x]+=ran[y]; if(ran[x]\u0026gt;res) res=ran[x]; } } } int main() { int n; while(scanf(\u0026#34;%d\u0026#34;,\u0026amp;n)!=EOF) { for(int i=1; i\u0026lt;=10000000; i++) { ran[i]=1; par[i]=i; } res=1; for(int i=0; i\u0026lt;n; i++) { int a,b; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a,\u0026amp;b); unite(a,b); } printf(\u0026#34;%d\\n\u0026#34;,res); } return 0; } ","date":"2016-08-01T16:13:36+08:00","permalink":"https://boiltask.com/oj/hdu/1856/","title":"【杭电】[1856]More is better"},{"content":"问题描述 Rikka with Graph\r[hdu-5631] [3241978769555317] @vjudge\r问题分析 给了n点，n+1条边，问存在多少个方案使图去掉几条边后，仍能连通。\n由连通图性质知，n个点至少要有n-1条边才能连通\n因为数据范围较小\n所以尝试采取枚举法看去掉某一条或某两条边后图是否连通\n判断图是否连通可用并查集\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include\u0026lt;stdio.h\u0026gt; int par[120]; struct node { int n,m; } a[120]; int find(int m) { if(m==par[m]) return m; else return par[m]=find(par[m]); } void unite(int x,int y) { x=find(x); y=find(y); if(x==y) return ; else par[y]=x; } int main() { int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i=0; i\u0026lt;n+1; i++) { scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a[i].n,\u0026amp;a[i].m); } int res=0; for(int i=0; i\u0026lt;n+1; i++) { for(int j=i; j\u0026lt;n+1; j++) { for(int k=1; k\u0026lt;=n; k++) par[k]=k; for(int k=0; k\u0026lt;n+1; k++) { if(k==i||k==j) continue; unite(a[k].n,a[k].m); } int k; for(k=1; k\u0026lt;n; k++) { if(find(n)!=find(k)) break; } if(k==n) res++; } } printf(\u0026#34;%d\\n\u0026#34;,res); } return 0; } ","date":"2016-08-01T15:55:39+08:00","permalink":"https://boiltask.com/oj/hdu/5631/","title":"【杭电】[5631]Rikka with Graph"},{"content":"问题描述 Fire!\r[uva-11624] [3106306097285719] @vjudge\r问题分析 题目：一个平面迷宫中有一个人，迷宫中有些点起火了，火和人每个单位时间只能向相邻的格子移动，其中有一些空间被墙壁占据，问这个人在不背或烧到的情况下，离开迷宫的最快时间。\n分析：搜索。迷宫中的最短路，首先就会想到bfs；并且bfs利用队列会使状态空间按时间顺序分层。\n而火的扩散过程正好符合这个时间的层次。所以我们会想到，利用两个队列，一个储存人的状态，一个储存火的状态。按照时间顺序，先更新火蔓延的节点，再扩展人能到达的节点。\n通过分析，我们发现这两个队列可以合并，只须初始化的时候，按照火节点然后是人的顺序入队即可。\n（节点中加入一个是否是火节点的判断，就可以两种节点按不同的细节处理）\n本段分析参考博客：UVa 11624 - Fire! - 小白菜又菜\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;queue\u0026gt; using namespace std; char map[1200][1200]; int cnt[1200][1200]; int tmove[4]= {1,-1,0,0}; int inf=99999999; struct node { int n,m; } a[1020*1020]; int x; int H,W; int bfs(int n,int m) { queue\u0026lt;node\u0026gt;q; node t; for(int i=0; i\u0026lt;x; i++) { t.n=a[i].n,t.m=a[i].m; q.push(t); } t.n=n,t.m=m; q.push(t); while(!q.empty()) { t=q.front(); if(map[t.n][t.m]==\u0026#39;F\u0026#39;) { for(int i=0; i\u0026lt;4; i++) { int tn=t.n+tmove[i],tm=t.m+tmove[(i+2)%4]; if(tn\u0026gt;=0\u0026amp;\u0026amp;tn\u0026lt;H\u0026amp;\u0026amp;tm\u0026gt;=0\u0026amp;\u0026amp;tm\u0026lt;W\u0026amp;\u0026amp;map[tn][tm]==\u0026#39;.\u0026#39;) { map[tn][tm]=\u0026#39;F\u0026#39;; node temp; temp.n=tn,temp.m=tm; q.push(temp); } } } else { for(int i=0; i\u0026lt;4; i++) { int tn=t.n+tmove[i],tm=t.m+tmove[(i+2)%4]; if(tn\u0026lt;0||tn\u0026gt;=H||tm\u0026lt;0||tm\u0026gt;=W) return cnt[t.n][t.m]; else if(map[tn][tm]==\u0026#39;.\u0026#39;\u0026amp;\u0026amp;cnt[tn][tm]==inf) { map[tn][tm]=\u0026#39;J\u0026#39;; cnt[tn][tm]=cnt[t.n][t.m]+1; node temp; temp.n=tn,temp.m=tm; q.push(temp); } } } q.pop(); } return -1; } int main() { int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;H,\u0026amp;W); getchar(); int mH,mW; x=0; for(int i=0; i\u0026lt;H; i++) { for(int j=0; j\u0026lt;W; j++) { cnt[i][j]=inf; map[i][j]=getchar(); if(map[i][j]==\u0026#39;F\u0026#39;) a[x].n=i,a[x++].m=j; else if(map[i][j]==\u0026#39;J\u0026#39;) mH=i,mW=j; } getchar(); } cnt[mH][mW]=1; int res=bfs(mH,mW); if(res==-1) printf(\u0026#34;IMPOSSIBLE\\n\u0026#34;); else printf(\u0026#34;%d\\n\u0026#34;,res); } return 0; } 题目地址：Puzzle - UVA 227 - Virtual Judge\n","date":"2016-07-30T11:03:55+08:00","permalink":"https://boiltask.com/oj/uva/11624/","title":"【UVa】[11624]Fire!"},{"content":"问题描述 Find a way\r[hdu-2612] [3165225470619637] @vjudge\r问题分析 找出一个KFC使两人到它的距离之和最短\n只需要把KFC坐标进行记录\n然后分别以两人为起点搜索\n取每个KFC的两人距离之和\n其中最小的那个即为结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; #include\u0026lt;queue\u0026gt; using namespace std; int inf=99999999; char map[220][220]; int cnt[2][220][220]; int flag[220][220]; int tmove[4]= {1,-1,0,0}; struct node { int n,m; } a[220]; int H,W; int Yn,Ym,Mn,Mm; int x; void bfs(int n,int m,int who) { node t; t.n=n,t.m=m; queue\u0026lt;node\u0026gt;q; flag[n][m]=1; cnt[who][n][m]=0; q.push(t); while(!q.empty()) { t=q.front(); for(int i=0; i\u0026lt;4; i++) { int tn=t.n+tmove[i],tm=t.m+tmove[(i+2)%4]; if(tn\u0026gt;=0\u0026amp;\u0026amp;tn\u0026lt;H\u0026amp;\u0026amp;tm\u0026gt;=0\u0026amp;\u0026amp;tm\u0026lt;W\u0026amp;\u0026amp;!flag[tn][tm]\u0026amp;\u0026amp;map[tn][tm]!=\u0026#39;#\u0026#39;) { flag[tn][tm]=1; if(cnt[who][tn][tm]==inf) cnt[who][tn][tm]=cnt[who][t.n][t.m]+1; else cnt[who][tn][tm]+=cnt[who][t.n][t.m]+1; node temp; temp.n=tn,temp.m=tm; q.push(temp); } } q.pop(); } } int main() { while(scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;H,\u0026amp;W)!=EOF) { getchar(); x=0; for(int i=0; i\u0026lt;H; i++) { for(int j=0; j\u0026lt;W; j++) { cnt[0][i][j]=cnt[1][i][j]=inf; map[i][j]=getchar(); if(map[i][j]==\u0026#39;@\u0026#39;) a[x].n=i,a[x++].m=j; else if(map[i][j]==\u0026#39;Y\u0026#39;) Yn=i,Ym=j; else if(map[i][j]==\u0026#39;M\u0026#39;) Mn=i,Mm=j; } getchar(); } memset(flag,0,sizeof(flag)); bfs(Yn,Ym,0); memset(flag,0,sizeof(flag)); bfs(Mn,Mm,1); int res=inf; for(int i=0; i\u0026lt;x; i++) if(res\u0026gt;cnt[0][a[i].n][a[i].m]+cnt[1][a[i].n][a[i].m]) res=cnt[0][a[i].n][a[i].m]+cnt[1][a[i].n][a[i].m]; printf(\u0026#34;%d\\n\u0026#34;,res*11); } return 0; } ","date":"2016-07-30T09:22:38+08:00","permalink":"https://boiltask.com/oj/hdu/2612/","title":"【杭电】[2612]Find a way"},{"content":"问题描述 Fliptile\r[poj-3279] [3151914198599590] @vjudge\r问题分析 比较难想的一题，但是这也是很经典的一题\n经典游戏“点亮灯泡”就是这种\n也就是按下一个开关，这盏灯及上下左右的灯会改变状态\n因为一个开关按两次是没有意义的\n所以对于每个开关只有两种状态\n按或者不按 所以这一题就是要求输出\n每一个开关按(1)或者不按(0)\n题目问是否能通过操作让所有的1变成0\n如果不能则输出IMPOSSIBLE\n如果有多种操作则输出需要按(1)的次数最少的\n如果次数相等则输出结果字典序最小的那个\n(如果有00111和11100则输出00111)\n思路：\n若枚举所有格子开或不开有$2^{n*m}$个状态\n所以在1≤M≤15,1≤N≤15的范围内肯定是要爆炸\n所以思考能否优化\n事实上，若第一行确定，则它的下一行的点法必然是确定的\n因为对第一行有影响的只有第二行它对应的灯\n所以若第一行灯没亮则第二行应该要按下开关使它点亮\n以此类推可得所有的状态\n如果最后一行在按完之后也全部点亮\n则说明这种方案是成立的\n所以可以枚举第一行的操作有$2^m$个状态\n代码：\n为了方便表示出第一行灯的操作\n可以使用二进制来表示是否操作\n1 2 3 4 0000(0) 表示 否否否否 0001(1) 表示 否否否是 0010(2) 表示 否否是否 0011(3) 表示 否否是是 以此类推即可用循环把所有操作表示出来\n共有$2^m$次循环\n对于每一个i可以进行且操作i\u0026amp;1为二进制最后一位数\n而对于判断灯亮灭则可使用异或操作\n因为我们有运算法则\n1 2 3 4 0^1==1 1^1==0 0^0==0 1^0==1 也就是异或1则改变异或0则不变\n这与灯是否被操作的情况是相同的\n得到每种状态第一行的操作后\n我们可以依次向下判断来更新答案\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; int map[20][20]; int temp[20][20]; int N,M; void Pr(int x) { for(int i=0; i\u0026lt;M; i++) { map[0][i] ^= (x\u0026gt;\u0026gt;(M-1-i))\u0026amp;1; if((x\u0026gt;\u0026gt;(M-1-i))\u0026amp;1) { if(i\u0026gt;0) map[0][i-1] ^= 1; if(i\u0026lt;M-1) map[0][i+1] ^= 1; if(N\u0026gt;1) map[1][i] ^= 1; } printf(\u0026#34;%d\u0026#34;,(x\u0026gt;\u0026gt;(M-1-i))\u0026amp;1); printf(\u0026#34;%c\u0026#34;,i==M-1?\u0026#39;\\n\u0026#39;:\u0026#39; \u0026#39;); } for(int i=1; i\u0026lt;N; i++) { for(int j=0; j\u0026lt;M; j++) { printf(\u0026#34;%d\u0026#34;,map[i-1][j]); if(map[i-1][j]==1) { map[i-1][j] ^= 1; map[i][j] ^= 1; if(j\u0026gt;0) map[i][j-1] ^= 1; if(j\u0026lt;M-1) map[i][j+1] ^= 1; if(i\u0026lt;N-1) map[i+1][j] ^= 1; } printf(\u0026#34;%c\u0026#34;,j==M-1?\u0026#39;\\n\u0026#39;:\u0026#39; \u0026#39;); } } } int main() { while(scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;N,\u0026amp;M)!=EOF) { for(int i=0; i\u0026lt;N; i++) for(int j=0; j\u0026lt;M; j++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;map[i][j]); int res=99999999,rest=-1; int T=(1\u0026lt;\u0026lt;M),max=T-1; while(T--) { memcpy(temp,map,sizeof(map)); int t=T^max; int cnt=0; for(int i=0; i\u0026lt;M; i++) { temp[0][i] ^= (t\u0026gt;\u0026gt;(M-1-i))\u0026amp;1; if((t\u0026gt;\u0026gt;(M-1-i))\u0026amp;1) { cnt++; if(i\u0026gt;0) temp[0][i-1] ^= 1; if(i\u0026lt;M-1) temp[0][i+1] ^= 1; if(N\u0026gt;1) temp[1][i] ^= 1; } } for(int i=1; i\u0026lt;N; i++) { for(int j=0; j\u0026lt;M; j++) { if(temp[i-1][j]==1) { cnt++; temp[i-1][j] ^= 1; temp[i][j] ^= 1; if(j\u0026gt;0) temp[i][j-1] ^= 1; if(j\u0026lt;M-1) temp[i][j+1] ^= 1; if(i\u0026lt;N-1) temp[i+1][j] ^= 1; } } } int i; for(i=0; i\u0026lt;M; i++) if(temp[N-1][i]==1) break; if(i==M\u0026amp;\u0026amp;cnt\u0026lt;res) res=cnt,rest=t; } if(res==99999999) printf(\u0026#34;IMPOSSIBLE\\n\u0026#34;); else Pr(rest); } return 0; } ","date":"2016-07-29T20:44:55+08:00","permalink":"https://boiltask.com/oj/poj/3279/","title":"【POJ】[3279]Fliptile"},{"content":"问题描述 Tempter of the Bone\r[hdu-1010] [3150241236417113] @vjudge\r问题分析 给出一幅地图\n问能不能在第T秒到达出口\n因为并不是找最短距离，所以需要多次递归\n而因为递归次数巨大\n所以需要进行剪枝\n比较好的剪枝思路有\n如果已经有满足条件的，则其余递归都可以停止 记录总可走\u0026rsquo;.\u0026lsquo;如果tcnt+1\u0026lt;T则肯定不行 最重要的根据曼哈顿距离（从一个点到达另外一个点的最短路径长度|x1-x2|+|y1-y2|）进行剪枝，路径长度(非最短)与最短路径的长度同奇偶,它们的差一定是偶数。所以判断当前位置到终点的曼哈顿距离与它到终点如果成立所需要的路径长度的奇偶性，如果它们的差是奇数则可以停止递归。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 #include\u0026lt;stdio.h\u0026gt; int move[4]= {1,-1,0,0}; char map[10][10]; int cnt[10][10]; int H,W,T; int sH,sW,eH,eW,se; bool win; int abs(int m) { return m\u0026gt;0?m:-m; } void dfs(int n,int m) { if(win) return ; int t=(T-cnt[n][m])-(abs(n-eH)+abs(m-eW)); if(t\u0026lt;0||t\u0026amp;1) return ; if(n==eH\u0026amp;\u0026amp;m==eW\u0026amp;\u0026amp;cnt[n][m]==T) win=true; for(int i=0; i\u0026lt;4; i++) { int tn=n+move[i],tm=m+move[(i+2)%4]; if(tn\u0026gt;=0\u0026amp;\u0026amp;tn\u0026lt;H\u0026amp;\u0026amp;tm\u0026gt;=0\u0026amp;\u0026amp;tm\u0026lt;W\u0026amp;\u0026amp;map[tn][tm]!=\u0026#39;X\u0026#39;\u0026amp;\u0026amp;cnt[tn][tm]\u0026gt;cnt[n][m]+1\u0026amp;\u0026amp;cnt[n][m]\u0026lt;T) { cnt[tn][tm]=cnt[n][m]+1; dfs(tn,tm); cnt[tn][tm]=99999999; } } } int main() { while(scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;H,\u0026amp;W,\u0026amp;T),H||W||T) { getchar(); int tcnt=0; for(int i=0; i\u0026lt;H; i++) { for(int j=0; j\u0026lt;W; j++) { cnt[i][j]=99999999; map[i][j]=getchar(); if(map[i][j]==\u0026#39;S\u0026#39;) sH=i,sW=j; else if(map[i][j]==\u0026#39;D\u0026#39;) eH=i,eW=j; else if(map[i][j]==\u0026#39;.\u0026#39;) tcnt++; } getchar(); } if(tcnt+1\u0026lt;T) { printf(\u0026#34;NO\\n\u0026#34;); continue; } se=abs(sH-eH)+abs(sW-eW); win=false; cnt[sH][sW]=0; dfs(sH,sW); printf(\u0026#34;%s\\n\u0026#34;,win?\u0026#34;YES\u0026#34;:\u0026#34;NO\u0026#34;); } return 0; } ","date":"2016-07-29T15:58:48+08:00","permalink":"https://boiltask.com/oj/hdu/1010/","title":"【杭电】[1010]Tempter of the Bone"},{"content":"问题描述 Oil Deposits\r[hdu-1241] [3165219753788416] @vjudge\r问题分析 问几块石油区域\n需要注意的是只要八个方向上有石油\n那么这片区域就视作连通的\n所以dfs进行搜索填充就好\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include\u0026lt;stdio.h\u0026gt; int move[2][8]= {{1,1,1,0,0,-1,-1,-1},{0,1,-1,1,-1,0,1,-1}}; char map[120][120]; int H,W; void dfs(int n,int m) { map[n][m]=\u0026#39;*\u0026#39;; for(int i=0; i\u0026lt;8; i++) { int tn=n+move[0][i],tm=m+move[1][i]; if(tn\u0026gt;=0\u0026amp;\u0026amp;tn\u0026lt;H\u0026amp;\u0026amp;tm\u0026gt;=0\u0026amp;\u0026amp;tm\u0026lt;W\u0026amp;\u0026amp;map[tn][tm]==\u0026#39;@\u0026#39;) dfs(tn,tm); } } int main() { while(scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;H,\u0026amp;W),H||W) { for(int i=0; i\u0026lt;H; i++) scanf(\u0026#34;%s\u0026#34;,map[i]); int cnt=0; for(int i=0; i\u0026lt;H; i++) { for(int j=0; j\u0026lt;W; j++) if(map[i][j]==\u0026#39;@\u0026#39;) { cnt++; dfs(i,j); } } printf(\u0026#34;%d\\n\u0026#34;,cnt); } return 0; } ","date":"2016-07-29T12:01:02+08:00","permalink":"https://boiltask.com/oj/hdu/1241/","title":"【杭电】[1241]Oil Deposits"},{"content":"问题描述 Avoid The Lakes\r[poj-3620] [3154647556732040] @vjudge\r问题分析 注意横纵坐标的对应关系\n注意给的坐标是以1n而不是0n-1\n每次查找后把当前位置填充防止重复查找\n取查找的最大值为结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; int map[120][120]; int move[6]= {1,-1,0,0}; int W,H,cnt; void dfs(int n,int m) { cnt++; map[n][m]=0; for(int i=0; i\u0026lt;4; i++) { int tn=n+move[i],tm=m+move[(i+2)%4]; if(tn\u0026gt;0\u0026amp;\u0026amp;tn\u0026lt;=H\u0026amp;\u0026amp;tm\u0026gt;0\u0026amp;\u0026amp;tm\u0026lt;=W\u0026amp;\u0026amp;map[tn][tm]==1) dfs(tn,tm); } return ; } int main() { int T; while(scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;H,\u0026amp;W,\u0026amp;T)!=EOF) { memset(map,0,sizeof(map)); while(T--) { int n,m; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m); map[n][m]=1; } int res=0; for(int i=1; i\u0026lt;=H; i++) for(int j=1; j\u0026lt;=W; j++) { if(map[i][j]==0) continue; cnt=0; dfs(i,j); if(res\u0026lt;cnt) res=cnt; } printf(\u0026#34;%d\\n\u0026#34;,res); } return 0; } ","date":"2016-07-29T11:34:29+08:00","permalink":"https://boiltask.com/oj/poj/3620/","title":"【POJ】[3620]Avoid The Lakes"},{"content":"问题描述 Red and Black\r[hdu-1312] [3164656529174567] @vjudge\r问题分析 感觉做过好多遍的题都没贴-.-\n最简单的DFS迷宫搜索问题\n递归查找能走的路径\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include\u0026lt;stdio.h\u0026gt; char map[22][22]; int move[6]= {1,-1,0,0}; int W,H,cnt; void dfs(int n,int m) { cnt++; map[n][m]=\u0026#39;#\u0026#39;; for(int i=0; i\u0026lt;4; i++) { int tn=n+move[i],tm=m+move[(i+2)%4]; if(tn\u0026gt;=0\u0026amp;\u0026amp;tn\u0026lt;H\u0026amp;\u0026amp;tm\u0026gt;=0\u0026amp;\u0026amp;tm\u0026lt;W\u0026amp;\u0026amp;map[tn][tm]!=\u0026#39;#\u0026#39;) dfs(tn,tm); } return ; } int main() { while(scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;W,\u0026amp;H),W\u0026amp;\u0026amp;H) { getchar(); int mH,mW; for(int i=0; i\u0026lt;H; i++) { for(int j=0; j\u0026lt;W; j++) { map[i][j]=getchar(); if(map[i][j]==\u0026#39;@\u0026#39;) mH=i,mW=j; } getchar(); } cnt=0; dfs(mH,mW); printf(\u0026#34;%d\\n\u0026#34;,cnt); } return 0; } ","date":"2016-07-29T10:51:50+08:00","permalink":"https://boiltask.com/oj/hdu/1312/","title":"【杭电】[1312]Red and Black"},{"content":"问题描述 Dungeon Master\r[poj-2251] [3166266673304024] @vjudge\r问题分析 三维BFS，不算难题\n这一题数据给的非常严\nDFS必然超时 (不是很喜欢POJ这样子-.-)\n注意标记已遍历要放在push前\n否则也会把一个点加入队列多次\n导致内存超限或者时间超限\n-.-就是这么严\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include\u0026lt;cstdio\u0026gt; #include\u0026lt;queue\u0026gt; using namespace std; int movet[6]= {0,0,0,0,1,-1}; char map[32][32][32]; bool flag[32][32][32]; struct node { int l,r,c,cnt; } t,temp; int L,R,C; int sl,sr,sc; int el,er,ec; int bfs() { queue\u0026lt;node\u0026gt;q; t.l=sl,t.r=sr,t.c=sc,t.cnt=0; flag[t.l][t.r][t.c]=true; q.push(t); while(!q.empty()) { t=q.front(); for(int i=0; i\u0026lt;6; i++) { temp.l=t.l+movet[i],temp.r=t.r+movet[(i+2)%6],temp.c=t.c+movet[(i+4)%6],temp.cnt=t.cnt+1; if(temp.l==el\u0026amp;\u0026amp;temp.r==er\u0026amp;\u0026amp;temp.c==ec) return temp.cnt; else if(temp.l\u0026gt;=0\u0026amp;\u0026amp;temp.l\u0026lt;L\u0026amp;\u0026amp;temp.r\u0026gt;=0\u0026amp;\u0026amp;temp.r\u0026lt;R\u0026amp;\u0026amp;temp.c\u0026gt;=0\u0026amp;\u0026amp;temp.c\u0026lt;C\u0026amp;\u0026amp;map[temp.l][temp.r][temp.c]!=\u0026#39;#\u0026#39;\u0026amp;\u0026amp;!flag[temp.l][temp.r][temp.c]) { flag[temp.l][temp.r][temp.c]=true; q.push(temp); } } q.pop(); } return -1; } int main() { while(scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;L,\u0026amp;R,\u0026amp;C),L\u0026amp;\u0026amp;R\u0026amp;\u0026amp;C) { getchar(); for(int i=0; i\u0026lt;L; i++) { for(int j=0; j\u0026lt;R; j++) { for(int k=0; k\u0026lt;C; k++) { flag[i][j][k]=false; scanf(\u0026#34;%c\u0026#34;,\u0026amp;map[i][j][k]); if(map[i][j][k]==\u0026#39;S\u0026#39;) sl=i,sr=j,sc=k; else if(map[i][j][k]==\u0026#39;E\u0026#39;) el=i,er=j,ec=k; } getchar(); } getchar(); } int res=bfs(); if(res\u0026lt;0) printf(\u0026#34;Trapped!\\n\u0026#34;); else printf(\u0026#34;Escaped in %d minute(s).\\n\u0026#34;,res); } return 0; } ","date":"2016-07-29T10:34:16+08:00","permalink":"https://boiltask.com/oj/poj/2251/","title":"【POJ】[2251]Dungeon Master"},{"content":"问题描述 N皇后问题\r[hdu-2553] [3203295595393191] @vjudge\r问题分析 N皇后问题是道经典回溯问题\n这里参考《算法竞赛入门经典》 dfs中记录已经下了多少个棋子\n如果达到N个则说明有一种方案完成\n所以这一如此进行递归判断\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include\u0026lt;stdio.h\u0026gt; int res[15]; int flag[15]; int cnt; int abs(int m) { return m\u0026gt;0?m:-m; } void f(int m,int N) { if(m==N) cnt++; else { for(int i=0; i\u0026lt;N; i++) { flag[m]=i; int j; for(j=0; j\u0026lt;m; j++) if(flag[m]==flag[j]||abs(flag[m]-flag[j])==abs(m-j)) break; if(j==m) f(m+1,N); } } } void get() { for(int i=1; i\u0026lt;=10; i++) { cnt=0; f(0,i); res[i]=cnt; } return ; } int main() { get(); int n; while(scanf(\u0026#34;%d\u0026#34;,\u0026amp;n),n) printf(\u0026#34;%d\\n\u0026#34;,res[n]); return 0; } ","date":"2016-07-29T09:15:32+08:00","permalink":"https://boiltask.com/oj/hdu/2553/","title":"【杭电】[2553]N皇后问题"},{"content":"问题描述 Robot Motion\r[poj-1573] [3165549753565164] @vjudge\r问题分析 直接按照题目要求进行操作就好\n记录当前位置是第几步\n如果当前位置已经有记录\n说明已经被走过 也就是进入了循环\n如果有越界说明已经走出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include\u0026lt;stdio.h\u0026gt; char map[120][120]; int cnt[120][120]; int n,m,resx,resy; bool win=false; int move(int x,int y,int mcnt) { // printf(\u0026#34;%d-%d-%c\\n\u0026#34;,x,y,map[x][y]); if(x\u0026lt;0||x==n||y\u0026lt;0||y==m) { win=true; return mcnt-1; } if(cnt[x][y]) { win=false; resx=x; resy=y; return mcnt-1; } cnt[x][y]=mcnt; if(map[x][y]==\u0026#39;N\u0026#39;) return move(x-1,y,mcnt+1); else if(map[x][y]==\u0026#39;S\u0026#39;) return move(x+1,y,mcnt+1); else if(map[x][y]==\u0026#39;W\u0026#39;) return move(x,y-1,mcnt+1); else if(map[x][y]==\u0026#39;E\u0026#39;) return move(x,y+1,mcnt+1); } int main() { int k; while(scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;n,\u0026amp;m,\u0026amp;k),n||m||k) { getchar(); for(int i=0; i\u0026lt;n; i++) { for(int j=0; j\u0026lt;m; j++) { cnt[i][j]=0; scanf(\u0026#34;%c\u0026#34;,\u0026amp;map[i][j]); } getchar(); } int res=move(0,k-1,1); if(win) printf(\u0026#34;%d step(s) to exit\\n\u0026#34;,res); else printf(\u0026#34;%d step(s) before a loop of %d step(s)\\n\u0026#34;,cnt[resx][resy]-1,res-cnt[resx][resy]+1); } return 0; } ","date":"2016-07-28T15:29:22+08:00","permalink":"https://boiltask.com/oj/poj/1573/","title":"【POJ】[1573]Robot Motion"},{"content":"问题描述 变形课\r[hdu-1181] [3126446187477163] @vjudge\r问题分析 通过DFS来递归查找有无以\u0026rsquo;m\u0026rsquo;结尾的单词\n递归开始条件设为\u0026rsquo;b\u0026rsquo;\n每处理一组数据进行初始化\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; char s[1200][1200]; int flag[1200]; int cnt=0; bool Can=false; void judge(char c) { if(c==\u0026#39;m\u0026#39;) Can=true; bool win=false; for(int i=0; i\u0026lt;cnt; i++) { if(s[i][0]==c\u0026amp;\u0026amp;flag[i]==0) { flag[i]=1; int l=strlen(s[i]); judge(s[i][l-1]); } } } int main() { while(scanf(\u0026#34;%s\u0026#34;,s[cnt++])!=EOF) { if(s[cnt-1][0]==\u0026#39;0\u0026#39;) { judge(\u0026#39;b\u0026#39;); printf(\u0026#34;%s\\n\u0026#34;,Can?\u0026#34;Yes.\u0026#34;:\u0026#34;No.\u0026#34;); memset(flag,0,sizeof(flag)); cnt=0; Can=false; } } return 0; } ","date":"2016-07-28T11:57:50+08:00","permalink":"https://boiltask.com/oj/hdu/1181/","title":"【杭电】[1181]变形课"},{"content":"问题描述 Cow Bowling\r[poj-3176] [3160173745385710] @vjudge\r问题分析 经典dp问题 从下面向上有 $dp[i][j]+=max(dp[i+1][j],dp[i+1][j+1])$ 所以最后结果就会是$dp[0][0]$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; int map[352][352]; int main() { int n; while(scanf(\u0026#34;%d\u0026#34;,\u0026amp;n)!=EOF) { for(int i=0; i\u0026lt;n; i++) for(int j=0; j\u0026lt;=i; j++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;map[i][j]); if(n==1) { printf(\u0026#34;%d\\n\u0026#34;,map[0][0]); continue; } for(int i=n-2; i\u0026gt;=0; i--) { for(int j=0; j\u0026lt;=i; j++) { map[i][j]+=max(map[i+1][j],map[i+1][j+1]); } } printf(\u0026#34;%d\\n\u0026#34;,map[0][0]); } return 0; } ","date":"2016-07-28T09:56:15+08:00","permalink":"https://boiltask.com/oj/poj/3176/","title":"【POJ】[3176]Cow Bowling"},{"content":"问题描述 Babelfish\r[poj-2503] [3166072465556507] @vjudge\r问题分析 简单的STL应用，可用map+string水过读取字典的时候可用c=getchar()读取然后判断是否为‘\\n’来控制结束如果不是则继续把串读取完再合并起来\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;map\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; char s1[12],s2[12]; int main() { map\u0026lt;string,string\u0026gt;q; char c; while(c=getchar(),c!=\u0026#39;\\n\u0026#39;)\t{ scanf(\u0026#34;%s %s\u0026#34;,s1,s2); getchar(); string t1=s1; s1[0]=c,s1[1]=\u0026#39;\\0\u0026#39;; t1=s1+t1; string t2=s2; q[t2]=t1; } while(scanf(\u0026#34;%s\u0026#34;,s1)!=EOF) { string res=q[s1]; if(res.length()\u0026gt;0) printf(\u0026#34;%s\\n\u0026#34;,res.c_str()); else printf(\u0026#34;eh\\n\u0026#34;); } return 0; } ","date":"2016-07-28T09:15:14+08:00","permalink":"https://boiltask.com/oj/poj/2503/","title":"【POJ】[2503]Babelfish"},{"content":"问题描述 k-Multiple Free Set\r[codeforces-274A] [3228826969142761] @vjudge\r问题分析 要求y=x*k不与x同在同一集合的集合元素最大数\n则可考虑把有k倍关系的删除一个\n那么因为大数有可能还是其他小的数k倍数\n所以优先把较大的数删除\n二分查找在这里可用作搜索x的k倍数存不存在\n从而使查找的时间复杂度降为O(logn)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; int a[100200],flag[100200]; int main() { int n,k; while(scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;k)!=EOF) { for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]); sort(a,a+n); memset(flag,0,sizeof(flag)); int res=n; for(int i=0; i\u0026lt;n; i++) { if(!flag[i]) { __int64 t=(__int64)a[i]*k; if(a[n-1]\u0026lt;t) continue; int l=i+1,r=n-1; while(l\u0026lt;=r) { int mid=(l+r)/2; if(a[mid]\u0026gt;t) r=mid-1; else if(a[mid]\u0026lt;t) l=mid+1; else { flag[mid]=1; res--; break; } } } } printf(\u0026#34;%d\\n\u0026#34;,res); } return 0; } ","date":"2016-07-26T20:21:52+08:00","permalink":"https://boiltask.com/oj/codeforces/274A/","title":"【CodeForces】[274A]k-Multiple Free Set"},{"content":"问题描述 Hamburgers\r[codeforces-371C] [3198482657266742] @vjudge\r问题分析 与【CodeForces】[670D2]Magic Powder - 2类似\n同样是根据判断能不能做mid个\n来进行二分查找\n只不过这个每个汉堡所需的材料个数\n需要自己用字符串来数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; char s[120]; __int64 cnt[3]; __int64 n[3]; __int64 p[3]; __int64 r; bool judge(__int64 x) { __int64 t=r; for(int i=0; i\u0026lt;3; i++) { if(t/p[i]+n[i]\u0026lt;x*cnt[i]) return false; else t-=max((__int64)0,(x*cnt[i]-n[i])*p[i]); } return true; } int main() { while(scanf(\u0026#34;%s\u0026#34;,s)!=EOF) { cnt[0]=cnt[1]=cnt[2]=0; int ls=strlen(s); for(int i=0; i\u0026lt;ls; i++) { if(s[i]==\u0026#39;B\u0026#39;) cnt[0]++; else if(s[i]==\u0026#39;S\u0026#39;) cnt[1]++; else cnt[2]++; } for(int i=0; i\u0026lt;3; i++) scanf(\u0026#34;%I64d\u0026#34;,\u0026amp;n[i]); for(int i=0; i\u0026lt;3; i++) scanf(\u0026#34;%I64d\u0026#34;,\u0026amp;p[i]); scanf(\u0026#34;%I64d\u0026#34;,\u0026amp;r); __int64 l=0,r=1e13,res; while(l\u0026lt;=r) { __int64 mid=(l+r)/2; if(judge(mid)) { res=mid; l=mid+1; } else r=mid-1; } printf(\u0026#34;%I64d\\n\u0026#34;,res); } return 0; } ","date":"2016-07-26T20:17:11+08:00","permalink":"https://boiltask.com/oj/codeforces/371C/","title":"【CodeForces】[371C]Hamburgers"},{"content":"问题描述 Mafia\r[codeforces-348A] [3173291955655301] @vjudge\r问题分析 N个人参与一个游戏，每一局都必须有一个人出来当监督，剩下N-1个人当玩家，第i个人要求至少自己要当ai次玩家，请问最少要进行多少次游戏。\n根据x次游戏能否打成进行二分查找\n对于答案x的判定，先将每个人的要求加起来得到sum，然后判断x*n-sum，如果这个值大于等于x，说明可行，因为这个值就代表这些人可以提供最多的当监督的次数，只要监督的次数能够达到x次，就说明能够进行x次。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include\u0026lt;stdio.h\u0026gt; __int64 n,sum; bool judge(__int64 x) { return x*n-sum\u0026gt;=x; } int main() { while(scanf(\u0026#34;%d\u0026#34;,\u0026amp;n)!=EOF) { __int64 min=0; sum=0; for(int i=0; i\u0026lt;n; i++) { __int64 t; scanf(\u0026#34;%I64d\u0026#34;,\u0026amp;t); sum+=t; if(min\u0026lt;t) min=t; } __int64 l=min,r=sum,res; while(l\u0026lt;=r) { __int64 mid=(l+r)/2; if(judge(mid)) { res=mid; r=mid-1; } else l=mid+1; } printf(\u0026#34;%I64d\\n\u0026#34;,res); } return 0; } ","date":"2016-07-26T20:13:42+08:00","permalink":"https://boiltask.com/oj/codeforces/348A/","title":"【CodeForces】[348A]Mafia"},{"content":"问题描述 Counting Kangaroos is Fun\r[codeforces-372A] [3197712200777545] @vjudge\r问题分析 给n个袋鼠以及对应大小，把较小的放到较大的口袋里，判断最后头在外面的松鼠最少多少只\n能放在里面的条件是 a[i]*2\u0026lt;=a[j] 先把数组按照从小到大排序\n若想让外面有x个\n则a[0]~a[n-x]必然要被装\n所以可以以此判断\n进行二分查找\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; int a[500200]; int n; bool judge(int x) { if(x\u0026lt;(n+1)/2) return false; for(int i=0; i\u0026lt;n-x; i++) { if(a[i]*2\u0026gt;a[i+x]) return false; } return true; } int main() { while(scanf(\u0026#34;%d\u0026#34;,\u0026amp;n)!=EOF) { for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]); sort(a,a+n); int l=1,r=n,res; while(l\u0026lt;=r) { int mid=(l+r)/2; if(judge(mid)) { res=mid; r=mid-1; } else l=mid+1; } printf(\u0026#34;%d\\n\u0026#34;,res); } return 0; } ","date":"2016-07-26T20:09:14+08:00","permalink":"https://boiltask.com/oj/codeforces/372A/","title":"【CodeForces】[372A]Counting Kangaroos is Fun"},{"content":"问题描述 Magic Powder - 2\r[codeforces-670D2] [3268192100013952] @vjudge\r问题分析 题目大意：制作一个蛋糕需要n种材料，然后你有k克魔法粉，每克魔法粉可以代替任意一克的材料,ai代表制作一个蛋糕需要第i种材料多少克，bi代表你拥有第i个材料多少克，问做可以做多少个蛋糕。\n判断能不能做mid个蛋糕\n如果不能则减少mid的范围\n以此二分查找\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; __int64 a[100200],b[100200]; __int64 n,k; bool judge(__int64 x) { __int64 t=k; for(int i=0; i\u0026lt;n; i++) { if(b[i]+t\u0026gt;=a[i]*x) t-=max((__int64)0,a[i]*x-b[i]); else return false; } return true; } int main() { while(scanf(\u0026#34;%I64d %I64d\u0026#34;,\u0026amp;n,\u0026amp;k)!=EOF) { for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%I64d\u0026#34;,\u0026amp;a[i]); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%I64d\u0026#34;,\u0026amp;b[i]); __int64 l=0,r=2000000002,res; while(l\u0026lt;=r) { __int64 mid=(l+r)/2; if(judge(mid)) { res=mid; l=mid+1; } else r=mid-1; } printf(\u0026#34;%I64d\\n\u0026#34;,res); } return 0; } ","date":"2016-07-26T20:02:07+08:00","permalink":"https://boiltask.com/oj/codeforces/670D2/","title":"【CodeForces】[670D2]Magic Powder - 2"},{"content":"问题描述 Multiplication Table\r[codeforces-448D] [3192446154889684] @vjudge\r问题分析 每一行比x大的数有x/i个\n所以可以进行统计\n从而进行二分查找\n找到第k大(大于等于它的有k个)的元素\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; __int64 n,m,k; bool find(__int64 x) { __int64 cnt=0; for(int i=1; i\u0026lt;=n; i++) { cnt+=min(m,x/i); } return cnt\u0026gt;=k; } int main() { while(scanf(\u0026#34;%I64d %I64d %I64d\u0026#34;,\u0026amp;n,\u0026amp;m,\u0026amp;k)!=EOF) { __int64 l=1,r=n*m,res; while(l\u0026lt;=r) { __int64 mid=(r+l)/2; if(find(mid)) { res=mid; r=mid-1; } else l=mid+1; } printf(\u0026#34;%I64d\\n\u0026#34;,res); } return 0; } ","date":"2016-07-26T19:57:53+08:00","permalink":"https://boiltask.com/oj/codeforces/448D/","title":"【CodeForces】[448D]Multiplication Table"},{"content":"问题描述 Task schedule\r[hdu-4907] [3282568977220872] @vjudge\r问题分析 因为题目数据范围很小\n所以用标记法比较好理解\n用二分查找的话\n就是先把空间时间都统计出来\n然后用二分查找来找到\n大于q并且最接近q的空闲时间\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; int a[200200],b[200200]; int main() { int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); int n,m; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m); for(int i=1; i\u0026lt;=n; i++) { int t; scanf(\u0026#34;%d\u0026#34;,\u0026amp;t); a[t]=1; } int cnt=0; for(int i=0; i\u0026lt;200020; i++) if(!a[i]) b[cnt++]=i; while(m--) { int t; scanf(\u0026#34;%d\u0026#34;,\u0026amp;t); if(!a[t]) { printf(\u0026#34;%d\\n\u0026#34;,t); continue; } int l=0,r=cnt; while(l\u0026lt;=r) { int mid=(l+r)/2; if(b[mid]\u0026gt;=t) r=mid-1; else l=mid+1; } printf(\u0026#34;%d\\n\u0026#34;,b[l]); } } return 0; } ","date":"2016-07-26T19:50:36+08:00","permalink":"https://boiltask.com/oj/hdu/4907/","title":"【杭电】[4907]Task schedule"},{"content":"问题描述 Red packet\r[nbut-1651] [3245386802467867] @vjudge\r问题分析 比较麻烦的二分\n需要注意的是并不是选出一个可以最lucky的\n而是发完他之后\n无论后面怎么发都应该是他最lucky\n所以可以进行二分搜索\n然后判定时判断是因为mid过大还是因为mid过小\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include\u0026lt;stdio.h\u0026gt; int a[100020]; int n,m,k,sum; bool judge(int x) { if((n-k==1\u0026amp;\u0026amp;x\u0026gt;sum)||(n-k==2\u0026amp;\u0026amp;(x\u0026gt;sum-1||x\u0026lt;=sum/2))||x\u0026gt;sum-(n-k-1)||x\u0026lt;=sum-x-(n-k-2)) return false; for(int i=0; i\u0026lt;=k; i++) { if(x\u0026lt;=a[i]) return false; } return true; } int main() { int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;n,\u0026amp;m,\u0026amp;k); sum=0; for(int i=0; i\u0026lt;k; i++) { scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]); sum+=a[i]; } sum=m-sum; int l=0,r=m,res=0; while(l\u0026lt;=r) { int mid=(l+r)/2; if(judge(mid)) { res=mid; r=mid-1; } else { if((n-k==1\u0026amp;\u0026amp;mid\u0026gt;sum)||(n-k==2\u0026amp;\u0026amp;mid\u0026gt;sum-1)||mid\u0026gt;sum-(n-k-1)) r=mid-1; else l=mid+1; } } if(!res) printf(\u0026#34;Impossible\\n\u0026#34;); else printf(\u0026#34;%d\\n\u0026#34;,res); } return 0; } ","date":"2016-07-26T19:45:40+08:00","permalink":"https://boiltask.com/oj/nbut/1651/","title":"【NBUT】[1651]Red packet"},{"content":"问题描述 Expanding Rods\r[lightoj-1137] [3128549381013603] @vjudge\r问题分析 可推出关于圆弧半径r和h的方程\n$\\sqrt{r^2-(\\dfrac{l}{2})^2}+h=r$ ①\n$2*arsin(\\dfrac{l}{2r})*r=l\u0026rsquo;$②\n由①式可化简出\n$r=\\dfrac{h^2+\\dfrac{l^2}{4}}{2h}$\n代入②式中可求出l'\n把其与根据题目数据求出的l\u0026rsquo;比较\n可得到mid与res的比较关系\n从而可以进行二分查找\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;math.h\u0026gt; double L,n,c; bool judge(double m) { double t=(m*m+L*L/4.0)/m/2.0; if(2*asin(L/2.0/t)*t\u0026gt;=(1+n*c)*L) return true; else return false; } int main() { int T,kase=0; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { scanf(\u0026#34;%lf %lf %lf\u0026#34;,\u0026amp;L,\u0026amp;n,\u0026amp;c); double l=0,r=L; while(r-l\u0026gt;1e-8) { double mid=(l+r)/2; if(judge(mid)) r=mid; else l=mid; } printf(\u0026#34;Case %d: %.8lf\\n\u0026#34;,++kase,r); } return 0; } ","date":"2016-07-26T18:19:52+08:00","permalink":"https://boiltask.com/oj/lightoj/1137/","title":"【LightOJ】[1137]Expanding Rods"},{"content":"问题描述 Crossed Ladders\r[lightoj-1062] [3125582930135739] @vjudge\r问题分析 可以根据题目列出一个关于高度c和间隔d的方程\n$\\dfrac{c }{\\sqrt{x^2 - d^2}} + \\dfrac{c }{\\sqrt{y^2 - d^2}} = 1$\n化简得\n$c =\\dfrac{1}{ \\dfrac{1 }{\\sqrt{x^2 - d^2}} + \\dfrac{1 }{\\sqrt{y^2 - d^2}}}$\n可知若d比res大\n则c应该比所给c小\n由此可把mid与res进行比较\n从而进行二分查找\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;math.h\u0026gt; double x,y,c; bool judge(double m) { double res=1.0/(1.0/sqrt(y*y-m*m)+1.0/sqrt(x*x-m*m)); if(res\u0026gt;c) return true; else return false; } int main() { int T,kase=0; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { scanf(\u0026#34;%lf %lf %lf\u0026#34;,\u0026amp;x,\u0026amp;y,\u0026amp;c); double l=0,r=(x\u0026lt;y?x:y); while(r-l\u0026gt;1e-8) { double mid=(l+r)/2; if(judge(mid)) l=mid; else r=mid; } printf(\u0026#34;Case %d: %.8lf\\n\u0026#34;,++kase,l); } return 0; } ","date":"2016-07-26T18:04:01+08:00","permalink":"https://boiltask.com/oj/lightoj/1062/","title":"【LightOJ】[1062]Crossed Ladders"},{"content":"问题描述 The Frog\u0026#39;s Games\r[hdu-4004] [3097316427883761] @vjudge\r问题分析 因为可以方便比较\nmid是否比res大\n(通过计算mid下跳过石头所需的次数)\n所以可以对答案进行二分查找\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; int a[500200]; int L,n,m; bool judge(int x) { int cnt=0,t=0; for(int i=1; i\u0026lt;=n; i++) { if(a[i]-a[i-1]\u0026gt;x) return false; if(a[i]-t\u0026gt;x) { cnt++; t=a[--i]; } } if(cnt+1\u0026lt;=m) return true; else return false; } int main() { while(scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;L,\u0026amp;n,\u0026amp;m)!=EOF) { for(int i=1; i\u0026lt;=n; i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]); a[0]=0,a[++n]=L; sort(a,a+n+1); int l=0,r=L,res; while(l\u0026lt;=r) { int mid=(l+r)/2; if(judge(mid)) { res=mid; r=mid-1; } else l=mid+1; } printf(\u0026#34;%d\\n\u0026#34;,res); } return 0; } ","date":"2016-07-26T17:49:39+08:00","permalink":"https://boiltask.com/oj/hdu/4004/","title":"【杭电】[4004]The Frog's Games"},{"content":"问题描述 Can you find it?\r[hdu-2141] [3156819803343983] @vjudge\r问题分析 因为N最大为500\n所以如果开三重循环进行判断的话会超时\n那么可以思考如何进行优化\nAi+Bj+Ck=X\n⇒\nAi+Bj=X-Ck\n所以可以预处理Ai+Bj 保存之后进行排序 然后对于每个询问 循环C然后在预处理中 二分查找有无X-Ck\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; int l,n,m,cnt; int a[520],b[520],c[520],res[520*520]; bool find(int x) { int l=0,r=cnt-1; while(l\u0026lt;=r) { int mid=(l+r)/2; if(res[mid]\u0026gt;x) r=mid-1; else if(res[mid]\u0026lt;x) l=mid+1; else return true; } return false; } int main() { int kase=0; while(scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;l,\u0026amp;n,\u0026amp;m)!=EOF) { printf(\u0026#34;Case %d:\\n\u0026#34;,++kase); for(int i=0; i\u0026lt;l; i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;b[i]); for(int i=0; i\u0026lt;m; i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;c[i]); cnt=0; for(int i=0; i\u0026lt;l; i++) for(int j=0; j\u0026lt;n; j++) res[cnt++]=a[i]+b[j]; sort(res,res+cnt); int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { int t; scanf(\u0026#34;%d\u0026#34;,\u0026amp;t); int i; for(i=0; i\u0026lt;m; i++) { if(find(t-c[i])) break; } if(i\u0026lt;m) printf(\u0026#34;YES\\n\u0026#34;); else printf(\u0026#34;NO\\n\u0026#34;); } } return 0; } ","date":"2016-07-26T17:44:30+08:00","permalink":"https://boiltask.com/oj/hdu/2141/","title":"【杭电】[2141]Can you find it?"},{"content":"问题描述 Cable master\r[poj-1064] [3151927532608387] @vjudge\r问题分析 对结果进行二分搜索\n计算当前的mid可以分多少份\n与k进行比较\n判断条件也很好写\n然而……\n这是卡精度的一题\n需要注意的是因为题意\n所以最后结果不可以四舍五入\n需要进行舍弃\n而进制转换和double的灵异机制\n导致这一题最后的数据处理会很麻烦\n这里是因为逼得……\n所以用了一种很逗的方式输出……\n测试数据：\n1 2 3 4 5 6 7 8 9 10 11 12 4 2540 8.02 7.43 4.57 5.39 =\u0026gt;0.01 4 2542 8.02 7.43 4.57 5.39 =\u0026gt;0.00 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include\u0026lt;stdio.h\u0026gt; long long exgcd(long long a,long long b,long long \u0026amp;x,long long \u0026amp;y) { if(b==0) { x=1,y=0; return a; } long long d=exgcd(b,a%b,y,x); y-=x*(a/b); return d; } int main() { long long x,y,m,n,L; while(scanf(\u0026#34;%lld %lld %lld %lld %lld\u0026#34;,\u0026amp;x,\u0026amp;y,\u0026amp;m,\u0026amp;n,\u0026amp;L)!=EOF) { long long t1,t2; long long d=exgcd(n-m,L,t1,t2); if((y-x)%d!=0) printf(\u0026#34;Impossible\\n\u0026#34;); else { t1=t1*((x-y)/d); long long r=L/d; t1=(t1%r+r)%r; printf(\u0026#34;%lld\\n\u0026#34;,t1); } } return 0; } ","date":"2016-07-26T17:36:00+08:00","permalink":"https://boiltask.com/oj/poj/1064/","title":"【POJ】[1064]Cable master"},{"content":"二分查找不算是一种算法 我认为其更偏向为一种思想\n核心代码 1 2 3 4 5 6 7 while(l\u0026lt;=r) { mid=(l+r)/2; if(judge(mid)) { r=mid-1; } else l=mid+1; } 优点 使正常搜索的O(n)复杂度降为O(logn)\n要求 所要查找的目标数据必须为有序的\n说明 二分查找是通过不断缩小解可能存在的范围，从而求得问题最优解的方法。在学习与竞赛中，可以经常见到二分思想与其它算法结合的题目。\n用处 搜索有序数组中的某数 可以通过二分查找搜索数组中 1.有无某数 2.某数的位置\n求出方程在误差范围内的解 通过不断二分缩小解的范围\n最大化最小值 最小化平均值 因为这种问题可以方便的比较\n给定一数与正确解的相对大小\n所以即使不知道解具体是什么\n但可以通过比较缩小解的范围\n参考文章:\n《挑战程序设计竞赛》\n百度百科\n","date":"2016-07-26T17:24:57+08:00","permalink":"https://boiltask.com/knowledge/binary-search/","title":"二分查找——与答案进行比较的思维"},{"content":"问题描述 推箱子\r[hdu-1254] [3202140751368552] @vjudge\r问题分析 写这种搜索题不能多想……\n想好思路之后勇敢的写吧-.-\ndfs搜索能不能到\nbfs搜索最短距离\n","date":"2016-07-26T17:01:23+08:00","permalink":"https://boiltask.com/oj/hdu/1254/","title":"【杭电】[1254]推箱子"},{"content":"问题描述 Can you solve this equation?\r[hdu-2199] [3108287869870259] @vjudge\r问题分析 二分搜索答案\n与Y进行比较可知道mid与res的大小关系\n注意x的取值为0~100\n因为函数f(m)=8m4+7m3+2*m2+3*m+6\n在0~100上单调递增\n所以如果Y\u0026lt;f(0)||Y\u0026gt;f(100)是没有结果的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include\u0026lt;stdio.h\u0026gt; double n; double f(double m) { return 8*m*m*m*m+7*m*m*m+2*m*m+3*m+6; } bool judge(double m) { if(f(m)\u0026gt;n) return true; else return false; } int main() { int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { scanf(\u0026#34;%lf\u0026#34;,\u0026amp;n); if(n\u0026lt;f(0.0)||n\u0026gt;f(100.0)) { printf(\u0026#34;No solution!\\n\u0026#34;); continue; } double r=10000000000,l=0,res; while(r-l\u0026gt;1e-6) { double mid=(r+l)/2; if(judge(mid)) { res=mid; r=mid; } else l=mid; } printf(\u0026#34;%.4lf\\n\u0026#34;,res); } return 0; } ","date":"2016-07-26T17:01:23+08:00","permalink":"https://boiltask.com/oj/hdu/2199/","title":"【杭电】[2199]Can you solve this equation?"},{"content":"问题描述 Raising Modulo Numbers\r[poj-1995] [3158656970847213] @vjudge\r问题分析 题目大意:\n有的人爱看片儿、有的人爱在地窖里造原子弹、有的人爱用Windows，我爱计算(A1B1+A2B2+ … +AHBH)mod M\n由题目所说 直接用快速幂计算就好\n根据同余定理进行取模计算\nPS：世界上怎么会有这种人-.-\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include\u0026lt;stdio.h\u0026gt; int pow(int a,int b,int m) { __int64 r=1,t=a; while(b) { if(b\u0026amp;1) r=r*t%m; t=t*t%m; b\u0026gt;\u0026gt;=1; } return (int)r; } int main() { int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { int M; scanf(\u0026#34;%d\u0026#34;,\u0026amp;M); int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); __int64 sum=0; while(n--) { int a,b; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a,\u0026amp;b); sum=(sum+pow(a,b,M))%M; } printf(\u0026#34;%lld\\n\u0026#34;,sum); } return 0; } ","date":"2016-07-25T17:51:51+08:00","permalink":"https://boiltask.com/oj/poj/1995/","title":"【POJ】[1995]Raising Modulo Numbers"},{"content":"问题描述 Carmichael Numbers\r[uva-10006] [3106842600866412] @vjudge\r问题分析 一个数是Carmichael Numbers的条件为\n1.不是素数(这个数是合数)\n2.区间[2,n-1]中没有全部满足xn≡x(mod n)\n求素数可用筛法\n求幂可用快速幂取模\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; int prime[65200]; void getprime() { memset(prime,0,sizeof(prime)); prime[0]=prime[1]=1; for(int i=2; i\u0026lt;30000; i++) if(!prime[i]) { for(int j=i*i; j\u0026lt;65200; j+=i) prime[j]=1; } return ; } int pow(int a,int b) { int MOD=b; long long r=1,t=a%MOD; while(b) { if(b\u0026amp;1) r=r*t%MOD; t=t*t%MOD; b\u0026gt;\u0026gt;=1; } return (int)r; } bool judge(int n) { if(!prime[n]) return false; for(int i=2; i\u0026lt;n; i++) if(pow(i,n)!=i) { return false; } return true; } int main() { getprime(); int n; while(scanf(\u0026#34;%d\u0026#34;,\u0026amp;n),n) { if(judge(n)) printf(\u0026#34;The number %d is a Carmichael number.\\n\u0026#34;,n); else printf(\u0026#34;%d is normal.\\n\u0026#34;,n); } return 0; } ","date":"2016-07-25T17:17:37+08:00","permalink":"https://boiltask.com/oj/uva/10006/","title":"【UVa】[10006]Carmichael Numbers"},{"content":"问题描述 Key Set\r[hdu-5363] [3290484335498603] @vjudge\r问题分析 随便找下规律吧\n答案是$2^{n-1}-1$\n注意用快速幂时中间值溢出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include\u0026lt;stdio.h\u0026gt; int MOD=1000000007; int pow(int a,int b) { __int64 r=1,t=a%MOD; while(b) { if(b\u0026amp;1) r=r*t%MOD; t=t*t%MOD; b\u0026gt;\u0026gt;=1; } return (int)r; } int main() { int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); printf(\u0026#34;%d\\n\u0026#34;,pow(2,n-1)-1); } return 0; } ","date":"2016-07-25T15:49:15+08:00","permalink":"https://boiltask.com/oj/hdu/5363/","title":"【杭电】[5363]Key Set"},{"content":"问题描述 Rightmost Digit\r[hdu-1061] [3164659737751154] @vjudge\r问题分析 如果正常求幂则可使用快速幂\n1 2 3 4 5 6 7 8 9 10 11 12 int pow4(int a,int b) { int r=1,base=a; while(b!=0) { if(b\u0026amp;1) r*=base; base*=base; b\u0026gt;\u0026gt;=1; } return r; } 运用同余定理可求出最后一位数字\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include\u0026lt;stdio.h\u0026gt; int pow(int a,int b) { int r=1,base=a%10; while(b!=0) { if(b%2) r=r*base%10; base=base*base%10; b/=2; } return r; } int main() { int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); printf(\u0026#34;%d\\n\u0026#34;,pow(n,n)); } return 0; } 否则的话找规律打表也是个方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include\u0026lt;stdio.h\u0026gt; int res[4][10]= { {0,1,6,1,6,5,6,1,6,1}, {0,1,2,3,4,5,6,7,8,9}, {0,1,4,9,6,5,6,9,4,1}, {0,1,8,7,4,5,6,3,2,9} }; int main() { int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); printf(\u0026#34;%d\\n\u0026#34;,res[n%4][n%10]); } return 0; } 推荐博客: 杭电OJ（HDOJ）1097题：A hard puzzle（数论）\n","date":"2016-07-25T15:16:43+08:00","permalink":"https://boiltask.com/oj/hdu/1061/","title":"【杭电】[1061]Rightmost Digit"},{"content":"问题描述 Bellovin\r[hdu-5748] [3256955378826910] @vjudge\r问题分析 LIS模板问题\n可知所要求的数列\n即是每个fi\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; int a[100200],b[100200],g[100200],cnt[100200]; int main() { int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i=1; i\u0026lt;=n; i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]); for(int i=1; i\u0026lt;=n; i++) g[i]=0x3f3f3f3f; for(int i=1; i\u0026lt;=n; i++) { int k=lower_bound(g+1,g+n+1,a[i])-g; cnt[i]=k; g[k]=min(g[k],a[i]); } for(int i=1; i\u0026lt;=n; i++) { printf(\u0026#34;%d\u0026#34;,cnt[i]); if(i==n) printf(\u0026#34;\\n\u0026#34;); else printf(\u0026#34; \u0026#34;); } } return 0; } ","date":"2016-07-25T08:19:30+08:00","permalink":"https://boiltask.com/oj/hdu/5748/","title":"【杭电】[5748]Bellovin"},{"content":"问题描述 Aaronson\r[hdu-5747] [3256924025682332] @vjudge\r问题分析 其实和那个问最少需用几张纸币付账的题目类似\n由题意使$2^m$尽量大就好\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include\u0026lt;stdio.h\u0026gt; int main() { int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { __int64 n,m; scanf(\u0026#34;%I64d %I64d\u0026#34;,\u0026amp;n,\u0026amp;m); if(n==0) { printf(\u0026#34;0\\n\u0026#34;); continue; } __int64 t=1,cnt=1; while(t\u0026lt;\u0026lt;1 \u0026lt;=n \u0026amp;\u0026amp; cnt\u0026lt;=m) { cnt++; t\u0026lt;\u0026lt;=1; } __int64 sum=0; while(n) { sum+=n/t; n%=t; t\u0026gt;\u0026gt;=1; } printf(\u0026#34;%I64d\\n\u0026#34;,sum); } return 0; } ","date":"2016-07-25T08:16:40+08:00","permalink":"https://boiltask.com/oj/hdu/5747/","title":"【杭电】[5747]Aaronson"},{"content":"问题描述 Tian Ji -- The Horse Racing\r[hdu-1052] [3150666324523658] @vjudge\r问题分析 贪心策略:\n若田忌最快的马胜过齐威王最快的马\n则进行比赛\n若田忌最快的马慢于齐威王最快的马\n则那田忌最慢的马与其比赛\n若田忌最快的马等于齐威王最快的马\n则比较田忌最慢的马与齐威王最慢的马\n若田忌快于齐威王\n则进行比赛\n否则依旧拿最慢的马与齐威王最快的马比赛\n在比赛的过程中加判断\n以防把平局判断成输\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; int a[1200],b[1200]; int main() { int n; while(scanf(\u0026#34;%d\u0026#34;,\u0026amp;n),n) { for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;b[i]); sort(a,a+n); sort(b,b+n); int cnt=0; int al=0,ar=n-1,bl=0,br=n-1; for(int i=0; i\u0026lt;n; i++) { if(a[ar]\u0026gt;b[br]) { ar--,br--; cnt++; } else if(a[ar]\u0026lt;b[br]) { al++,br--,cnt--; } else if(a[al]\u0026gt;b[bl]) { al++,bl++; cnt++; } else { if(a[al]\u0026lt;b[br]) cnt--; al++,br--; } } printf(\u0026#34;%d\\n\u0026#34;,cnt*200); } return 0; } ","date":"2016-07-23T18:11:28+08:00","permalink":"https://boiltask.com/oj/hdu/1052/","title":"【杭电】[1052]Tian Ji -- The Horse Racing"},{"content":"问题描述 Vacations\r[codeforces-698A] [3258458633318374] @vjudge\r问题分析 需要注意问的是至少休息多少天\n所以要让$a[i]==0$的天数尽量少\n从前到后\n如果$a[i]==3$\n那么如果$a[i-1]==1$那$a[i]=2$\n如果$a[i-1]==2$那$a[i]=1$\n如果在循环开始就有3的话则不用考虑\n因为无论3有多少个都可以组合成有事天数\n对结果没有影响\n如果$a[i]==a[i-1]$\n那么把$a[i]$更新为0\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include\u0026lt;stdio.h\u0026gt; int a[120]; int main() { int n; while(scanf(\u0026#34;%d\u0026#34;,\u0026amp;n)!=EOF) { for(int i=0; i\u0026lt;n; i++) { scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]); if(i\u0026gt;0\u0026amp;\u0026amp;a[i]==3\u0026amp;\u0026amp;(a[i-1]==1||a[i-1]==2)) a[i]-=a[i-1]; else if(i\u0026gt;0\u0026amp;\u0026amp;a[i]!=3\u0026amp;\u0026amp;a[i]==a[i-1]) a[i]=0; } int cnt=0; for(int i=0; i\u0026lt;n; i++) if(a[i]==0) cnt++; printf(\u0026#34;%d\\n\u0026#34;,cnt); } return 0; } ","date":"2016-07-23T17:44:41+08:00","permalink":"https://boiltask.com/oj/codeforces/698A/","title":"【CodeForces】[698A]Vacations"},{"content":"问题描述 Far Relative’s Problem\r[codeforces-629B] [3242008783685289] @vjudge\r问题分析 一直感觉这种题目不算贪心\n但是却又看到好多把它分类到贪心\n应该也是有关于区间贪心的写法\n然而一直没想到也没找到相关写法\n这个复杂度取决于区间大小\n贪心策略取决于n的大小\n应该也是可以有所抉择\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;algorithm\u0026gt; #include\u0026lt;string.h\u0026gt; using namespace std; struct node { char sex; int l,r; } a[5200]; int man[5200],woman[5200]; int main() { int n; while(scanf(\u0026#34;%d\u0026#34;,\u0026amp;n)!=EOF) { getchar(); memset(man,0,sizeof(man)); memset(woman,0,sizeof(woman)); for(int i=0; i\u0026lt;n; i++) { scanf(\u0026#34;%c %d %d\u0026#34;,\u0026amp;a[i].sex,\u0026amp;a[i].l,\u0026amp;a[i].r); getchar(); if(a[i].sex==\u0026#39;M\u0026#39;) { for(int j=a[i].l; j\u0026lt;=a[i].r; j++) man[j]++; } else { for(int j=a[i].l; j\u0026lt;=a[i].r; j++) woman[j]++; } } int res=0; for(int i=1; i\u0026lt;367; i++) { res=max(res,min(man[i],woman[i])); } printf(\u0026#34;%d\\n\u0026#34;,res*2); } return 0; } ","date":"2016-07-23T16:45:46+08:00","permalink":"https://boiltask.com/oj/codeforces/629B/","title":"【CodeForces】[629B]Far Relative’s Problem"},{"content":"问题描述 Radar Installation\r[poj-1328] [3158147394585098] @vjudge\r问题分析 因为雷达必须要建立在x轴上\n所以当y\u0026gt;d则-1\n求出以点为圆心，d为半径的圆\n与x轴交于两点\n若雷达在两点之间\n则可以覆盖这个点\n因为区间有重合的部分\n所以只需在重合部分放点\n则可以覆盖尽量多的点\n由此可把问题转换为\n给出数段区间\n问使每个区间至少有一个点需要多少点\n所以想出贪心策略\n可以区间右端点排序\n比较时假设在第一个右端点建立雷达\n坐标记为t\n则若下一端点的左端点在此点之后\n则把t更新为下一端点的右端点\n并使cnt++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include\u0026lt;stdio.h\u0026gt; char map[120][120]; int cnt[120][120]; int n,m,resx,resy; bool win=false; int move(int x,int y,int mcnt) { // printf(\u0026#34;%d-%d-%c\\n\u0026#34;,x,y,map[x][y]); if(x\u0026lt;0||x==n||y\u0026lt;0||y==m) { win=true; return mcnt-1; } if(cnt[x][y]) { win=false; resx=x; resy=y; return mcnt-1; } cnt[x][y]=mcnt; if(map[x][y]==\u0026#39;N\u0026#39;) return move(x-1,y,mcnt+1); else if(map[x][y]==\u0026#39;S\u0026#39;) return move(x+1,y,mcnt+1); else if(map[x][y]==\u0026#39;W\u0026#39;) return move(x,y-1,mcnt+1); else if(map[x][y]==\u0026#39;E\u0026#39;) return move(x,y+1,mcnt+1); } int main() { int k; while(scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;n,\u0026amp;m,\u0026amp;k),n||m||k) { getchar(); for(int i=0; i\u0026lt;n; i++) { for(int j=0; j\u0026lt;m; j++) { cnt[i][j]=0; scanf(\u0026#34;%c\u0026#34;,\u0026amp;map[i][j]); } getchar(); } int res=move(0,k-1,1); if(win) printf(\u0026#34;%d step(s) to exit\\n\u0026#34;,res); else printf(\u0026#34;%d step(s) before a loop of %d step(s)\\n\u0026#34;,cnt[resx][resy]-1,res-cnt[resx][resy]+1); } return 0; } ","date":"2016-07-23T15:41:26+08:00","permalink":"https://boiltask.com/oj/poj/1328/","title":"【POJ】[1328]Radar Installation"},{"content":"问题描述 Doing Homework again\r[hdu-1789] [3203032630771949] @vjudge\r问题分析 为了让浪费的分数最小\n考虑优先排序分数\n由题意知，尽量使安排放在靠近截止日期的那一天\n比如 4 天截止\n那么便考虑放在第4天完成，如果不行就第3天第2天……\n如果安排不了，说明这个分数就浪费了\n所以可建数组记录当天是否有安排作业\n以此来判断作业应该安排在哪一天\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; struct node { int date,score; } a[1200]; bool cmp(node A,node B) { if(A.score==B.score) return A.date\u0026gt;B.date; else return A.score\u0026gt;B.score; } int flag[1200]; int main() { int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i].date); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i].score); sort(a,a+n,cmp); int sum=0; memset(flag,0,sizeof(flag)); for(int i=0; i\u0026lt;n; i++) { int j; for(j=a[i].date; j\u0026gt;0; j--) { if(!flag[j]) { flag[j]=1; break; } } if(j==0) sum+=a[i].score; } printf(\u0026#34;%d\\n\u0026#34;,sum); } return 0; } ","date":"2016-07-23T10:07:20+08:00","permalink":"https://boiltask.com/oj/hdu/1789/","title":"【杭电】[1789]Doing Homework again"},{"content":"问题描述 Repair the Wall\r[hdu-2124] [3104468706585119] @vjudge\r问题分析 排序之后由大向小取就好\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; int a[620]; int main() { __int64 l,n; while(scanf(\u0026#34;%I64d %d\u0026#34;,\u0026amp;l,\u0026amp;n)!=EOF) { for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%I64d\u0026#34;,\u0026amp;a[i]); sort(a,a+n); int cnt=0; for(int i=n-1; i\u0026gt;=0; i--) { if(l\u0026lt;=0) break; l-=a[i]; cnt++; } if(l\u0026gt;0) printf(\u0026#34;impossible\\n\u0026#34;); else printf(\u0026#34;%d\\n\u0026#34;,cnt); } return 0; } ","date":"2016-07-23T09:32:30+08:00","permalink":"https://boiltask.com/oj/hdu/2124/","title":"【杭电】[2124]Repair the Wall"},{"content":"问题描述 FatMouse\u0026#39; Trade\r[hdu-1009] [3150270416195812] @vjudge\r问题分析 计算单位价值之后排序就好\n需要注意若物品“免费”\n则可以直接把其重量加入sum\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; struct node { int j,f; double m; } a[1200]; bool cmp(node A,node B) { return A.m\u0026gt;B.m; } int main() { int m,n; while(scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;m,\u0026amp;n),m!=-1||n!=-1) { double sum=0; for(int i=0; i\u0026lt;n; i++) { scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a[i].j,\u0026amp;a[i].f); if(a[i].f\u0026gt;0) a[i].m=(double)a[i].j/a[i].f; else { a[i].m=0; sum+=a[i].j; } } sort(a,a+n,cmp); for(int i=0; i\u0026lt;n; i++) { sum+=min(m,a[i].f)*a[i].m; m-=min(m,a[i].f); } printf(\u0026#34;%.3lf\\n\u0026#34;,sum); } return 0; } ","date":"2016-07-23T08:58:35+08:00","permalink":"https://boiltask.com/oj/hdu/1009/","title":"【杭电】[1009]FatMouse' Trade"},{"content":"问题描述 小珂的苦恼\r时间限制：1000 ms内存限制：256 MB\r描述 小珂是一名初中生，她现在很苦恼，因为老师布置了一个让她苦恼的作业，你能不能帮助她呢？题目信息如下。\n已知二元一次方程 ax+by=n， 判断这个二元一次方程有没有整数解，x,y为未知数，其中a，b，n都为整数且不等于零，同时满足0\u0026lt;a,b,n\u0026lt;2^16-1。\n输入 第一行有一个整数0\u0026lt;n\u0026lt;=1000000表示有 n组测试数据,接下来的每一行有三个整数分别是a,b,n\n输出 存在整数x和y使得方程有解，输出“Yes”，否则输出“No”\n样例输入 1 2 3 2 2 4 2 3 9 7 样例输出 1 2 Yes No 题目来源 小珂的苦恼 - NYOJ\n问题分析 二元一次方程有整数解的条件为\n$n\\%gcd(a,b)==0$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include\u0026lt;stdio.h\u0026gt; int gcd(int a,int b) { return b==0?a:gcd(b,a%b); } int main() { int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { int a,b,n; scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;a,\u0026amp;b,\u0026amp;n); printf(\u0026#34;%s\\n\u0026#34;,n%gcd(a,b)==0?\u0026#34;Yes\u0026#34;:\u0026#34;No\u0026#34;); } return 0; } ","date":"2016-07-22T09:25:36+08:00","permalink":"https://boiltask.com/oj/nyoj/1143/","title":"【NYOJ】[1143]小珂的苦恼"},{"content":"问题描述 Biorhythms\r[poj-1006] [3151027316338878] @vjudge\r","date":"2016-07-22T09:23:52+08:00","permalink":"https://boiltask.com/oj/poj/1006/","title":"【POJ】[1006]Biorhythms"},{"content":"问题描述 Kefa and Company\r[codeforces-580B] [3296914340964919] @vjudge\r问题分析 以钱数进行排序\n对每个可同时参加的区间的总友好度进行统计\n每次遇见新的人判断是否能与最左端的人同在\n不能的话则把最左端的人删掉\n以此改变sum值\n并更新max\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; struct node { int m,s; } a[100200]; bool cmp(node A,node B) { return A.m\u0026lt;B.m; } int main() { int n,d; while(scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;d)!=EOF) { for(int i=0; i\u0026lt;n; i++) { scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a[i].m,\u0026amp;a[i].s); } sort(a,a+n,cmp); int l=0; __int64 max=0,sum=0; for(int i=0; i\u0026lt;n; i++) { sum+=(__int64)a[i].s; while(a[i].m\u0026gt;=a[l].m+d) { sum-=(__int64)a[l].s; l++; } if(max\u0026lt;sum) max=sum; } printf(\u0026#34;%I64d\\n\u0026#34;,max); } return 0; } ","date":"2016-07-21T16:11:57+08:00","permalink":"https://boiltask.com/oj/codeforces/580B/","title":"【CodeForces】[580B]Kefa and Company"},{"content":"问题描述 Spongebob and Joke\r[codeforces-599B] [3253507590175335] @vjudge\r问题分析 记录数字出现次数及坐标\n然后读取时判断能不能对应\n最后判断输出方式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; int cnt[100200],res[100200]; int a[100200]; int main() { int n,m; while(scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m)!=EOF) { memset(cnt,0,sizeof(cnt)); memset(res,0,sizeof(res)); for(int i=1; i\u0026lt;=n; i++) { int t; scanf(\u0026#34;%d\u0026#34;,\u0026amp;t); cnt[t]++; res[t]=i; } int flag=0; for(int i=1; i\u0026lt;=m; i++) { scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]); if(flag\u0026lt;2) { if(cnt[a[i]]==0) flag=2; else if(cnt[a[i]]\u0026gt;1) flag=1; } } if(flag==0) { printf(\u0026#34;Possible\\n\u0026#34;); for(int i=1; i\u0026lt;=m; i++) { printf(\u0026#34;%d\u0026#34;,res[a[i]]); if(i==m) printf(\u0026#34;\\n\u0026#34;); else printf(\u0026#34; \u0026#34;); } } else if(flag==1) printf(\u0026#34;Ambiguity\\n\u0026#34;); else printf(\u0026#34;Impossible\\n\u0026#34;); } return 0; } ","date":"2016-07-21T16:07:40+08:00","permalink":"https://boiltask.com/oj/codeforces/599B/","title":"【CodeForces】[599B]Spongebob and Joke"},{"content":"问题描述 HDD is Outdated Technology\r[codeforces-612B] [3237958140419432] @vjudge\r问题分析 记录数字的下标存入$a[t]=i$\n然后直接累加$abs(a[i+1]-a[i])$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include\u0026lt;stdio.h\u0026gt; int a[1000000]; int abs(int m){ return m\u0026gt;0?m:-m; } int main() { int n; while(scanf(\u0026#34;%d\u0026#34;,\u0026amp;n)!=EOF) { for(int i=1; i\u0026lt;=n; i++) { int t; scanf(\u0026#34;%d\u0026#34;,\u0026amp;t); a[t]=i; } __int64 sum=0; for(int i=1; i\u0026lt;n; i++) { sum+=(__int64)abs(a[i]-a[i+1]); } printf(\u0026#34;%I64d\\n\u0026#34;,sum); } return 0; } ","date":"2016-07-21T16:04:25+08:00","permalink":"https://boiltask.com/oj/codeforces/612B/","title":"【CodeForces】[612B]HDD is Outdated Technology"},{"content":"问题描述 Restaurant\r[codeforces-597B] [3237958140419432] @vjudge\r问题分析 与【杭电】[2037]今年暑假不AC相同思路\n简单的贪心问题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; struct node { int l,r; } a[1000000]; bool cmp(node A,node B) { if(A.r==B.r) return A.l\u0026gt;B.l; else return A.r\u0026lt;B.r; } int main() { int n; while(scanf(\u0026#34;%d\u0026#34;,\u0026amp;n)!=EOF) { for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a[i].l,\u0026amp;a[i].r); sort(a,a+n,cmp); int cnt=1; int t=a[0].r; for(int i=1; i\u0026lt;n; i++) { if(a[i].l\u0026gt;t) { t=a[i].r; cnt++; } } printf(\u0026#34;%d\\n\u0026#34;,cnt); } return 0; } ","date":"2016-07-21T15:59:18+08:00","permalink":"https://boiltask.com/oj/codeforces/597B/","title":"【CodeForces】[597B]Restaurant"},{"content":"问题描述 Bulbs\r[codeforces-615A] [3240286827108617] @vjudge\r问题分析 给出每个按钮可点亮的灯\n问能否把所有灯点亮\n因为点亮后的灯不会熄灭\n所以只要有按钮控制的灯都能点亮\n也就是只要出现过的灯都能点亮\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; int a[120]; int main() { int n,m; while(scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m)!=EOF) { memset(a,0,sizeof(a)); for(int i=0; i\u0026lt;n; i++) { int t; scanf(\u0026#34;%d\u0026#34;,\u0026amp;t); while(t--) { int tx; scanf(\u0026#34;%d\u0026#34;,\u0026amp;tx); a[tx]=1; } } int i; for(i=1; i\u0026lt;=m; i++) { if(!a[i]) break; } printf(\u0026#34;%s\\n\u0026#34;,i\u0026lt;=m?\u0026#34;NO\u0026#34;:\u0026#34;YES\u0026#34;); } return 0; } ","date":"2016-07-21T15:45:05+08:00","permalink":"https://boiltask.com/oj/codeforces/615A/","title":"【CodeForces】[615A]Bulbs"},{"content":"问题描述 New Year and Days\r[codeforces-611A] [3237604900516252] @vjudge\r问题分析 找规律题目\n已知平年有52周零1天\n闰年有52周零2天\n2016年为闰年，并且第一天为周五\n所以一年有53个周五周六，其余为52\n一年有12个月有29号\n一年有11个月有30号\n一年有7个月有31号\n1 2 3 4 5 6 7 8 9 10 11 12 #include\u0026lt;stdio.h\u0026gt; int main() { int n; char s[10]; while(scanf(\u0026#34;%d of %s\u0026#34;,\u0026amp;n,s)!=EOF) { if(s[0]==\u0026#39;w\u0026#39;) printf(\u0026#34;%d\\n\u0026#34;,n==5||n==6?53:52); else printf(\u0026#34;%d\\n\u0026#34;,n\u0026lt;30?12:(n==30?11:7)); } return 0; } ","date":"2016-07-21T15:40:51+08:00","permalink":"https://boiltask.com/oj/codeforces/611A/","title":"【CodeForces】[611A]New Year and Days"},{"content":"问题描述 Pasha and Stick\r[codeforces-610A] [3238035275300974] @vjudge\r问题分析 可把数n当做由两个不同的偶数组合而成\n问有多少种组合\n可知当为奇数或$n==2$时无解\n对于组合n的数必定是一个小于n/2一个大于n/2\n所以可把n/2来求种类\n而在1~n/2的范围里有n/4个偶数\n当n/2位偶数，则最后结果不能为自身\n当其为奇数，则最后结果为(n/2-1)/2\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include\u0026lt;stdio.h\u0026gt; int main() { __int64 n; while(scanf(\u0026#34;%I64d\u0026#34;,\u0026amp;n)!=EOF) { if(n\u0026lt;4||n%2==1) printf(\u0026#34;0\\n\u0026#34;); else if(n/2%2==0) printf(\u0026#34;%d\\n\u0026#34;,n/4-1); else printf(\u0026#34;%d\\n\u0026#34;,(n/2-1)/2); } return 0; } ","date":"2016-07-21T15:35:41+08:00","permalink":"https://boiltask.com/oj/codeforces/610A/","title":"【CodeForces】[610A]Pasha and Stick"},{"content":"问题描述 The Text Splitting\r[codeforces-612A] [3237954999198941] @vjudge\r问题分析 因为题目说多种结果输出一种即可\n所以相当于问一个二元一次方程有无整数解\n数据小可以枚举法找到整数解\n然后分段输出即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include\u0026lt;stdio.h\u0026gt; char s[120]; int main() { int n,p,q; while(scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;n,\u0026amp;p,\u0026amp;q)!=EOF) { scanf(\u0026#34;%s\u0026#34;,s); int a=-1,b=-1; for(int i=0; i\u0026lt;=n; i++) { for(int j=0; j\u0026lt;=n; j++) { if(i*p+j*q==n) { a=i; b=j; break; } } } if(a==-1) printf(\u0026#34;-1\\n\u0026#34;); else { printf(\u0026#34;%d\\n\u0026#34;,a+b); for(int i=0; i\u0026lt;a; i++) { for(int j=0; j\u0026lt;p; j++) printf(\u0026#34;%c\u0026#34;,s[p*i+j]); printf(\u0026#34;\\n\u0026#34;); } for(int i=0; i\u0026lt;b; i++) { for(int j=0; j\u0026lt;q; j++) printf(\u0026#34;%c\u0026#34;,s[p*a+q*i+j]); printf(\u0026#34;\\n\u0026#34;); } } } return 0; } ","date":"2016-07-21T15:29:05+08:00","permalink":"https://boiltask.com/oj/codeforces/612A/","title":"【CodeForces】[612A]The Text Splitting"},{"content":"问题描述 Uncowed Forces\r[codeforces-604A] [3253361538315946] @vjudge\r问题分析 注意数据类型\n防止精度丢失\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include\u0026lt;stdio.h\u0026gt; double max(double a,double b) { return a\u0026gt;b?a:b; } int main() { int m[5]; while(scanf(\u0026#34;%d\u0026#34;,\u0026amp;m[0])!=EOF) { int s[]= {500,1000,1500,2000,2500}; for(int i=1; i\u0026lt;5; i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;m[i]); int w[5]; for(int i=0; i\u0026lt;5; i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;w[i]); int h1,h2; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;h1,\u0026amp;h2); double sum=0; for(int i=0; i\u0026lt;5; i++) { sum+=max(0.3*s[i],(1-m[i]/250.0)*s[i]-50*w[i]); } printf(\u0026#34;%.lf\\n\u0026#34;,sum+100*h1-50*h2); } return 0; } ","date":"2016-07-21T15:24:55+08:00","permalink":"https://boiltask.com/oj/codeforces/604A/","title":"【CodeForces】[604A]Uncowed Forces"},{"content":"问题描述 Patrick and Shopping\r[codeforces-599A] [3272820263258311] @vjudge\r问题分析 与【郑轻】[1799]wrz的压岁钱类似\n需把情况考虑完整\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include\u0026lt;stdio.h\u0026gt; int main() { int a,b,c; while(scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;a,\u0026amp;b,\u0026amp;c)!=EOF) { int x[5]; x[0]=a+b+c; x[1]=a+a+b+b; x[2]=a+c+c+a; x[3]=b+c+c+b; int min=x[0]; for(int i=1; i\u0026lt;4; i++) if(min\u0026gt;x[i]) min=x[i]; printf(\u0026#34;%d\\n\u0026#34;,min); } } ","date":"2016-07-21T15:22:09+08:00","permalink":"https://boiltask.com/oj/codeforces/599A/","title":"【CodeForces】[599A]Patrick and Shopping"},{"content":"欧几里得算法 任务 求两个数a,b的最大公约数gcd(a,b)\n说明 由贝祖定理[若设a,b是整数，则存在整数x,y，使得ax+by=gcd（a,b）]得，gcd(a,b)=(b,a-b),其中a≥b。通过这样不断的迭代，知道b=0，就是原来数对的最大公约数。考虑到只使用减法会超时，我们观察到如果a-b仍然大于b的话，要进行一次同样的操作，就把a减到不足b为止，所以有gcd(a,b)=gcd(b,a mod b)。由此可以在log的时间内求出两个数的gcd。\n程序 int gcd(int a,int b);\n复杂度 O(logN)，其中N和a，b同阶\n输入 a，b两个整数\n输出 a，b的最大公约数\n代码 1 2 3 int gcd(int a,int b){ return b == 0? a : gcd(b, a % b); } 扩展欧几里得 任务 求出A,B的最大公约数，且求出X,Y满足AX+BY=GCD(A,B)。\n说明 要求X,Y，满足：AX+BY=GCD(A,B)。 当B=0时，有X=1，Y=0时等式成立。 当B\u0026gt;0时，在欧几里得算法的基础上，已知： GCD(A,B)=GCD(B,A mod B) 先递归楸树X’,Y’满足： BX’+(A mod B)Y’ = GCD(B,A mod B) = GCD(A,B) 然后可以回推，我们将上式化简得： BX’+(A-A/B*B)Y’=GCD(A,B) AY’+BX’-(A/B)BY’=GCD(A,B) 这里除法指整除。把含B的因式提取一个B，可得： AY’+B(X’-A/BY’)=GCD(A,B) 故X=Y’，Y=X’-A/B\u0026amp;Y’\n程序 int extend_gcd(int a,int b,int \u0026amp;x,int \u0026amp;y);\n复杂度 O(logN)，其中N和a，b同阶\n输入 a，b两个整数 \u0026amp;x,\u0026amp;y引用，ax+by=GCD(a,b)的一组解\n输出 a，b的最大公约数 调用后x，y满足方程ax+by=GCD(a,b)。\n代码 1 2 3 4 5 6 7 8 9 10 11 int extend_gcd(int a,int b,int \u0026amp;x,int \u0026amp;y) { if(b==0) { x=1; y=0; return a; } else { int r=extend_gcd(b,a%b,y,x); y-=x*(a/b); return r; } } 参考文章 ACM国际大学生程序设计竞赛：算法与实现 百度百科\n","date":"2016-07-21T15:08:12+08:00","permalink":"https://boiltask.com/knowledge/extended-gcd/","title":"欧几里得——GCD引发的讨论"},{"content":"问题描述 上三角矩阵的判断\r时间限制：1 Sec内存限制：128 MB\rDescription 编写程序，输入一个正整数n（1\u0026lt;=n\u0026lt;=10）和n阶方阵a中的元素，如果a是上三角矩阵，输出“YES”，否则，输出“NO\u0026quot;。 上三角矩阵即主对角线以下（不包括主对角线）的元素都为0的矩阵，主对角线为从矩阵的左上角至右下角的连线。 要求定义函数IsUpperTriMatrixO判断矩阵a是否是上三角矩阵，如果是返回1，否则返回0。函数原型如下： IsUpperTriMatrix(int a, int n);\nInput 输入一个正整数n（1\u0026lt;=n\u0026lt;=10）和n阶方阵a中的元素，均为整数。\nOutput 如果a是上三角矩阵，输出“YES\u0026quot;，否则，输出“NO”\nSample Input 1 2 3 4 5 4 1 2 3 4 0 2 2 2 0 0 3 4 0 0 0 4 Sample Output 1 YES 问题分析 题目解释了一下什么叫上三角矩阵 判断本身没什么难度\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include\u0026lt;stdio.h\u0026gt; int n; int map[12][12]; bool IsUpperTriMatrix() { for(int i=1; i\u0026lt;n; i++) for(int j=0; j\u0026lt;i; j++) if(map[i][j]) return false; return true; } int main() { while(scanf(\u0026#34;%d\u0026#34;,\u0026amp;n)!=EOF) { for(int i=0; i\u0026lt;n; i++) for(int j=0; j\u0026lt;n; j++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;map[i][j]); printf(\u0026#34;%s\\n\u0026#34;,IsUpperTriMatrix()?\u0026#34;YES\u0026#34;:\u0026#34;NO\u0026#34;); } return 0; } 题目地址:【郑轻】[1125]上三角矩阵的判断\n","date":"2016-07-20T23:29:42+08:00","permalink":"https://boiltask.com/oj/zzuli/1125/","title":"【郑轻】[1125]上三角矩阵的判断"},{"content":"问题描述 矩阵乘积\r时间限制：1 Sec内存限制：128 MB\rDescription 计算两个矩阵A和B的乘积。\nInput 第一行三个正整数m、p和n，0\u0026lt;=m,n,p\u0026lt;=10，表示矩阵A是m行p列，矩阵B是p行n列； 接下来的m行是矩阵A的内容，每行p个整数，用空格隔开； 最后的p行是矩阵B的内容，每行n个整数，用空格隔开。\nOutput 输出乘积矩阵：输出占m行，每行n个数据，以空格隔开。\nSample Input 1 2 3 4 5 6 7 8 2 3 4 1 0 1 0 0 1 1 1 1 3 4 5 6 7 8 9 1 0 Sample Output 1 2 9 10 2 3 8 9 1 0 问题分析 矩阵乘法：\n结果矩阵第m行与第n列交叉位置的那个值，等于第一个矩阵第m行与第二个矩阵第n列，对应位置的每个值的乘积之和。\n理解矩阵乘法 - 阮一峰的网络日志\n如果用数组硬算也可以\n但是这里写的高级一点\n用结构体重载运算符\n进而可以直接进行结构体乘法运算\n然后直接输出就行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include\u0026lt;stdio.h\u0026gt; int n; int map[12][12]; bool IsUpperTriMatrix() { for(int i=1; i\u0026lt;n; i++) for(int j=0; j\u0026lt;i; j++) if(map[i][j]) return false; return true; } int main() { while(scanf(\u0026#34;%d\u0026#34;,\u0026amp;n)!=EOF) { for(int i=0; i\u0026lt;n; i++) for(int j=0; j\u0026lt;n; j++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;map[i][j]); printf(\u0026#34;%s\\n\u0026#34;,IsUpperTriMatrix()?\u0026#34;YES\u0026#34;:\u0026#34;NO\u0026#34;); } return 0; } 题目地址:【郑轻】[1125]上三角矩阵的判断\n","date":"2016-07-20T23:02:37+08:00","permalink":"https://boiltask.com/oj/zzuli/1127/","title":"【郑轻】[1127]矩阵乘积"},{"content":"问题描述 汉诺塔VII\r[hdu-1997] [3122595692095457] @vjudge\r问题分析 （1）首先判断是不是已经完全放好了或者还没有开始移动，这样就不用考虑是否最优化了，即所有的盘子在C柱上或者所有的盘子在A柱上，这样是合法的，直接输出true。\n（2）【我们考虑盘号最大的盘子第n号盘子，移动方向为A–\u0026gt;C，它只可能在A柱或者C柱上，如果在B柱上我们可以直接返回false–①】；\n如果盘号最大的盘子在A柱上，说明其它盘子正在进行A–\u0026gt;B的操作，所以考虑移动的那个n-1个盘子，然后同样按①判断，只不过，最大盘号变成了n-1，而移动方向变成了A–\u0026gt;B；\n如果盘号最大的盘子在C柱上，说明其它盘子正在进行B–\u0026gt;C的操作，所以考虑移动的那个n-1个盘子，然后同样按①判断，只不过，最大盘号变成了n-1，而移动方向变成了B–\u0026gt;C；\n利用递归按这种方式不断地进行①操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include\u0026lt;stdio.h\u0026gt; int map[4][100]; int f(int a,int b) { if(a==1) return b==2?3:2; if(a==2) return b==1?3:1; if(a==3) return b==1?2:1; } bool judge(int n,int t1,int t2) { if(n==0) return true; for(int i=0; i\u0026lt;map[0][f(t1,t2)]; i++) if(map[f(t1,t2)][i]==n) return false; for(int i=0; i\u0026lt;map[0][t1]; i++) if(map[t1][i]==n) return judge(n-1,f(t1,t2),t1); for(int i=0; i\u0026lt;map[0][t2]; i++) if(map[t2][i]==n) return judge(n-1,f(t1,t2),t2); } int main() { int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); scanf(\u0026#34;%d\u0026#34;,\u0026amp;map[0][1]); for(int i=0; i\u0026lt;map[0][1]; i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;map[1][i]); scanf(\u0026#34;%d\u0026#34;,\u0026amp;map[0][2]); for(int i=0; i\u0026lt;map[0][2]; i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;map[2][i]); scanf(\u0026#34;%d\u0026#34;,\u0026amp;map[0][3]); for(int i=0; i\u0026lt;map[0][3]; i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;map[3][i]); printf(\u0026#34;%s\\n\u0026#34;,judge(n,1,3)?\u0026#34;true\u0026#34;:\u0026#34;false\u0026#34;); } return 0; } ","date":"2016-07-20T10:25:43+08:00","permalink":"https://boiltask.com/oj/hdu/1997/","title":"【杭电】[1997]汉诺塔VII"},{"content":"问题描述 the Sum of Cube\r[hdu-5053] [3284834361055368] @vjudge\r问题分析 签到水题\n直接循环计算就好\n注意数据范围和中间过程溢出\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include\u0026lt;stdio.h\u0026gt; int main() { int T,kase=0; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { int a,b; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a,\u0026amp;b); __int64 sum=0; for(int i=a; i\u0026lt;=b; i++) sum+=(__int64)i*i*i; printf(\u0026#34;Case #%d: %I64d\\n\u0026#34;,++kase,sum); } return 0; } ","date":"2016-07-20T10:21:05+08:00","permalink":"https://boiltask.com/oj/hdu/5053/","title":"【杭电】[5053]the Sum of Cube"},{"content":"问题描述 又见GCD\r[hdu-2504] [3124371655819235] @vjudge\r问题分析 可以暴力查找\n但是可以根据题意优化\nc一定是b的倍数\n所以每一次可把i+=b\n因为c！=b\n所以初始条件可以把i=b+b\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include\u0026lt;stdio.h\u0026gt; int gcd(int a,int b) { if(b==0) return a; return gcd(b,a%b); } int main() { int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { int a,b; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a,\u0026amp;b); for(int i=b+b; i\u0026lt;1000000; i+=b) if(gcd(a,i)==b) { printf(\u0026#34;%d\\n\u0026#34;,i); break; } } return 0; } ","date":"2016-07-20T10:18:20+08:00","permalink":"https://boiltask.com/oj/hdu/2504/","title":"【杭电】[2504]又见GCD"},{"content":"问题描述 Cake\r[hdu-1722] [3224237816890421] @vjudge\r问题分析 其实找规律可以想出来\n规律可以这么解释:如果要能把它分为等值的p份或q份,那么我们可以先分为d(最大公约数)=gcd(p,q)份,因为当你分为d份的时候,你可能选择将每份分为p/d份(也就是把整体分为p份),也可以选择将每份分为q/d份(也就是把整体分为p份),这两种选择里,肯定不会有切到相同位置的一刀!所以我们可以得到公式:s=p+q-gcd(p,q);\n1 2 3 4 5 6 7 8 9 10 11 12 #include\u0026lt;stdio.h\u0026gt; int gcd(int a,int b) { if(b==0) return a; return gcd(b,a%b); } int main() { int n,m; while(scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m)!=EOF) printf(\u0026#34;%d\\n\u0026#34;,n+m-gcd(n,m)); return 0; } ","date":"2016-07-20T10:12:51+08:00","permalink":"https://boiltask.com/oj/hdu/1722/","title":"【杭电】[1722]Cake"},{"content":"问题描述 Wolf and Rabbit\r[hdu-1222] [3157029628831946] @vjudge\r问题分析 因为是个循环的过程\n所以如果两个数最大公约数为1的话\n狼就可以抓到兔子\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include\u0026lt;stdio.h\u0026gt; int gcd(int a,int b) { if(b==0) return a; return gcd(b,a%b); } int main() { int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { int n,m; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m); printf(\u0026#34;%s\\n\u0026#34;,gcd(n,m)==1?\u0026#34;NO\u0026#34;:\u0026#34;YES\u0026#34;); } return 0; } ","date":"2016-07-20T10:10:12+08:00","permalink":"https://boiltask.com/oj/hdu/1222/","title":"【杭电】[1222]Wolf and Rabbit"},{"content":"问题描述 问题分析 需要注意问的是存不存在\n而不是能不能在k场内完成\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include\u0026lt;stdio.h\u0026gt; int n,k; bool judge() { for(int i=1; i\u0026lt;=n/2; i++) { if(i*(n-i)==k) return true; } return false; } int main() { while(scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;k),n||k) printf(\u0026#34;%s\\n\u0026#34;,judge()?\u0026#34;YES\u0026#34;:\u0026#34;NO\u0026#34;); return 0; } ","date":"2016-07-19T16:26:22+08:00","permalink":"https://boiltask.com/oj/nyoj/1769/","title":"【NYOJ】[1769]对决"},{"content":"问题描述 问题分析 题目说不要求排序\n其实就是按照区域首次出现的先后输出\n所以可以另开一个数组进行记录\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; int a[120],b[120]; int main() { int cnt=0; memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); int n,m; while(scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m),n||m) { if(b[n]) b[n]+=m; else { a[cnt++]=n; b[n]=m; } } for(int i=0; i\u0026lt;cnt; i++) printf(\u0026#34;%d %d\\n\u0026#34;,a[i],b[a[i]]); return 0; } ","date":"2016-07-19T15:59:51+08:00","permalink":"https://boiltask.com/oj/nyoj/1799/","title":"【NYOJ】[1799]无主之地1"},{"content":"问题描述 Hot or Cold?\r[uva-1524] [3226176764000018] @vjudge\r问题分析 多项式的积分问题\n算出积分后除以所用时间\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;math.h\u0026gt; double a[120]; double f(int n,double m) { double sum=0; for(int i=0; i\u0026lt;=n; i++) { sum+=(double)pow(m,(double)(i+1))*a[i]/(i+1); } return sum; } int main() { int n; while(scanf(\u0026#34;%d\u0026#34;,\u0026amp;n),n) { for(int i=n; i\u0026gt;=0; i--) scanf(\u0026#34;%lf\u0026#34;,\u0026amp;a[i]); double s,e; scanf(\u0026#34;%lf %lf\u0026#34;,\u0026amp;s,\u0026amp;e); printf(\u0026#34;%.3lf\\n\u0026#34;,(f(n,e)-f(n,s))/(e-s)); } return 0; } ","date":"2016-07-19T10:53:56+08:00","permalink":"https://boiltask.com/oj/uva/1524/","title":"【UVa】[1524]Hot or Cold?"},{"content":"问题描述 IQ test\r[codeforces-25A] [3110617126089256] @vjudge\r问题分析 找出一串数中唯一的奇数或者偶数的坐标\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include\u0026lt;stdio.h\u0026gt; int a[120]; int n; void solve() { int cnt1=0,cnt2=0; for(int i=1; i\u0026lt;=n; i++) { if(a[i]\u0026amp;1) cnt1++; else cnt2++; if(cnt1\u0026gt;1\u0026amp;\u0026amp;i\u0026gt;cnt1) for(int i=1; i\u0026lt;=n; i++) if(a[i]%2==0) { printf(\u0026#34;%d\\n\u0026#34;,i); return ; } if(cnt2\u0026gt;1\u0026amp;\u0026amp;i\u0026gt;cnt2) for(int i=1; i\u0026lt;=n; i++) if(a[i]\u0026amp;1) { printf(\u0026#34;%d\\n\u0026#34;,i); return ; } } return ; } int main() { while(scanf(\u0026#34;%d\u0026#34;,\u0026amp;n)!=EOF) { for(int i=1; i\u0026lt;=n; i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]); solve(); } return 0; } ","date":"2016-07-18T21:31:29+08:00","permalink":"https://boiltask.com/oj/codeforces/25A/","title":"【CodeForces】[25A]IQ test"},{"content":"问题描述 括号配对问题\r时间限制：3000 ms内存限制：128 MB\r描述 现在，有一行括号序列，请你检查这行括号是否配对。\n输入 第一行输入一个数N（0\u0026lt;N\u0026lt;=100），表示有N组测试数据。后面的N行输入多组输入数据，每组输入数据都是一个字符串S（S的长度小于10000，且S不是空串），测试数据组数少于5组。数据保证S中只含有\u0026quot;[\u0026quot;，\u0026quot;]\u0026quot;，\u0026quot;(\u0026quot;，\u0026quot;)\u0026quot; 四种字符\n输出 每组输入数据的输出占一行，如果该字符串中所含的括号是配对的，则输出Yes,如果不配对则输出\n样例输入 1 2 3 4 3 [(]) (]) ([[]()]) 样例输出 1 2 3 No No Yes 题目来源 括号配对问题 - NYOJ\n问题分析 用栈来检测是否对应\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; #include\u0026lt;stack\u0026gt; using namespace std; char s[10200]; stack\u0026lt;char\u0026gt;q; bool judge(char a,char b) { if(a==\u0026#39;(\u0026#39;\u0026amp;\u0026amp;b==\u0026#39;)\u0026#39;) return false; if(a==\u0026#39;[\u0026#39;\u0026amp;\u0026amp;b==\u0026#39;]\u0026#39;) return false; return true; } int main() { int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { scanf(\u0026#34;%s\u0026#34;,s); int l=strlen(s); bool flag=true; while(!q.empty()) q.pop(); for(int i=0; i\u0026lt;l; i++) { if(!flag) continue; if(s[i]==\u0026#39;[\u0026#39;||s[i]==\u0026#39;(\u0026#39;) q.push(s[i]); else { if(q.empty()||judge(q.top(),s[i])) flag=false; else q.pop(); } } printf(\u0026#34;%s\\n\u0026#34;,flag?\u0026#34;Yes\u0026#34;:\u0026#34;No\u0026#34;); } return 0; } ","date":"2016-07-18T20:21:16+08:00","permalink":"https://boiltask.com/oj/nyoj/v1-2/","title":"【NYOJ】[v1-2]括号配对问题"},{"content":"问题描述 问题分析 大数运算使用字符串模拟\n在斐波那契数列中是对大数的多次想加\n为了方便编写函数所以可以使用string类型\n函数完成后只需像正常求数列那样调用即可\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; #include\u0026lt;cstring\u0026gt; using namespace std; string F[1020]= {\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;}; string add(string a,string b) { a=\u0026#34;0\u0026#34;+a; int la=a.length(); int lb=b.length(); for(int i=1; i\u0026lt;=la; i++) { if(lb-i\u0026gt;=0) a[la-i]+=b[lb-i]-\u0026#39;0\u0026#39;; if(a[la-i]-\u0026#39;0\u0026#39;\u0026gt;9) { a[la-i]-=10; a[la-i-1]++; } } while(a[0]==\u0026#39;0\u0026#39;) a.erase(0,1); return a; } int main() { for(int i=3; i\u0026lt;1002; i++) { F[i]=add(F[i-1],F[i-2]); } int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { char s[220]; scanf(\u0026#34;%s\u0026#34;,\u0026amp;s); cout\u0026lt;\u0026lt;F[strlen(s)]\u0026lt;\u0026lt;endl; } return 0; } ","date":"2016-07-18T12:02:49+08:00","permalink":"https://boiltask.com/oj/hdu/1715/","title":"【杭电】[1715]大菲波数"},{"content":"问题示例:\nN台计算机K个任务，各个计算机可以处理的任务种类不同，最多能处理多少任务\n过山车每个女生只愿与某几个男生相邻，求最多能安排几对\n匈牙利算法\n参考资料\n《挑战程序设计竞赛》\n《算法竞赛入门经典》\n匈牙利算法_百度百科\n趣写算法系列之–匈牙利算法\n","date":"2016-04-01T07:07:18+08:00","permalink":"https://boiltask.com/knowledge/bipartite-graph/","title":"二分图——集合中匹配另一集合中数个"},{"content":"简介 在数论，对正整数n，欧拉函数是小于n的数中与n互质的数的数目。此函数以其首名研究者欧拉命名(Ruler\u0026rsquo;so totient function)，它又称为Euler\u0026rsquo;s totient function、φ函数、欧拉商数等。 例如φ(8)=4，因为1,3,5,7均和8互质。 从欧拉函数引伸出来在环论方面的事实和拉格朗日定理构成了欧拉定理的证明。\n性质 $\\varphi \\left( x\\right) =x\\left( 1-\\dfrac{1}{p_{1}}\\right) \\left( 1-\\dfrac{1}{p_{2}}\\right) \\ldots \\left( 1-\\dfrac{1}{p_{n}}\\right)$\n若n是质数p的k次幂\n$\\varphi \\left( n\\right) =p^{k}-p^{k-1}$\n(因为除了p的倍数外，其他数都跟n互质)\n若n为质数则\n$\\varphi \\left( n\\right) = n-1$\n这些定理是筛法求欧拉函数的基础\n算法写法 直接求解 1 2 3 4 5 6 7 8 9 10 11 12 int euler(int n){ //返回euler(n) int res=n,a=n; for(int i=2;i*i\u0026lt;=a;i++){ if(a%i==0){ res=res/i*(i-1);//先进行除法是为了防止中间数据的溢出 while(a%i==0) a/=i; } } if(a\u0026gt;1) res=res/a*(a-1); return res; } 筛法 1 2 3 4 5 6 7 8 9 10 long long a[1000020]; memset(a,0,sizeof(a)); a[1]=1; for(int i=2; i\u0026lt;1000020; i++) if(!a[i]) for(int j=i; j\u0026lt;1000020; j+=i) { if(!a[j]) a[j]=j; a[j]=a[j]/i*(i-1); } 参考资料:\n欧拉函数_百度百科\n欧拉函数线性筛法\n欧拉函数_Lur \u0026rsquo;s acm blog\n","date":"2016-03-26T08:17:46+08:00","permalink":"https://boiltask.com/knowledge/eulers-totient-function/","title":"欧拉函数——小于n的数中与n互质数的数目"},{"content":"错排问题也是见过许多次了\n每一次都感觉到无从下手\n不过这次找了个时间专门研究了一下\n【杭电】[2048]神、上帝以及老天爷\n百度百科:\n全错位排列——百度百科\n错排公式——百度百科\n错位重排——百度百科\n核心递归公式\nf(n)=(n-1) {f(n-1)+f(n-2)}\n方法一：\nn各有序的元素应有n！种不同的排列。如若一个排列式的所有的元素都不在原来的位置上，则称这个排列为错排。任给一个n，求出1,2,……,n的错排个数Dn共有多少个。\n递归关系式为：D(n)=(n-1)(D(n-1)+D(n-2))\nD(1)=0,D(2)=1\n可以得到:\n错排公式为 f(n) = n![1-1/1!+1/2!-1/3!+……+(-1)^n1/n!]\n其中,n!=123\u0026hellip;..*n,\n特别地,有0!=0,1!=1.\n解释：\nn 个不同元素的一个错排可由下述两个步骤完成：\n第一步，“错排” 1 号元素（将 1 号元素排在第 2 至第 n 个位置之一），有 n - 1 种方法。\n第二步，“错排”其余 n - 1 个元素，按如下顺序进行。视第一步的结果，若1号元素落在第 k 个位 置，第二步就先把 k 号元素“错排”好， k 号元素的不同排法将导致两类不同的情况发生：\n1、 k 号元素排在第1个位置，留下的 n - 2 个元素在与它们的编号集相等的位置集上“错排”，有 f(n -2) 种方法；\n2、 k 号元素不排第 1 个位置，这时可将第 1 个位置“看成”第 k 个位置(也就是说本来准备放到k位置为元素，可以放到1位置中),于是形成（包括 k 号元素在内的） n - 1 个元素的“错排”，有 f(n - 1) 种方法。据加法原理，完成第二步共有 f(n - 2)+f(n - 1) 种方法。\n根据乘法原理， n 个不同元素的错排种数\nf(n) = (n-1)[f(n-2)+f(n-1)] (n\u0026gt;2) 。\n证毕。\n","date":"2016-03-02T22:32:11+08:00","permalink":"https://boiltask.com/knowledge/derangement/","title":"错排——错误引发的讨论"},{"content":"问题描述 神、上帝以及老天爷\r[hdu-2048] [3151831946608367] @vjudge\r问题分析 错排问题\n也就是\na[i]=(i-1)*(a[i-1]+a[i-2])\n这里涉及到阶乘\n也不想换数据类型了\n所以由规律知加了一个判断\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include\u0026lt;stdio.h\u0026gt; int j(int m) { if(m==1) return 1; else return m*j(m-1); } int main() { int a[15]= {0,0,1}; for(int i=3; i\u0026lt;13; i++) { a[i]=(i-1)*(a[i-1]+a[i-2]); } int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); if(n\u0026lt;13) printf(\u0026#34;%.2lf%%\\n\u0026#34;,a[n]*100.0/j(n)); else printf(\u0026#34;36.79%%\\n\u0026#34;); } return 0; } 题目地址:【杭电】[2048]神、上帝以及老天爷\n","date":"2016-03-02T22:25:07+08:00","permalink":"https://boiltask.com/oj/hdu/2048/","title":"【杭电】[2048]神、上帝以及老天爷"},{"content":"问题描述 问题分析 去重后进行排序\n写的时候用了sort\n然后排序后去重\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; int main() { int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { int a[120]; int b[120]; int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]); sort(a,a+n); b[0]=a[0]; int cnt=1; for(int i=1; i\u0026lt;n; i++) { if(a[i]!=a[i-1]) { b[cnt++]=a[i]; } } printf(\u0026#34;%d\\n\u0026#34;,cnt); for(int i=0; i\u0026lt;cnt; i++) { printf(\u0026#34;%d\u0026#34;,b[i]); if(i==cnt-1) printf(\u0026#34;\\n\u0026#34;); else printf(\u0026#34; \u0026#34;); } } return 0; } ","date":"2016-02-21T04:05:15+08:00","permalink":"https://boiltask.com/oj/nyoj/1254/","title":"【NYOJ】[1254]C小加 之 随机数"},{"content":"问题介绍 一个无向图，如果某个子图中任意两个定点都互相连通并且是一棵树，那么这棵树就叫做生成树。如果边上有权值，那么使得边权和最小的生成树叫做最小生成树。\n常用算法 Prim算法 找一个起始点加入树，对所有点寻找到到树的距离，从中选择最小的加入树，再次更新距离，从中寻找最小的，直到所有点都加入树。\nKruskal算法 对权值进行排序，然后从小到大进行判断，如果加入这条边，不成环则是所求树的边。\n(结合并查集)\n参考文章: 《算法竞赛入门经典》\n《挑战程序设计竞赛》\n最小生成树-Prim算法和Kruskal算法\n","date":"2016-02-20T00:16:16+08:00","permalink":"https://boiltask.com/knowledge/minimum-spanning-tree/","title":"最小生成树——所有点成树有最小总权和"},{"content":"单源最短路问题 求解一个点到其它所有点的最短路的问题\n用BFS求最短路 《算法竞赛入门经典》\n第六章数据结构基础之图部分——zzyafyj的专栏\nDijkstra算法 【坐在马桶上看算法】算法7：Dijkstra最短路算法\n我们发现dis[3]=12，dis[2]+e[2][3]=1+9=10，dis[3]\u0026gt;dis[2]+e[2][3]，因此dis[3]要更新为10。这个过程有个专业术语叫做“松弛”。即1号顶点到3号顶点的路程即dis[3]，通过2-\u0026gt;3这条边松弛成功。这便是Dijkstra算法的主要思想：通过“边”来松弛1号顶点到其余各个顶点的路程。\n每次找到离源点（上面例子的源点就是1号顶点）最近的一个顶点，然后以该顶点为中心进行扩展，最终得到源点到其余所有点的最短路径。\n任意两点间的最短路问题 求解所有两点间的最短路的问题\nFloyd-Warshall算法 坐在马桶上看算法：只有五行的Floyd最短路算法\n最开始只允许经过1号顶点进行中转，接下来只允许经过1和2号顶点进行中转……允许经过1~n号所有顶点进行中转，求任意两点之间的最短路程。用一句话概括就是：从i号顶点到j号顶点只经过前k号点的最短路程。\n参考文章:\n《挑战程序设计竞赛》\n坐在马桶上看算法：只有五行的Floyd最短路算法\n【坐在马桶上看算法】算法7：Dijkstra最短路算法\n","date":"2016-02-17T14:49:25+08:00","permalink":"https://boiltask.com/knowledge/shortest-path/","title":"最短路——两点最短总权和"},{"content":"过个年过的还是有点颓废\n而且越看这些越觉得没有数据结构等那些作为基础，强行研究并查集、最小生成树这些也是一路艰辛啊。\n其实本来应该是已经要学的基础知识，不过还是浪费了好多时间啊，想想这部分还是要把重心放在上面，不能心态太功利地去强行理解。\n然后刚才也是清了清“占个位置”分类的题，突然发觉QQ空间火在了它的“说说”板块，想想，要不以后有必要在CSDN开设一个专门给我这个话唠的“说说”。要不就专门写个博文，然后做个分类，然后想说就编辑一下文章在下面继续说，感觉这个形式不错哎~哈哈哈哈\n所以中心思想，广涉猎一些基础知识，然后慢慢地填充吧。\n","date":"2016-02-13T00:17:11+08:00","permalink":"https://boiltask.com/record/201602131/","title":"颓废良久了"},{"content":" 20250405：指的是CSDN上的第200篇博文，不太好用，放弃CSDN很久了……\n据说200是个槛\n先打个点~\n以后想起来了这一篇再来编辑一下\n以此来说说吧~\n哈哈哈哈\n===========2016.02.02-03:10===========\n","date":"2016-02-02T03:11:09+08:00","permalink":"https://boiltask.com/record/201602021/","title":"这是第200篇博文"},{"content":"问题描述 问题分析 使用了结构体\n并用sort进行了排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; struct sh { int n,l,b; } a[1020]; bool vs(sh A,sh B) { if(A.n!=B.n) { return A.n\u0026lt;B.n; } else { if(A.l!=B.l) return A.l\u0026lt;B.l; else return A.b\u0026lt;B.b; } } int main() { int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { int m; scanf(\u0026#34;%d\u0026#34;,\u0026amp;m); for(int i=0; i\u0026lt;m; i++) { scanf(\u0026#34;%d %d %d\u0026#34;,\u0026amp;a[i].n,\u0026amp;a[i].l,\u0026amp;a[i].b); if(a[i].l\u0026lt;a[i].b) { int t=a[i].l; a[i].l=a[i].b; a[i].b=t; } } sort(a,a+m,vs); int tn=0,tl=0,tb=0; for(int i=0; i\u0026lt;m; i++) { if(tn!=a[i].n||tl!=a[i].l||tb!=a[i].b) printf(\u0026#34;%d %d %d\\n\u0026#34;,a[i].n,a[i].l,a[i].b); tn=a[i].n; tl=a[i].l; tb=a[i].b; } } return 0; } ","date":"2016-02-02T03:08:40+08:00","permalink":"https://boiltask.com/oj/nyoj/1008/","title":"【NYOJ】[1008]一种排序"},{"content":"问题描述 字母统计\r时间限制：3000 ms内存限制：64 MB\r描述 现在给你一个由小写字母组成字符串，要你找出字符串中出现次数最多的字母，如果出现次数最多字母有多个那 么输出最小的那个。\n输入 第一行输入一个正整数T（0\u0026lt;T\u0026lt;25） 随后T行输入一个字符串s,S长度小于1010。\n输出 每组数据输出占一行，输出出现次数最多的字符；\n样例输入 1 2 3 abcd bbaa jsdhfjkshdfjksahdfjkhsajkf 样例输出 1 2 3 a a j 问题分析 今天大脑不在状态\n就随便水水好了……\n用一个数组来记录字母数\n然后来寻找次数最多的那一个下标\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; int main() { int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { int a[26]; memset(a,0,sizeof(a)); char s[1020]; scanf(\u0026#34;%s\u0026#34;,s); for(int i=0; i\u0026lt;strlen(s); i++) { a[s[i]-\u0026#39;a\u0026#39;]++; } int maxi=0; for(int i=0; i\u0026lt;26; i++) { if(a[i]\u0026gt;a[maxi]) maxi=i; } printf(\u0026#34;%c\\n\u0026#34;,maxi+\u0026#39;a\u0026#39;); } return 0; } 标程的思路一样~\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; main() { int x,i,max,q; char a[1011]; scanf(\u0026#34;%d\u0026#34;,\u0026amp;x); getchar(); while(x--) { int s[26]= {0}; gets(a); for(i=strlen(a)-1; i\u0026gt;=0; i--) s[a[i]-97]++; max=0; for(i=0; i\u0026lt;26; i++) if(max\u0026lt;s[i]) max=s[i],q=i; printf(\u0026#34;%c\\n\u0026#34;,q+97); } } ","date":"2016-01-31T23:52:25+08:00","permalink":"https://boiltask.com/oj/nyoj/v1-243/","title":"【NYOJ】[v1-243]字母统计"},{"content":"问题描述 无线网络覆盖\r问题分析 乍一看有点难\n但仔细想一想\n题目还是挺简单的\n一些限制条件在那呢\n规定路由器只能在中间\n所以要求直径需大于宽\n同时 R\u0026gt;=1 D\u0026gt;=1 L\u0026gt;=1 保证了 只要直径大于宽 那么就一定有结果\n所用路由器个数取决与于边缘的长度\n既等于图中左下角到下方两圆交点的那一段长度\n$$ l = \\sqrt{(2R)^2 - D^2}$$再使用 ceil() 来向上取整数\n所以代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;math.h\u0026gt; int main() { int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { double L,D,R; scanf(\u0026#34;%lf %lf %lf\u0026#34;,\u0026amp;L,\u0026amp;D,\u0026amp;R); if(2*R\u0026lt;=D) printf(\u0026#34;impossible\\n\u0026#34;); else printf(\u0026#34;%.lf\\n\u0026#34;,ceil(L/sqrt(4*R*R-D*D))); } return 0; } 标程可以说和我一样了~\n嗯……\n或许应该说我和标程一样~\n哈哈哈 无所谓啦\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;math.h\u0026gt; int main() { int T; double L,D,R,a; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { scanf(\u0026#34;%lf%lf%lf\u0026#34;,\u0026amp;L,\u0026amp;D,\u0026amp;R); a=4*R*R-D*D; if(a\u0026gt;0)printf(\u0026#34;%.0lf\\n\u0026#34;,ceil(L/sqrt(a))); else puts(\u0026#34;impossible\u0026#34;); } } ","date":"2016-01-31T02:18:16+08:00","permalink":"https://boiltask.com/oj/nyoj/1198/","title":"【NYOJ】[1198]无线网络覆盖"},{"content":"问题描述 数数\r问题分析 题目不难\n自认为巧妙的一点是用字符串储存了对应关系\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; int main() { char word[]= {\u0026#34;OOTTFFSSEN\u0026#34;}; int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { char s[15]; scanf(\u0026#34;%s\u0026#34;,s); for(int i=strlen(s)-1; i\u0026gt;=0; i--) { printf(\u0026#34;%c\u0026#34;,word[s[i]-\u0026#39;0\u0026#39;]); } printf(\u0026#34;\\n\u0026#34;); } return 0; } 标程还是使用数字来储存的输入数据\n然后puts(\u0026quot;\u0026quot;);用来输出换行\n(……虽然现在不知道为什么能这样)\n思路还是一样的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include\u0026lt;cstdio\u0026gt; char str[]=\u0026#34;OOTTFFSSENT\u0026#34;; void show(int t) { if(t) { putchar(*(str+t%10)); show(t/10); } } int main() { int n,t; scanf(\u0026#34;%d\u0026#34;,\u0026amp;t); while(t--) { scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); show(n); puts(\u0026#34;\u0026#34;); } } ","date":"2016-01-31T01:42:59+08:00","permalink":"https://boiltask.com/oj/nyoj/1197/","title":"【NYOJ】[1197]数数"},{"content":"问题描述 素数\r时间限制：3000 ms内存限制：64 MB\r描述 走进世博园某信息通信馆，参观者将获得前所未有的尖端互动体验，一场充满创想和喜悦的信息通信互动体验秀将以全新形式呈现，从观众踏入展馆的第一步起，就将与手持终端密不可分，人类未来梦想的惊喜从参观者的掌上展开。\n在等候区的梦想花园中，参观者便开始了他们奇妙的体验之旅，等待中的游客可利用手机等终端参与互动小游戏，与梦想剧场内的虚拟人物Kr.Kong进行猜数比赛。当屏幕出现一个整数X时，若你能比Kr.Kong更快的发出最接近它的素数答案，你将会获得一个意想不到的礼物。\n例如：当屏幕出现22时，你的回答应是23；当屏幕出现8时，你的回答应是7；若X本身是素数，则回答X；若最接近X的素数有两个时，则回答大于它的素数。\n输入 第一行：N要竞猜的整数个数 接下来有N行，每行有一个正整数X 1\u0026lt;=N\u0026lt;=5 1\u0026lt;=X\u0026lt;=1000\n输出 输出有N行，每行是对应X的最接近它的素数\n样例输入 1 2 3 4 5 4 22 5 18 8 样例输出 1 2 3 4 23 5 19 7 问题分析 和素数距离问题基本类似\n那个好像还比这个稍微难一些\n不过鉴于是省赛的一道题目\n所以还是再来写一遍吧\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include\u0026lt;stdio.h\u0026gt; int a[1020]= {1,1}; int main() { for(int i=2; i\u0026lt;1020; i++) { if(!a[i]) { for(int j=i+i; j\u0026lt;1020; j+=i) { a[j]=1; } } } int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { int m; scanf(\u0026#34;%d\u0026#34;,\u0026amp;m); int t1=m,sum1=0; while(a[t1]) { sum1++; t1--; } int t2=m,sum2=0; while(a[t2]) { sum2++; t2++; } if(sum1\u0026lt;sum2) printf(\u0026#34;%d\\n\u0026#34;,t1); else printf(\u0026#34;%d\\n\u0026#34;,t2); } return 0; } 标程竟然无耻的把1000以内的素数都直接打出来了……\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include\u0026lt;iostream\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; int prime[]= {2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,1009}; int main() { int n,m; cin\u0026gt;\u0026gt;n; while(n--) { cin\u0026gt;\u0026gt;m; if(m==1) { cout\u0026lt;\u0026lt;2\u0026lt;\u0026lt;endl; continue; } int* l=lower_bound(prime,prime+169,m); if(*l-m\u0026lt;=m-*(l-1)) cout\u0026lt;\u0026lt;*l\u0026lt;\u0026lt;endl; else cout\u0026lt;\u0026lt;*(l-1)\u0026lt;\u0026lt;endl; } } ","date":"2016-01-31T01:30:12+08:00","permalink":"https://boiltask.com/oj/nyoj/v1-169/","title":"【NYOJ】[v1-169]素数"},{"content":"问题描述 九九乘法表\r时间限制：1000 ms内存限制：64 MB\r描述 小时候学过的九九乘法表也许将会扎根于我们一生的记忆，现在让我们重温那些温暖的记忆，请编程输出九九乘法表\n现在要求你输出它的格式与平常的不同啊！是那种反过来的三角形啦，具体如下图：\n1 2 3 4 5 6 7 8 9 1*1=1 1*2=2 1*3=3 1*4=4 1*5=5 1*6=6 1*7=7 1*8=8 1*9=9 2*2=4 2*3=6 2*4=8 2*5=10 2*6=12 2*7=14 2*8=16 2*9=18 3*3=9 3*4=12 3*5=15 3*6=18 3*7=21 3*8=24 3*9=27 4*4=16 4*5=20 4*6=24 4*7=28 4*8=32 4*9=36 5*5=25 5*6=30 5*7=35 5*8=40 5*9=45 6*6=36 6*7=42 6*8=48 6*9=54 7*7=49 7*8=56 7*9=63 8*8=64 8*9=72 9*9=81 每两个式子之前用一个空格隔开。。。\n输入 第一有一个整数N，表示有N组数据（N\u0026lt;10） 接下来由N行，每行只有一个整数M（1\u0026lt;=M\u0026lt;=9);\n输出 对应每个整数M，根据要求输出乘法表的前N行，具体格式参见输入输出样例和上图.\n每两组测试数据结果之间有一个空行隔开，具体如输出样例。\n样例输入 1 2 3 4 3 2 1 5 样例输出 1 2 3 4 5 6 7 8 9 10 1*1=1 1*2=2 1*3=3 1*4=4 1*5=5 1*6=6 1*7=7 1*8=8 1*9=9 2*2=4 2*3=6 2*4=8 2*5=10 2*6=12 2*7=14 2*8=16 2*9=18 1*1=1 1*2=2 1*3=3 1*4=4 1*5=5 1*6=6 1*7=7 1*8=8 1*9=9 1*1=1 1*2=2 1*3=3 1*4=4 1*5=5 1*6=6 1*7=7 1*8=8 1*9=9 2*2=4 2*3=6 2*4=8 2*5=10 2*6=12 2*7=14 2*8=16 2*9=18 3*3=9 3*4=12 3*5=15 3*6=18 3*7=21 3*8=24 3*9=27 4*4=16 4*5=20 4*6=24 4*7=28 4*8=32 4*9=36 5*5=25 5*6=30 5*7=35 5*8=40 5*9=45 问题分析 一眼扫过 感觉有趣 就先做了这一题\n先放AC代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include\u0026lt;stdio.h\u0026gt; int main() { int T,flag=0; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); if(flag) printf(\u0026#34;\\n\u0026#34;); flag=1; for(int i=1; i\u0026lt;=n; i++) { for(int j=i; j\u0026lt;=9; j++) { printf(\u0026#34;%d*%d=%d\u0026#34;,i,j,i*j); if(j==9) printf(\u0026#34;\\n\u0026#34;); else printf(\u0026#34; \u0026#34;); } } } return 0; } 其实主要是我突然想起来这种无赖的写法:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include\u0026lt;stdio.h\u0026gt; int main() { char s[9][80]= {\u0026#34;1*1=1 1*2=2 1*3=3 1*4=4 1*5=5 1*6=6 1*7=7 1*8=8 1*9=9\u0026#34;,\u0026#34;2*2=4 2*3=6 2*4=8 2*5=10 2*6=12 2*7=14 2*8=16 2*9=18\u0026#34;,\u0026#34;3*3=9 3*4=12 3*5=15 3*6=18 3*7=21 3*8=24 3*9=27\u0026#34;,\u0026#34;4*4=16 4*5=20 4*6=24 4*7=28 4*8=32 4*9=36\u0026#34;,\u0026#34;5*5=25 5*6=30 5*7=35 5*8=40 5*9=45\u0026#34;,\u0026#34;6*6=36 6*7=42 6*8=48 6*9=54\u0026#34;,\u0026#34;7*7=49 7*8=56 7*9=63\u0026#34;,\u0026#34;8*8=64 8*9=72\u0026#34;,\u0026#34;9*9=81\u0026#34;}; int T,flag=0; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); if(flag) printf(\u0026#34;\\n\u0026#34;); flag=1; for(int i=0; i\u0026lt;n; i++) printf(\u0026#34;%s\\n\u0026#34;,s[i]); } return 0; } 哈哈哈~打表法\n虽然并没有什么卵用\n不过看标程来说\n我对空行的处理还是过于严格了\n不过……\n在下自认为是好习惯~哈哈哈\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include\u0026lt;stdio.h\u0026gt; int main() { int t,n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;t); while(t--) { scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i=1;i\u0026lt;=n;i++){ for(int j=i;j\u0026lt;10;j++) printf(\u0026#34;%d*%d=%d \u0026#34;,i,j,i*j); printf(\u0026#34;\\n\u0026#34;); } } } ","date":"2016-01-31T00:05:05+08:00","permalink":"https://boiltask.com/oj/nyoj/v1-463/","title":"【NYOJ】[v1-463]九九乘法表"},{"content":"问题描述 问题分析 百度NYOJ时发现的一题\n感觉不难就写了\n然后据说是数论里的一题\n运用了抽屉原理\n关于这个以后再详细谈\n就这一题而言\n其实很容易想明白 只要m\u0026gt;n的一半就能YES\n因为是要求找 是都一定存在一组就好\n至于n的奇偶性 则可以举例\n如:\nn=101 m=50\nNO\nn=100 m=50\nNO\nn=99 m=50\nNO\nn=98 m=50\nYES\n所以可以推断出\nAC代码\n1 2 3 4 5 6 7 8 #include\u0026lt;stdio.h\u0026gt; int main() { int n,m; while(scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m)!=EOF) { printf(\u0026#34;%s\\n\u0026#34;,2*m-1\u0026gt;n?\u0026#34;YES\u0026#34;:\u0026#34;NO\u0026#34;) ; } return 0; } ","date":"2016-01-30T23:42:43+08:00","permalink":"https://boiltask.com/oj/nyoj/1409/","title":"【NYOJ】[1409]死神来了"},{"content":"此讨论是关于【NYOJ】[100]1的个数的补充说明\n对于这一题标程给的这一句代码 比较难理解\n所以分开来解析 逗号表达式 while(m)m\u0026amp;=m-1,s++;可以写为:\n1 2 while(m) m\u0026amp;=m-1,s++; 首先是\u0026quot;,\u0026ldquo;所代表的意思\n此处是作为 逗号运算符\n关于逗号运算符:\n逗号运算符可以把两个以上（包含两个）的表达式连接成一个表达式，称为逗号表达式。\n逗号运算符的优先级是所有运算符中级别最低的，通常配合 for 循环使用。\n所以常用的for(i=0,n=1;i\u0026lt;10;i++)\n这种，这个i=0,n=1便是逗号表达式\n对于a + b, c = b, c++这个式子\n逗号表达式最右边的子表达式的值即为逗号表达式的值。上例中，c++ 的值（c 自增之前的值）即为该表达式的值。\n逗号运算符保证左边的子表达式运算结束后才进行右边的子表达式的运算。也就是说，逗号运算符是一个序列点，其左边所有副作用都结束后，才对其右边的子表达式进行运算。因此，上例中，c 得到 b 的值后，才进行自增运算。\n验证程序:\n1 2 3 4 5 6 7 8 9 #include\u0026lt;stdio.h\u0026gt; int main() { int x,a; x=(a=3,6*3); printf(\u0026#34;a=%d,x=%d\\n\u0026#34;,a,x); x=a=3,6*a; printf(\u0026#34;a=%d,x=%d\\n\u0026#34;,a,x); return 0; } 所以while(m)m\u0026amp;=m-1,s++;可看作是两条循环语句\n1 2 m\u0026amp;=m-1; s++; 位运算 s++ 很好理解\n那么m\u0026amp;=m-1;的解释又应该怎么说呢\n\u0026amp;在这里应是按位与\n也就是二进制的数每个位，两个数都是 1这个位才是1\n常用的\nif(a\u0026amp;1) 就相当于如果a是奇数\n因为如果a是奇数 那么最后一位就是1\na\u0026amp;1 结果也应该是1\n如果是偶数 那么a\u0026amp;1==0\n在这里 m\u0026amp;=m-1 =\u0026gt;m=m\u0026amp;m-1\n为什么这样写能计算出1的个数呢\n举例\n5的二进制 101\n则运算过程为\n100\u0026amp;101==100 =\u0026gt;s==1\n100\u0026amp;011==0 =\u0026gt;s==2\n分析\nm\u0026amp;m-1 使得如果最后一位是1\n那么结果便相当于去除了最后以为的1并把结果+1\n如果最后一位是0\n那么其前一个1位在运算后会变成0 并结果+1\n而且使得其自身还是为0\n所以通过这种方式一次一次把1位拨成0位\n然后记录次数\n从而可以得出数字二进制有几个1\n也是二进制运算很奇妙的一种体现\n参考文章:\n《C语言程序设计——贾宗璞 许合利》\nc语言中逗号运算符的功能和使用方法_百度知道\n位运算_百度百科\n","date":"2016-01-30T00:42:22+08:00","permalink":"https://boiltask.com/knowledge/cpp-while-comma-bit/","title":"while(m)m\u0026=m-1,s++;的解释"},{"content":"关于题目~\n嗯……吐槽二字致敬宇神\n然后…咖啡二字 本来想写汗水，结果发现似乎写代码的也流不了多少汗吧，所以换个词语~(虽然咖啡也没大喝的说)\n刚看了几期最强大脑，还是因为郭魏撕逼大战引起的，这个节目似乎以前也听说过，不过因为高中也没什么时间看，所以没大关注，这次来看其实从节目内容来说，其实设计的还是挺不错的，不过因为其它一些原因搞得乱乱哒。\n不过这也承认了-.-我白天确实又颓废了，虽然按照设想我现在应该是两耳不闻窗外事的，不过我想我要承认现实了，这么些年，确实已经把我的热血磨灭的差不多了。或许有段时期我确实是有些天赋的(真是到现在也不愿完全承认我没天赋啊)，不过现在来说，我确实注定无法成为世界顶尖了。\n《最强大脑》这种节目展示的，其实到最后总要面对的，是人与人的天赋确实有一定差异，更何况有天赋也要挖掘啊(还是不愿承认-.-)。自小我自以为是一个挺傲的人，对于失败，或者不如别人的地方，总是想要找出各种理由。小时候看这些挑战，是想着我这方面没什么天赋但不见得其它地方没天赋，更何况那还是因为我没有练过。那现在彻底18了，也没办法在这方面骗自己了，就大脑来说，我自认为还是属于一般的。\n再加上，十多年的人生经历与生活环境，注定我的感性思考还是非常丰富的，文艺风确实会干扰我在很多地方的决定，理性的东西终究没有完全占领我的大脑。这点从到现在都有的排版强迫症什么的都可以看出来，日常生活中也是挺容易感动的一个人，对情感的捕捉也是很敏感。这明显与我心目中的牛逼程序员不符，虽说技术牛逼不一定就是完美，但能力确实是应该被钦佩的东西。嗯……刚删掉了一个最，毕竟还有其它很多也值得钦佩。\n没办法了，无法成为世界上最牛逼的程序员，或许也开创不了一个新高度，但我同样还是热爱这一行业，这是我坚信不疑的。所以，这条道路，在下还是要走，毕竟每一个行业，有标竿，也注定要有基石，我会努力缩短与标杆的差距，嗯……删掉一个努力成为标杆。\n天赋不够，咖啡来凑呗。在下自认天赋现在已经肯定不是顶尖的，估计再过段时间连中等偏上都骗不了自己，要被证实最多一般。但是，为了能做出点什么，也是要在内心告诫自己啊。\n很简单的道理，如果这几年努力了，我今后的日子还有继续努力的机会，如果这几年颓废了，可能今后连努力的机会都没有，能做什么呢？网管？修电脑的？或许最好的结果，真做了一名不起眼的写代码的。到那时候，可能真的想努力都没机会了，没时间了，没精力了。写下这篇文章，若是以后努力了，可以拿来解解闷，要是颓废了，也可以看看来回味从前啊。\n","date":"2016-01-29T15:47:13Z","permalink":"https://boiltask.com/record/talent-or-coffee/","title":"【吐槽】天赋不够 咖啡来凑"},{"content":"问题描述 问题分析 可以用进制转换 然后依次数1的个数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include\u0026lt;stdio.h\u0026gt; int main() { int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { int m,cnt=0; scanf(\u0026#34;%d\u0026#34;,\u0026amp;m); while(m) { if(m%2==1) cnt++; m/=2; } printf(\u0026#34;%d\\n\u0026#34;,cnt); } return 0; } 不过鉴于是二进制\n所以借助C语言的位运算\n可以高效的求出结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include\u0026lt;stdio.h\u0026gt; int main() { int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { int m,cnt=0; scanf(\u0026#34;%d\u0026#34;,\u0026amp;m); while(m) { if(m\u0026amp;1==1) cnt++; m\u0026gt;\u0026gt;=1; } printf(\u0026#34;%d\\n\u0026#34;,cnt); } return 0; } 标程的写法也很有意思\n不是很懂\n脑力有点不足了 明天再来补充吧\n今天就到这了\n后续第二天对于这种写法的补充:\n【看书】while(m)m\u0026amp;=m-1,s++;的解释\n1 2 3 4 5 6 7 8 9 10 11 #include\u0026lt;stdio.h\u0026gt; main() { int n,m,s; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); while(n--) { scanf(\u0026#34;%d\u0026#34;,\u0026amp;m); s=0; while(m)m\u0026amp;=m-1,s++; printf(\u0026#34;%d\\n\u0026#34;,s); } } 题目地址:【NYOJ】[100]1的个数\n","date":"2016-01-29T00:16:35+08:00","permalink":"https://boiltask.com/oj/nyoj/1100/","title":"【NYOJ】[1100]1的个数"},{"content":"在下终于下定决心写第一篇真正意义上算法的理解博文了！\n鼓掌庆祝先~\n不过这个肯定不会是一次就写好哒~哈哈哈 慢慢补充\n并查集算法产生的原因(意义) 在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。这一类问题近几年来反复出现在信息学的国际国内赛题中，其特点是看似并不复杂，但数据量极大，若用正常的数据结构来描述的话，往往在空间上过大，计算机无法承受；即使在空间上勉强通过，运行的时间复杂度也极高，根本就不可能在比赛规定的运行时间（1～3秒）内计算出试题需要的结果，只能用并查集来描述。\n并查集是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。\n也就是对于一些集合之间的相连关系的描述\n并查集算法的操作(能做什么) 初始化 把每个点所在集合初始化为其自身。\n通常来说，这个步骤在每次使用该数据结构时只需要执行一次，无论何种实现方式，时间复杂度均为O(N)。\n查找 查找元素所在的集合，即根节点。\n合并 将两个元素所在的集合合并为一个集合。\n通常来说，合并之前，应先判断两个元素是否属于同一集合，这可用上面的“查找”操作实现。\n判断 判断两个元素是否在一个集合之中\n了解操作的意义 通过分析并查集的操作可以更好的理解并查集的思想\n也就是遇到需要进行这些操作的问题 可以往并查集这方面来思考\n并查集的例题 最简单的例题:\n若某个家族人员过于庞大，要判断两个是否是亲戚，确实还很不容易，给出某个亲戚关系图，求任意给出的两个人是否具有亲戚关系。 规定：x和y是亲戚，y和z是亲戚，那么x和z也是亲戚。如果x,y是亲戚，那么x的亲戚都是y的亲戚，y的亲戚也都是x的亲戚。\n根据给出的对应关系求出给定两人是否有亲戚关系\n此时便涉及到\n对集合的合并(合并有亲戚关系的集合)\n对集合的查找(查找两人是否为同一集合)\n详细解答过程\n并查集_百度百科\n并查集的注意点 树形数据结构的退化 插入节点时的规则如果不加控制\n容易导致树形退化\n在二叉搜索树中如:以1-2-3-4-5的顺序插入节点\n树的高度会变成n 那么所有操作便都需要O(n)时间才能完成\n所以同样在并查集为避免退化的发生\n可进行如下操作\n1.对于每棵树，记录这棵树的高度\n2.合并时如果两棵数的高度不同，那么从高度小的向高度大的连边\n路径压缩 对于每个节点\n1.一旦向上走到了一次根节点，就把这个点到父亲的边改为直接连向根\n2.在查询过程中向上经过的所有的节点，都改为直接连到根上\n(并没有必要修改高度rank)\n高度记录rank[m]为以m为根节点的树的高度\n参考资料:\n《挑战程序设计竞赛》\n并查集 - 百度百科\n","date":"2016-01-27T23:13:00+08:00","permalink":"https://boiltask.com/knowledge/union-find/","title":"并查集——合并与查询"},{"content":"问题描述 问题分析 分析可知(从小到大排序后)\n过桥比较省时间的方法有两种\n1、a[0] a[1]先过a[0]回\na[n] a[n-1]过 a[1]回\n则总时间a[1]+a[0]+a[n]+a[1]\n2、a[0]带a[n]过a[0]回\na[0]带a[n-1]过a[0]回\n则总时间a[n]+a[0]+a[n-1]+a[0]\n区别在与a[1]+a[1]与a[n-1]+a[0]\n两者应该去更小的那一种方法\n所以可以两两考虑\n把最大的两个送过桥\n当最后三人以下时\n剩三人\n则a[0]带a[2]过a[0]回\na[0]与a[1]过\n总时间 a[2]+a[0]+a[1]\n剩两人\na[0]与a[1]过\n总时间a[1]\n剩1人(说明总人数只有一人)\n总时间a[0]\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; int a[1200]; int main() { int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { int n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(int i=0; i\u0026lt;n; i++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]); sort(a,a+n); int sum=0; int i; for(i=n-1; i\u0026gt;2; i-=2) { sum+=min(a[1]+a[0]+a[i]+a[1],a[i]+a[0]+a[i-1]+a[0]); } if(i==2) printf(\u0026#34;%d\\n\u0026#34;,sum+a[0]+a[1]+a[2]); else if(i==1) printf(\u0026#34;%d\\n\u0026#34;,sum+a[1]); else printf(\u0026#34;%d\\n\u0026#34;,sum+a[0]); } return 0; } ","date":"2016-01-26T22:01:30+08:00","permalink":"https://boiltask.com/oj/nyoj/1047/","title":"【NYOJ】[1047]过河问题"},{"content":"问题描述 问题分析 题目细想之下并不难\n不过在\nfor(int k=i; !(k%m); cnt++)\n循环的中止判定时\n注意循环体执行的第一次前就会判定条件\n如果不满足 则循环体一遍也会执行\n注意 do-while是先循环一次再判断条件\n探究:\n【看书】for,(do-)while的循环体执行\n所以这一题的思路就很简单了\nn的阶乘为 1×2×3×4×……n\n所以需要找其分解质因数\n只需要判断 m~n 各有几个质因数\n(比m小的分解肯定没有质因数是m)\n判断一个数有几个质因数是 m\n只需要把这个数不断除去m\n知道无法整除 看除了多少次\nAC代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include\u0026lt;stdio.h\u0026gt; int main() { int T; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); while(T--) { int m,n; int i,cnt; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;n,\u0026amp;m); for(i=m,cnt=0; i\u0026lt;=n; i++) for(int k=i; !(k%m); cnt++) k/=m; //循环体执行前先判断条件 注意和do-while的区别 printf(\u0026#34;%d\\n\u0026#34;,cnt); } return 0; } 标程则用了递归函数\n还是涉及到了函数+表达式的形式\n并且使用了另外一种思路\n找到的一篇关于此的介绍文章\n《阶乘因式分解 - sead+》\n给定两个数m,n\n求m!分解质因数后因子n的个数。\n这道题涉及到了大数问题，如果相乘直接求的话会超出数据类型的范围。\n下面给出一种效率比较高的算法，我们一步一步来。\nm!=123*……(m-2)(m-1)m\n可以表示成所有和n倍数有关的乘积再乘以其他和n没有关系的\n=(n2n3n……kn)ohter other是不含n因子的数的乘积 因为 kn\u0026lt;=m 而k肯定是最大值 所以k=m/n\n=n^k(12*……*k)other\n=n^kk!*other\n从这个表达式中可以提取出k个n，然后按照相同的方法循环下去可以求出k!中因子n的个数。\n每次求出n的个数的和就是m!中因子n的总个数。\n这一种思路的实现是通过把n!的阶乘分解来实现的\n例如 求 n=8 m=2 的结果\n则\n8!=24×4!×other (other代表剩余其它的数字)\n那么\n4!=22×2!×other\n2!=21×1\n所以 8! 里应该有4+2+1=7个2\n同样的\n对于 n=7 m=2 的结果\n则\n7!=23×3!×other (other=\u0026gt;7×5×3)\n3!=21×1!×other (other=\u0026gt;3)\n所以\n7!里有3+1=4个2\n这种运算方法无疑比直接找的算法更为简便\n这也就是学算法的意义吧~\n而标程的递归使得这一运算表达更加简明\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include\u0026lt;iostream\u0026gt; using namespace std; int get(int n,int num) { if(n==0) return 0; else return get(n/num,num)+n/num; } int main() { int n; cin\u0026gt;\u0026gt;n; while(n--) { int a,b; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; cout\u0026lt;\u0026lt;get(a,b)\u0026lt;\u0026lt;endl; } } 题目地址:【NYOJ】[56]阶乘因式分解（一）\n参考文章:\n阶乘因式分解 - sead+\n","date":"2016-01-26T22:01:30+08:00","permalink":"https://boiltask.com/oj/nyoj/1056/","title":"【NYOJ】[1056]阶乘因式分解（一）"},{"content":"虽然最早就学过\nwhile与do-while区别\n但因为do-while很少用\n甚至做题时可以说从来没用过\n所以对于描述\ndo-while的循环体至少会执行一次\n这句话并没有深刻体会\n不过引发这个思考的是\n【NYOJ】[56]阶乘因式分解（一）\n之中的for循环条件\nfor(int k=i; !(k%m); cnt++) !(k%m)含义有点困惑\n不过结合 while do-while 便可以轻松得出\nfor(初始语句;判断语句;调整语句)\n中在执行循环的顺序应该是\nflowchart TD\rst[初始语句] --\u0026gt; cond{循环条件}\rcond -- 是 --\u0026gt; op1[循环体]\rcond -- 否 --\u0026gt; e[循环结束]\rop1 --\u0026gt; op2[调整语句]\rop2 --\u0026gt; cond\r这个流程图画的还不错吧~哈哈哈\n验证:\n初始条件在第一次判断前就执行\n1 2 3 4 5 6 7 #include\u0026lt;stdio.h\u0026gt; int main() { int n=1; for(int i=n=0; i\u0026lt;0; n++,i++); printf(\u0026#34;n的值为%d\\n\u0026#34;,n); return 0; } 第一次循环体执行前就需要 判断条件:\n1 2 3 4 5 6 7 8 9 10 #include\u0026lt;stdio.h\u0026gt; int main() { int n=0; for(int i=0; i\u0026lt;0; i++) n++; //\tfor(int i=0; i\u0026lt;1; i++) //\tn++; printf(\u0026#34;运行了%d次\\n\u0026#34;,n); return 0; } 而do-while形式为\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include\u0026lt;stdio.h\u0026gt; int main() { int n=0; int i=0; do { n++; i++; } while(i\u0026lt;0); //\tdo { //\tn++; //\ti++; //\t} while(i\u0026lt;1); printf(\u0026#34;n的值为%d\\n\u0026#34;,n); return 0; } 两次输出都为 n的值为1\n由此可以验证\nfor 与 do-while的区别\n","date":"2016-01-25T12:12:22+08:00","permalink":"https://boiltask.com/knowledge/cpp-for-do-while/","title":"for,(do-)while的循环体执行"},{"content":" 算法是一种思维。\n前情提要 在下这段时间对算法的理解应该要归结于这样一句话\n大胆假设 小心论证嘛\n起初最早对算法有个概念 是贪心算法\n对贪心算法的表述\n百度百科是这样说的\n贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。\n贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。\n当时其实对这种说法还是一知半解的(现在好像也是)\n所以对算法到底是什么 一直得不到一个明确的答案\n在想明白之前\n在下感觉做题的收益有点低\n题目地址:\tHPU15级个人赛 - Virtual Judge (hpuacm)\n而这次的个人赛有八道题目\n在下结束之后忘了保存代码了\n而又感觉去网站提交记录找 没必要\n所以对于这些题目的代码\n应该会上传一个重新写的版本\n八道题目分别是: 就不一一截图了\n以后慢慢整理\n这篇文章就是从解题思路上来简单说说\nProblem A\t利息计算 : 作为一道纯粹的数学计算题\n一定程度上考察了对数据类型和输入输出的控制\n但是这种题目作为签到题本身\n我觉得更重要的目的是让自己找到感觉\n不至于在接下的答题中慌乱\n而这此次比赛我恰恰犯了这点错误\n对一团数字不加思考就选择先做B题\n然而……\nProblem B - 18岁生日 : 在下这次个人赛的噩梦之源\n又是一个关于闰年的问题\n从这一题\n在下第一次知道闰年并不是严格的四年一次\n一个回归年不是365天,而是365天5小时48分46秒,多出的时间就会累积起来,新年就会后移,所以每隔四年就设一个闰年,这一年的二月改为29天.这样,闰年就有366天.但是,这样每一百年又差不多多了一天,所以又规定\u0026quot;百年\u0026quot;不设闰,即\u0026quot;百年24闰\u0026quot;.但百年扣一天闰还是不刚好,于是又规定,公元年数为400倍数者设闰.\n而我原先一直以为 1900 不是闰年是个数学问题\n也就是1988 1902都是闰年(其实并不是)\n但是经过这次教训也是学习了\n同时更深层次的\n也是对自己的一个教训\n太过自信了\n也就是过于相信自己是知道出题人的想法的\n(不一定被4整除 被100整除的还要能被400整除)\n本来一般的题目这种想法就够了\n然而这一题我所采用的方法\n恰恰用到了四年一闰这个思想\n(这个想法是错误的)\n具体解法讨论见题解文章\nProblem C - Magic Spheres 这一题也是迷之WA\n各种情况都想不通\n然后发现了一句……\nhe needs at least x blue, y violet and z orange spheres.\n重点是……\nat least\n也就是上面的数据没必要完全等于下面的\n只要能把上面变化成大于等于下面的就好了\n然而给的两组Yes的数据全部满足\n等于下面的\n所以导致对题目理解错误……\n想想原因\n就是对于这种英文题目\n我一般是对照输入输入猜题目意思\n所以导致了先入为主的思想\n这也是以后面对英文需要警醒的一件事情\nProblem D - The Best Gift 这一题神奇之处在于\n我竟然没用到题目给的m就顺利AC了-.-\nProblem E - Red and Black 这题是道经典的搜索题\nProblem F - Load Balancing 负载均衡 序列平衡的一种算法\n当时比赛因为前面用的时间太长了\n导致这一题都没时间看了……\n(主要也是看到别人都WA了好多 就没写)\nProblem G - The Suspects 按照题意应该是并查集\n不过当时我的第一眼思路是往搜索想的\n最终也是做出来了\nProblem H - Networking 最小生成树问题\n之前做过类似的了\n思考 经过这八道题\n其实我在思考到底什么是算法\n如果它只是一种解题方法的话\n我觉得似乎并不恰当\n比如有些题目 如\nProblem G - The Suspects\n属于简单的并查集\n但如果用搜索却也并不难理解\n又或者\nProblem E - Red and Black\n属于搜索 但bfs dfs却都可以解答\n那么 什么是算法\n我认为把算法归结为一种解题思维\n或许更加恰当\n也就是 不需要把算法看做一种模板 而是一种解题的思路\n区别是什么呢\n我觉得就是判断一道题是像是某某算法的题目\n脑海里第一意识出现的是算法的思想 还是算法的代码框架\n我觉得更好的情况还是理解算法的本质\n这样无论题目千变万化 总可以找到解题的钥匙\n而不用纠结于它到底符合哪一个模板\n算法是一种思维\n这便是我现阶段对算法的理解\n先照着这条路走吧\n然后慢慢修正自己的观点\n更何况\n无论怎样理解\n对一个算法还是要认真学习的\n甚至说更加努力的去学习\n探究其本质的一些东西\n话说我最近貌似开始养成\n把一篇文章分成几天来写的习惯了-.-\n貌似有时候会影响思路~\n哈哈哈\n尽量还是一口气写完吧~\n适当补充还是可以的\n","date":"2016-01-13T17:50:13+08:00","permalink":"https://boiltask.com/record/201601131/","title":"算法是一种思维"},{"content":"想想除了看书时之外\n有时也会幸运地有点想法\n所以再开一个类别来记录吧~\n在下希望这个分类下的博文越多越好 -.-\n中午记录\r晚上有场个人赛\n感觉略紧张啊……\n万一爆零肿么办 -_-\n感觉晚上还会来编辑一次\n先立个flag\n【关于for循环中定义变量的后续讨论】 上次在书中看到了关于for循环中定义的变量问题1 【看书】for循环中的定义变量\n结合最近的实际体验和一些测试 在这里再补充说明一些地方\nfor(int i=0 ; i\u0026lt;n ; i++)的局限性 我之前提到过\n提示2-4 建议尽量缩短变量的定义范围。例如，在for循环的初始化部分定义循环变量。\n加上自己的习惯 所以这些日子都是 尽量对于循环变量随用随定义\nPS:易语言 记次循环首(次数,n) 也是这种直接写出来的模式 (不过其实也需要先定义 不过个人养成了让它报错然后再直接定义的坏习惯)\n但是有时出现了一些问题 比如印象最深的关于涉及到 循环中 break; 例如当时有种素数判定方法:\n1 2 3 4 5 6 7 for(i=2;i\u0026lt;=sqrt(m);i++) if(m%i==0) break; if(i\u0026gt;k) printf(\u0026#34;%d 是素数。\\n\u0026#34;,m); else printf(\u0026#34;%d 不是素数。\\n\u0026#34;,m); 循环for便不能写成\nfor(int i=2;i\u0026lt;=sqrt(m);i++)\n否则跳出循环后是没有 i 这个变量的\n所以如果在for前没有对于 i 定义\nif(i\u0026gt;k)\n会报错\n而如果定义了\n又相当于没有对 i 赋值\n所以会得到错误结果\n可见for(int i=0 ; i\u0026lt;n ; i++)也是不可以滥用的\n现在对于这种情况我一般是采取\n对于这种需要 break 然后判断循环变量的\n还是使用在for之前就定义 然后\nfor还写成 for(i=0 ; i\u0026lt;n ; i++)\n或者使用一个 flag 标记\n比如对于上述判定素数\n可写成:\n1 2 3 4 5 6 7 8 9 10 11 int flag; for(int i=flag=2; i\u0026lt;=sqrt(m); i++) { if(m%i==0) { flag=0; break; } } if(flag) printf(\u0026#34;%d 是素数。\\n\u0026#34;,m); else printf(\u0026#34;%d 不是素数。\\n\u0026#34;,m); 这样会相对麻烦\n但对于一些情况还是挺方便理解的\n毕竟还是只需要对循环变量随用随定义\n循环前只需要 int flag\n需要注意的是\nflag必须要在循环前定义\n在循环里定义同样是无法在循环结束调用的\n这引出了下一部分的讨论\n也就是对循环体中的定义变量适用范围问题\nwhile等{}花括号中int i 的使用范围 已经知道\n对于自定义函数\n1 2 3 4 int sum(int a,int b) { int c=a+b; return c; } (只是为了说明函数中定义变量的问题)\n(这个函数可以直接写成)\n1 2 3 int sum(int a,int b) { return a+b; } 为了避免强迫症 还是再提一下\n在其中定义的 变量c\n是无法被其他函数调用的\n(包括 main 函数)\n而 函数语句被 { } 括起来\n结合上面的讨论\n有种猜测:\n{ } 花括号中定义的变量只能适用于花括号里面\n函数的 { } 是这样\n那么再讨论另一个使用花括号 { } 的地方\nwhile(){\n}\n事实上发现的确会报错 可见上述猜测对 while 是成立的\n想想 其实还有其它有花括号 比如 if(){ } 所以再进行一下测试\n结果证明同样符合猜测\n所以可以暂且得出结论\n{ } 花括号中定义的变量只能适用于花括号里面\n算法是一种思维 还有关于算法的一些思考……不过关于这一点 想想 “===程序设计灵魂==算法===” 分类下还没有文章 所以这一部分写到那里吧~ 哈哈哈哈哈\n晚上记录\r所以顺带这一部分如果有的话也新开一篇文章吧-.-\n这一篇写的有点长了哦\n算了 还是直接写在这里吧\n比赛链接:HPU15级个人赛 - Virtual Judge\n呃……对于结果不想说话啦\n在下只是还要坚定自己的想法\n以及完善自己的想法\n另外……认真执行自己的想法\n上次的文章:【看书】for循环中的定义变量\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2016-01-12T14:32:38+08:00","permalink":"https://boiltask.com/notes/competitive-programming/8/","title":"算法竞赛入门经典(8) – 关于for循环中定义变量的后续讨论"},{"content":"在做【UVa】[227]Puzzle1这一题的时候\n对于 char map[5][5] ; 这种形式的变量又做了讨论\n(文章地址:【UVa】[227]Puzzle)\n也就是对于map[5][5]的理解问题\ns[5] 可以理解为字符串(字符数组)\n那么 map[5][5]也可以理解为 多行字符串(二维字符数组)\nabc (0)\ndef (1)\nghi (2)\nmap[0]便代表”abc”\nmap[1]便代表”def”\nmap[2]便代表”ghi”\n也就是map[n][m]\nn是行号 m是列号\nmap[0][0]==’a’\nmap[0][1]==’b’\nmap[1][1]==’e’\nmap[2][0]==’g’\n所以对 map[5][5] 赋值可以用\n1 2 3 char map[5][5]; for(int i=0;i\u0026lt;5;i++) scanf(\u0026#34;%s\u0026#34;,map[i]); 同理可用于printf(\u0026quot;%s\u0026quot;,map[i]);\n经测试不可以！！\n应该是因为printf是遇到’\\0’才结束吧\n而且除了第一行之后 后面还跟了乱码符\n使用之后输出结果如下\n而使用二重循环配合 putchar(map[i][j]); 或者printf(\u0026quot;%c\u0026quot;,map[i][j]);\n便可以正常输出 代码如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; int main() { char map[5][5]; memset(map,0,sizeof(map)); for(int i=0; i\u0026lt;5; i++) scanf(\u0026#34;%s\u0026#34;,map[i]); for(int i=0; i\u0026lt;5; i++) { for(int j=0; j\u0026lt;5; j++) { // putchar(map[i][j]); printf(\u0026#34;%c\u0026#34;,map[i][j]); } printf(\u0026#34;\\n\u0026#34;); } return 0; } 由此可见\nC语言的魅力还远不止于此啊-.-\n另外再次感叹一下这书习题是给的真好\nPuzzle - UVA 227 - Virtual Judge\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2016-01-11T20:00:01+08:00","permalink":"https://boiltask.com/notes/competitive-programming/7/","title":"算法竞赛入门经典(7) – 二维字符数组"},{"content":"问题描述 Puzzle\r[uva-227] [2683667214179811] @vjudge\r问题分析 第一印象就是题目好长啊……\n据说是ACM/ICPC World Finals 1993的一道题……\n感觉屌屌的~\n所以……\n先把前几天写的对这一题的思路全部打上为敬……\n用二维字符串数组储存网格(第n行整体为一字符串)\n用字符串记录指令语句，用循环来进行判断\n读取到A、B、L、R执行对应命令\n其它字符 break; 并输出“This puzzle has no final configuration.”\n输入可用两重循环并使用 x,y 来记录空格所在\n(网格中空格处记录为 0)\n(第二重循环结束用getchar()吸收空行)\nA:上 B:下 L:左 R:右 (A:把上方的字母移入空格)\n示例代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // ARRBBL 其对应变化为 // A: map(x,y)=map(x,y-1); map(x,y-1)=0; y=y-1; // B: map(x,y)=map(x,y+1); map(x,y+1)=0; y=y+1; // L: map(x,y)=map(x-1,y); map(x-1,y)=0; x=x-1; // R: map(x,y)=map(x+1,y); map(x+1,y)=0; x=x+1; 变换后输出结果 (应该可以用一重循环搭配 printf)\nprintf(\u0026quot;%s\\n\u0026quot;,map[y]);\n/* 需要测试 */最直接的还是用两重循环搭配putchar()\n(第二重循环结束输出”\\n”)\n当时就是这样想的\n然后今天来正式的写~\n首先做二维数组相关的测试\n事实证明\n1 2 3 char map[5][5]; for(int i=0; i\u0026lt;5; i++) scanf(\u0026#34;%s\u0026#34;,map[i]); 此种写法会把字符存在\nmap[0][1-5] 这里面\n同理可用于 printf\n不可以这么打印啊……\n具体见:看书】二维字符数组\n所以输入网格的时候不一定要用getchar()\n但这里因为涉及到网格中空格的判定\n所以还是用 两重循环搭配 getchar() 比较好\n久经尝试\n虽然改了各种坑点还是WA了……\n是在下小看这一题了\n先打个flag\nWA代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; int main() { int x,y; int k,kase=0; char s[1000]; char map[5][5]; while(scanf(\u0026#34;%c\u0026#34;,\u0026amp;map[0][0]),map[0][0]!=\u0026#39;Z\u0026#39;) { for(int i=0; i\u0026lt;5; i++) { int flag=1; for(int j=0; j\u0026lt;5; j++) { if(i||j) { map[i][j]=getchar(); if(map[i][j]==\u0026#39; \u0026#39;) { y=i; x=j; } else if(map[i][j]==\u0026#39;\\n\u0026#39;) { map[i][j]=\u0026#39; \u0026#39;; y=i; x=j; flag=0; } } else continue; } if(flag) getchar(); } int t=-1; memset(s,0,sizeof(s)); while((s[++t]=getchar())!=\u0026#39;0\u0026#39;); if(kase) printf(\u0026#34;\\n\u0026#34;); printf(\u0026#34;Puzzle #%d:\\n\u0026#34;,++kase); for(k=0; k\u0026lt;t; k++) { if(s[k]==\u0026#39;A\u0026#39;) { if(y-1\u0026lt;0) { printf(\u0026#34;This puzzle has no final configuration.\\n\u0026#34;); break; } else { map[y][x]=map[y-1][x]; map[y-1][x]=0; y=y-1; } } else if(s[k]==\u0026#39;B\u0026#39;) { if(y+1\u0026gt;=5) { printf(\u0026#34;This puzzle has no final configuration.\\n\u0026#34;); break; } else { map[y][x]=map[y+1][x]; map[y+1][x]=0; y=y+1; } } else if(s[k]==\u0026#39;L\u0026#39;) { if(x-1\u0026lt;0) { printf(\u0026#34;This puzzle has no final configuration.\\n\u0026#34;); break; } else { map[y][x]=map[y][x-1]; map[y][x-1]=0; x=x-1; } } else if(s[k]==\u0026#39;R\u0026#39;) { if(x+1\u0026gt;=5) { printf(\u0026#34;This puzzle has no final configuration.\\n\u0026#34;); break; } else { map[y][x]=map[y][x+1]; map[y][x+1]=0; x=x+1; } } else if(s[k]==\u0026#39;\\n\u0026#39;) { continue; } else { printf(\u0026#34;This puzzle has no final configuration.\\n\u0026#34;); break; } } if(k==t) { for(int i=0; i\u0026lt;5; i++) { for(int j=0; j\u0026lt;5; j++) { putchar(map[i][j]); if(j!=4) putchar(\u0026#39; \u0026#39;); } printf(\u0026#34;\\n\u0026#34;); } } memset(map,0,sizeof(map)); char ch; while((ch = getchar()) != \u0026#39;\\n\u0026#39; \u0026amp;\u0026amp; ch != EOF); } return 0; } 题目地址：Puzzle - UVA 227 - Virtual Judge\n","date":"2016-01-10T21:42:53+08:00","permalink":"https://boiltask.com/oj/uva/227/","title":"【UVa】[227]Puzzle"},{"content":"想起了以前的一个知识点\n1 2 3 for(起始语句;判断语句;修正语句){ 循环语句; } 对于for循环我以前的理解是这样的\n执行到for循环时\n先执行一次 起始语句\n然后开始执行循环体(循环语句)\n执行后执行 修正语句\n然后判断 判断语句\n成立则继续执行 循环语句→修正语句→判断语句……\n但通过P19中的介绍以及实验\n发现似乎还有一些需要注意的地方\n也就是这种写法:\n1 for(int i=0; i\u0026lt;100; i++); 也就是循环变量i是在for语句时才建立的\n按照之前\n执行到for循环时\n先执行一次 起始语句\n理解 这个i应该和这种用法:\n1 2 int i; for(i=0; i\u0026lt;100; i++); 是一样的\n但探究之后发现并不一样\n参考如下语句\n1 2 3 4 5 6 7 8 #include\u0026lt;stdio.h\u0026gt; int main() { // int i; for(int i=0; i\u0026lt;20; i++) printf(\u0026#34;%d \u0026#34;,i); printf(\u0026#34;\\n%d\u0026#34;,i); return 0; } 当编译时会报错\n也就是for循环结束之后\ni变得无法调用了\n而for之前的那条注释语句加上的话\n发现执行结果如下:\n可见循环中的 int i 并没有影响循环外的 int i\n所以可见这个for循环中的i是独立的\n这样的话 既然独立 那么随用随定义应该是好过直接先定义的\n以前我在这种的时候是习惯把正常的变量与循环变量分开区分的\n如\n1 2 int n,m,x,y; //储存数值的变量 int i,j,k; //记录循环次数的变量 而了解到这一特性之后\n可以轻松地在运用for时再定义这些变量 而不影响其它部分\n在P19有这样一句话\n提示2-4 建议尽量缩短变量的定义范围。例如，在for循环的初始化部分定义循环变量。\n我也是深感很有道理啊~\n话说这就是共鸣哎~毕竟每个人的习惯还是不一样的 能和大神的观点一致 还是有点小激动的呢\n《算法竞赛入门经典(第2版)》P19\n以上发表于:\n【看书】for循环中的定义变量（2016-01-04 17:11） 11 0\n20160112 附: 后续文章:【看书】关于for循环中定义变量的后续讨论\n","date":"2016-01-04T17:11:21+08:00","permalink":"https://boiltask.com/notes/competitive-programming/6/","title":"算法竞赛入门经典(6) – for循环中的定义变量"},{"content":"问题描述：\n找出所有形如abc*de（三位数乘以两位数）的算式，使得在完整的竖式中，所有数字都属于一个特定的数字集合。输入数字集合（相邻数字之间没有空格），输出所有竖式。每个竖式前应有编号，之后应有一个空行。最后输出解的总数。具体格式见样例输出（为了便于观察，竖式中的空格改用小数点显示，但你的程序应该输出空格，而非小数点）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 //样例输入 2357 //样例输出 \u0026lt;1\u0026gt; ..775 X..33 ----- .2325 2325. ----- 25575 The number of solutions = 1 写上补充一下这个题目所要表达的意思\n同时还是继续考虑用MarkDown编辑器\n怎么来写这种文章\n这个题目是要求出所有满足\n形如 abc*de 三位数乘以两位数\n并且竖式过程中用到的数\n都在集合”s”中\n输出这样的竖式及总共有多少\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; int main() { int count = 0; char s[20],buf[99]; scanf(\u0026#34;%s\u0026#34;,s); for(int abc = 111; abc \u0026lt;= 999; abc++) for(int de = 11; de \u0026lt;=99; de++) { int x=abc*(de%10),y=abc*(de/10),z=abc*de; sprintf(buf,\u0026#34;%d%d%d%d%d\u0026#34;,abc,de,x,y,z); int ok=1; for(int i=0; i\u0026lt;strlen(buf); i++) if(strchr(s,buf[i])==NULL) ok=0; if(ok) { printf(\u0026#34;\u0026lt;%d\u0026gt;\\n\u0026#34;,++count); printf(\u0026#34;%5d\\nX%4d\\n-----\\n%5d\\n%4d\\n-----\\n%5d\\n\\n\u0026#34;,abc,de,x,y,z); } } printf(\u0026#34;The number of solutions = %d\\n\u0026#34;,count); return 0; } 《算法竞赛入门经典(第2版)》P41\n","date":"2015-12-28T18:04:49+08:00","permalink":"https://boiltask.com/notes/competitive-programming/5/","title":"算法竞赛入门经典(5) – 竖式问题"},{"content":"《算法竞赛入门经典(第2版)》\nP36 题目2 下面的程序运行结果是什么？“!=”运算符表示“不相等”。提示：请上机实验，不要凭主观感觉回答。\n1 2 3 4 5 6 7 #include\u0026lt;stdio.h\u0026gt; int main() { double i; for(i=0; i!=10; i+=0.1) printf(\u0026#34;%.lf\\n\u0026#34;,i); return 0; } 运行结果:\n可以发现程序会一直循环下去\n把代码改成如下\n1 2 3 4 5 6 7 #include\u0026lt;stdio.h\u0026gt; int main() { double i; for(i=0; i!=10\u0026amp;\u0026amp;i\u0026lt;20; i+=0.1) printf(\u0026#34;%.lf\\n\u0026#34;,i); return 0; } 可以发现\nc语言中double类型数据计算是有误差的\n也就是说每次加0.1\n可能永远得不到整10\n所以上述程序会永远循环\n","date":"2015-12-28T17:32:23+08:00","permalink":"https://boiltask.com/notes/competitive-programming/4/","title":"算法竞赛入门经典(4) – 浮点数陷阱"},{"content":"《算法竞赛入门经典》P35 习题2-5\n分数化小数 (decimal)\n问题描述：\n输入正整数a，b，c，输出a/b的小数形式，精确到小数点后c位。a,b≤106(10的6次方) ，c≤100。输入包含多组数据，结束标记为a=b=c=0。\n样例输入：\n1 6 4\n0 0 0\n样例输出：\nCase 1 : 0.1667\n又是一种没见过的题\n而且顺便使用一下 HTML版的博文编辑器~\n当小数的位数定的时候可以写成\n1 printf(\u0026#34;%.4lf\u0026#34;,a/b); 这次要输出一个位数不定的小数\n所以不能这么写\n百度一下发现可以这么写\n1 printf(\u0026#34;%.*lf\u0026#34;,c,a/b); 所以整个程序可以写成:\n1 2 3 4 5 6 7 8 9 #include\u0026lt;stdio.h\u0026gt; int main() { double a,b; int c,kase=0; while(scanf(\u0026#34;%lf %lf %d\u0026#34;,\u0026amp;a,\u0026amp;b,\u0026amp;c),a!=0||b!=0||c!=0) { printf(\u0026#34;Case %d : %.*lf\\n\u0026#34;,++kase,c,a/b); } return 0; } 如此应该可以符合题意~\n话说……\n有没有这些题的OJ啊……\n一会再去找一找……\n","date":"2015-12-28T16:53:23+08:00","permalink":"https://boiltask.com/notes/competitive-programming/3/","title":"算法竞赛入门经典(3) – 输出不确定位数的小数"},{"content":"为什么网址要变成这个啊！！！！\nhttp://blog.csdn.net/u011493189\n在下想要\nhttp://blog.csdn.net/BoilTask\n啊！！！！！！\n这让一个排版都研究半天的人很难受啊！\n算了……\n懒得换了\n吐个槽记录一下就好\n改变强迫症\n从乱七八糟的网址开始！\n20250405：这么想，一直不喜欢CSDN然后反复折腾博客也是有原因的……\n","date":"2015-12-28T14:09:59+08:00","permalink":"https://boiltask.com/record/csdn-username/","title":"【吐槽】为什么用户名不能换啊！"},{"content":"当感到程序计算过慢时\n可使用“计时器”来查看到底有多慢\n具体的是一个 time.h 头文件\n从而调用计时函数 clock()\n这个获得的数值除以常数 CLOCK_PER_SEC\n可以得到以秒为单位的数值\n代码写法\n先调用头文件\n1 #include\u0026lt;time.h\u0026gt; 然后在程序结尾写上\n1 printf(\u0026#34;程序用时 = %.2f\\n\u0026#34;,(double)clock()/CLOCKS_PER_SEC); 但通过这种方式发现程序用时过大\n因为这个计时的起点是以打开程序开始的\n所以会导致用键盘输入的时间也会包括在内\n所以可以用命令行来解决\n打开 CMD(命令提示符)\n输入\ncd 文件目录\n来把当前目录转到指定目录\n如：\n然后输入 echo 输入数据 | 程序名\n如:\nabc便是我创建程序的文件名\n可以得到一些关于输入输出的数据\n从而可以进行分析\n与书中给的数据还是有不少差别的\n可见我的小电脑计算能力还是可以哒~\n哈哈哈\n《算法竞赛入门经典》——刘佳汝 P26\n","date":"2015-12-27T12:33:36+08:00","permalink":"https://boiltask.com/notes/competitive-programming/2/","title":"算法竞赛入门经典(2) – 程序计时器"},{"content":"越发的感觉刘汝佳的《算法竞赛入门经典》写的很好\n然后勾起了心中的共鸣~\n然后没事就发点读后感吧\n也算是在看书过程中的调节调节\n哈哈哈~\n先把P16的指出的int范围测出来~\nint ： -2147483647~2147483647\n话说我以前怎么没想到还有必要进行一下这种测试嘞~\n","date":"2015-12-27T11:42:51+08:00","permalink":"https://boiltask.com/notes/competitive-programming/1/","title":"算法竞赛入门经典(1) – int的范围"},{"content":"问题描述 wrz的压岁钱\r时间限制：1 Sec内存限制：128 MB\rDescription 马上要过年了，电子信息wrz要去亲戚家拿压岁钱。\n他的亲戚有三家，他有一辆谷鸽牌电动车，电量只能支持从自己家骑到任意一家亲戚家，然后电动车就会没电了，电动车会放在该亲戚家充电。\n剩下的两家亲戚由电子信息wrz步行过去，之后再回来骑充满电的谷鸽牌电动车回家。\n但是电子信息wrz比较懒，不喜欢走太多路，你能帮他算出最少要走多少路程吗？\nInput 第一行为数字T，表示有T（1\u0026lt;=T\u0026lt;=1000）组测试数据。\n每组数据占一行，分别有三个整数x，y，z，代表三家中任意两家的路程。（1\u0026lt;=x，y，z\u0026lt;=10~9)\n例如：三家亲戚分别为a，b，c，则三个数字分别为a到b的路程，b到c的路程，c到a的路程。\nOutput 每个实例输出占一行：格式为Case#x：y\nx为第x个实例，y为电子信息wrz需要走的最短路程。\nSample Input 1 2 3 4 3 1 2 3 4 5 6 7 8 9 Sample Output 1 2 3 Case #1: 6 Case #2:15 Case #3: 24 问题分析 第一眼思路是画了个三角形\n于是感觉非常简单\n但总感觉有点诡异\n于是突然意识到\n坑点是这三个数据并不一定能组成三角形\n当不是三角形的时候\n原路返回而不走第三个\n的情况下用的路程更少\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;algorithm\u0026gt; using namespace std; int main() { int T; int k,i; long long a[3]; long long sum; scanf(\u0026#34;%d\u0026#34;,\u0026amp;T); for(k=1;k\u0026lt;=T;k++) { for(i=0; i\u0026lt;3; i++) scanf(\u0026#34;%lld\u0026#34;,\u0026amp;a[i]); sort(a,a+3); sum=a[0]+a[1]; if(a[2]\u0026lt;sum) sum+=a[2]; else sum+=sum; printf(\u0026#34;Case #%d: %lld\\n\u0026#34;,k,sum); } return 0; } 题目地址：【郑轻】[1799]wrz的压岁钱\n","date":"2015-12-26T20:41:50+08:00","permalink":"https://boiltask.com/oj/zzuli/1799/","title":"【郑轻】[1799]wrz的压岁钱"},{"content":"嗯…有几件事情要先写一写\n感觉不说点什么不是我的风格 所以我决定写写这个系列日志~标题我考虑再三还是用这一个啦 毕竟这是绕不开的话题\n其实写这篇日志的时候已经彻底步入18了…话说这么晚了写日志会不会突然睡着…-_-|| 其实阳历生日是12月12 虽然早就过了 但心中还有点不舍嘛 所以强行拖到了农历生日才这么珍重\n我都说了 我这辈子最在乎的关于生理上的一是…呃…不说了 二便是年龄 感觉我有这种心态和@冀丹妮是抹不开的毕竟逼我发说说逼了一天 而且既然都不介意我说说了那我就不介意@出来了啊 完蛋了…感觉又要HOLD不住我要说些什么了…\n算啦算啦 我就顺便说说吧 省了再发说说了 标题都这么取了 不聊妹纸真是毫无意义啊\n想想现在QQ里 经常出现的身影 除了小学同桌…嗯…幼儿园也同过桌吧~那时候没分那么清就属于@冀丹妮认识时间最久了吧 哎…话说这篇日志要不要设置阅读权限-_-||\n算了 任性 设置权限不是我的风格 今生最讨厌任何形式的权限狗╭(╯^╰)╮\n我靠…忍住不好意思写的感受强行写！\n丹妮~嗯 我向来是不介意别人知道有这个人的 我感觉这已经成为我的一道坎了 我不喜欢删说说删日志 我承认我是个看重回忆的人 我觉得那些东西都没用 什么IT男 我对网上的一些数据看的其实并没有那么神圣 所以往往放在那里就懒得动了 谁愿意看就去看好了 换句话说 人家都愿意花时间去了解你的过去了 你还有什么理由拒绝呢？\n说起IT男 我认为我似乎又并不是个严格的IT男 我一直认为我是有文艺青年的气息的 这种感觉在初三下学期到高一表现的特别强烈 也许 没有计算机我真的能成为徐志摩呢哈哈哈 虽然我现在并不认为徐志摩是个什么好男人 那就是个禽兽啊所以我感觉现在还好 唉~虽然现在估计离开了计算机也不行了啊 智商明显下降 情商…感觉好久没正式试过了 不好说\n多想回到那遥远的从前啊 至少 我还有许多没干的事情可以去做 我曾经想 18岁之前我要这样这样这样 然而现在基本死完了\n我在想我为什么还没找女朋友呢 ……我说了 我对爱情是有洁癖的 …呃…我不相信我这么屌没妹纸喜欢\n只不过…不敢了…\n我觉得但不是我存在什么走不出来什么的 毕竟有没有在谈恋爱 这么长时间了该看开的早就看开了 只是 心好累 或者说 我已经没有信心再对另一个人做这么多了 如果我不能 那么 我认为这对于妹纸是不公平的 那我良心上是会受谴责的\n本身不想再提的嘛\n但既然都说了\n我的语言组织能力竟然实在是绕不开 不知道怎么说 这么长时间 想想对我说过的 最深入脑海的竟然是 抱歉和对不起 也是醉了\n话说我现在还这么矫情不合适吧…毕竟…醉了 醉了…不想写了…\n啊呀…好难啊 算了 反正设的所有人可见 任性 正如有牛逼的人说 我不是针对你一个人 我是说在座的各位 都是垃圾…那么~我不是针对你一个人 我是说 在看的各位 真认真看到这里的也是不容易…\n我为什么整天喊着要妹纸啊~因为从内心深处已经觉得 对我谈恋爱感觉非常不自然…妹纸是拿来护着的 不是拿来谈恋爱的…感觉再这样发展下去真成中央空调了…\n其实空调就空调嘛…从小受到的是什么教育…妹纸就是天生要被守护的 我妈本身就是个可爱的女孩~就不多说了 下一篇日志再说吧 就连我爸都表示 最起码的 出去吃饭不能让人家女生付钱…对于这一点…非常惭愧的是在下有时候确实穷啊\n但从小就是…培养所谓绅士风度嘛 你懂得\n看红楼梦的时候我不知道其他人对贾宝玉这个人 包括他的行为 包括他的名言“女人是水做的 男人是泥做的”是怎么理解的 我起初迷迷糊糊的只是仿佛感觉挺有道理 虽然带有一丝玩笑…但现在我确实有这个感觉 就是…一个开朗的女生会给人感觉很单纯 一个男生…嗯…禽兽？哈哈 其实我一直的意见都是 如果你觉得一个女生的行为是坏的 那也一定是被身边的男生带坏的 所以我轻易是不会去讨厌一个人的 特别是妹纸\n那么…不讨厌就是喜欢？\n我有时候在想 如果对每一个妹纸都好 那么…对女朋友呢？更进一步 对妻子呢？我仔细想…答案是…有点不知道？所以我并不想谈恋爱 说了 恋爱这种状态 特别是高中 更甚者初中 一定是要有人出来拒绝的 否则对两个人还是弊处无穷 所以…我对被发好人卡并不是特别难受…呃…虽然当时有点 但想想其实还好 但…\n我靠 不谈恋爱就和谁也别谈啊…给我发好人卡 我还能自我安慰 但…我勒个去 你让我怎么办嘛 所以在那之前的一段时间我不断缠着…我有预感的…但…骗不了自己的…虽然我可以一本正经的胡说八道到让人家都觉得很有道理 但…骗不了我自己啊！\n我知道 发觉到了…已经渐行渐远…所以当我知道…那个什么…我无奈 我失望 但我不意外…毕竟…距离是很重要的 有些事情虽然我自认我有空间条件我也能做 还做得可以更好 但我没有…而且我的一些东西不足以超越空间…\n知道吗…前几天做那个相册的时候 我是边吐槽边骂边灌水做出来的 为此还麻烦了萌萌哒苏贺听了我一晚上的槽 最日了狗的…我做好了不理我了╭(╯^╰)╮ 然后我就在那一遍一遍的循环那个小视频 7.14…前一天我们去唱的歌 那次唱歌其实真不是我约的 是小圣博自作主张举办的 他请客我掏钱-_-||因为我知道当时的情况 叫你你肯定不去…话说这不是一篇第二人称的日志！！！人称还改不回来了…\n无所谓╮(╯_╰)╭啦 反正看到这里的基本也是真爱了 都不知道日志能不能发这么长的字数…\n当时我吐槽说…这一去 估计要出事…啊…哈哈\n圣博是知道我好多事情的…问我值吗 我一直在表示闲着也是闲着 或者~我才不承认我还在联系 然后现在想想…我真不知道怎么搞了…特别是在我发了这篇日志之后…\n哈哈哈 我是个相信每个人都有故事的人 大学生啊特别是优秀的 没被人惦记过说出去我都不信所以…什么是洁癖呢 也许在我还相信真爱之前 我一直都会有吧…所以我内心是不希望看到分手啊什么的 看了爱情观是要受打击的…所以年轻不懂事…那么就坚持到年老吧\n嗯…说这话是不是有点没良心…哈哈哈\n就我个人来说 我不介意坦白~或者 我更希望在和我接触之前便了解过我 这样才更深刻的了解我 毕竟爱情面前 人是可以展现的淋漓尽致的 至少我还是这样 或者说 人是应该展现的淋漓尽致的…\n爱情观这种东西…我认为我还是基本成熟着的…正如开头我说 我不知道我还能不能再用心去呵护一个人 或者说 比起呵护爱情 我现在也确实愿意陪伴计算机 前几天发的说说 代码是最好的伙伴 它忠诚的执行你的命令 所谓秘之BUG也大都源自自己 所以…我现在还是感觉计算机更靠谱…爱情 是奢侈品 我这屌丝心态奢侈品应该是享用不起了但又真心不想让爱情掉价…所以就不如放在那里吧 每天 我要妹子我要妹子 也挺好 有限的经历还是要投入到无限的为人民服务中去啊~\n对了 关于那个如何对女朋友如何对妻子得问题…我勒个去…又忘了想要说什么了…要不谁来帮我回忆回忆 来个情景模拟好啦~哈哈哈\n两点了哎…明天还有太极拳…明天想说就再接着说吧~祝我自己明天考试超神 18岁的正式第一天过得开心(∩_∩)\n","date":"2015-12-23T17:57:45Z","permalink":"https://boiltask.com/record/qzone-1450893451/","title":"18岁的那些事——关于爱情"},{"content":"问题描述 今年暑假不AC\r[hdu-2037] [3151813865328070] @vjudge\r问题分析 贪心算法\n(虽然现在也不是很明白什么是贪心算法)\n难点也就是对节目结束时间的排序\n需要自己饶一饶\n第一次写的时候还没学结构体\n所以用数组写的比较长\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include\u0026lt;stdio.h\u0026gt; int main() { int n,i,j,k,t; while(scanf(\u0026#34;%d\u0026#34;,\u0026amp;n),n!=0) { int re=1,result=1; int Ti_s[100],Ti_e[100]; Ti_s[0]=Ti_e[0]=0; for(i=0; i\u0026lt;n; i++) { scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;Ti_s[i],\u0026amp;Ti_e[i]); for(k=0; k\u0026lt;i; k++) { if(Ti_e[i]\u0026lt;Ti_e[k]) { t=Ti_e[k]; Ti_e[k]=Ti_e[i]; Ti_e[i]=t; t=Ti_s[k]; Ti_s[k]=Ti_s[i]; Ti_s[i]=t; } } } // for(i=0; i\u0026lt;n; i++) { // for(k=i+1,j=i; k\u0026lt;n; k++) { // if(Ti_e[j]\u0026lt;=Ti_s[k]) { // j=k; // re++; // } // } // if(re\u0026gt;result) // result=re; // if(i==0) // result=re; // re=1; // } for(k=1,j=0; k\u0026lt;n; k++) { if(Ti_e[j]\u0026lt;=Ti_s[k]) { j=k; re++; } } printf(\u0026#34;%d\\n\u0026#34;,re); } return 0; } 下面的是结构体的\n但也是没有用sort\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include\u0026lt;stdio.h\u0026gt; struct tv { int Ti_s; int Ti_e; }; int main() { int i,k; int n,result; while(scanf(\u0026#34;%d\u0026#34;,\u0026amp;n),n!=0) { result=1; struct tv b[n],t; b[0].Ti_s=b[0].Ti_e=0; for(i=1; i\u0026lt;=n; i++) scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;b[i].Ti_s,\u0026amp;b[i].Ti_e); for(i=1; i\u0026lt;=n; i++) { for(k=1; k\u0026lt;=n-i+1; k++) { if(b[k].Ti_e\u0026lt;b[k-1].Ti_e) { t=b[k]; b[k]=b[k-1]; b[k-1]=t; } } } for(i=2,t=b[1]; i\u0026lt;=n; i++) { if(b[i].Ti_s\u0026gt;=t.Ti_e) { result++; t=b[i]; } } printf(\u0026#34;%d\\n\u0026#34;,result); } return 0; } 值得做的一题\n在附一个优秀的讲解博文：\nHDU2037 今年暑假不AC 贪心算法\n","date":"2015-12-21T19:10:29+08:00","permalink":"https://boiltask.com/oj/hdu/2037/","title":"【杭电】[2037]今年暑假不AC"},{"content":"想一想 似乎好久没写过日志了……\n确实是，毕竟平时想说点什么都直接发说说了，而且还没法判断字数到底有多少，于是导致了经常出现一些长段说说……这次本来也是想发说说的，但想想似乎大学以来都没写过日志，而且今天写了挺多篇的博客了，有手感，所以还是来写成日志了。其实……最关键的……我有预感，我会说的挺多的……\n当时为了情怀建立了www.BoilTask.com这个网站 但并没有想好怎么做 搞得并没有什么卵用\n关心一下我的应该知道我在搞ACM这方面的东西 然后其实感触挺多的\n三个多月了，也许不算特别长的时间 但当我们在讨论寒假啦 怎么回家啦 期末考试啦什么的 才发觉……大一上学期这就要结束了。我做了什么呢？好像并没有干什么事情……颓废了一个学期，其实想想也是挺难受的。\n这两天在写博客http://blog.csdn.net/u011493189;\n也是在填之前挖出的坑 然后自然也是翻了翻学长的博客，真正让我决定写点什么的导火索 是宇神的博客 确实看着挺有感觉的\n这是学长2014年12月28日写的一篇博客……有句话我觉得说的 挺……\n“我不是一个学霸，我也不想去做一个学霸。如果为了那些爱我的人和我爱的人，我必须要成为所谓的学霸才能让他们欣慰，我也心甘情愿去承受这一切。即使再苦，再累，我也不会后悔，更不会在这条我选择的路上给自己回头的理由。即使泪流满面，我也会笑着走完自己的路。”\n学长的博客名便叫做了笑着走完自己的路……\n我注意到学长第一篇博客是发在 2014年12月21日00:41 也就是去年今天的晚上\n然后直到今天学长也是上传了几道我并不懂得题\n一年时间学长传了一千多篇博文，很不容易的……我不知道自己一年之后能不能做到这样……确实不知道……虽然牛还是要先吹为敬，但真正想想，确实是不容易的……\n我喜欢计算机 喜欢编程 这是毋容置疑的，但同时，我也是有文艺青年的多愁善感和二逼青年的蹉跎时日，也就是，我能写一天一夜代码不停，也能写一天一夜文章不停，同时也能玩一天一夜游戏不停，这都是有可能的……所以，我现在确实是不知道未来会怎样。\n这次的周练内心是崩溃着的，之前的周练布置下来，没灵感 放放 再看看，循环几次也就好了，这次……没灵感 放放 再看看 还是炸，总结下来就是自从吃了18岁的蛋糕智商明显下降，有必要考虑考虑农历生日重新吃一遍……\n嗯……我还想说什么来着……不知道……忘了……想起来在再水吧~\n周练我还要去挣扎挣扎……\n但愿一年以后有人来看我 也能有点感触吧~\n至少 我看着学长及学长的学长还是有些被感染的\n学计算机的 适当傲一点我认为还是必要的\n扶我起来 我还能继续WA\n","date":"2015-12-20T09:29:19Z","permalink":"https://boiltask.com/record/qzone-1450603741/","title":"【震惊哭】竟然决定用日志水了"},{"content":"问题描述 数值统计\r[hdu-2008] [3215600033426102] @vjudge\r问题分析 没什么说的\n就是好多变量……嗯……\n加加加加加\n+++++\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;math.h\u0026gt; int main() { int n,i,a,b,c; double x; while(scanf(\u0026#34;%d\u0026#34;,\u0026amp;n),n!=0) { a=b=c=0; for(i=0; i\u0026lt;n; i++) { scanf(\u0026#34;%lf\u0026#34;,\u0026amp;x); if(x==0) b++; if(x\u0026lt;0) a++; if(x\u0026gt;0) c++; } printf(\u0026#34;%d %d %d\\n\u0026#34;,a,b,c); } return 0; } ","date":"2015-12-20T12:13:06+08:00","permalink":"https://boiltask.com/oj/hdu/2008/","title":"【杭电】[2008]数值统计"},{"content":"问题描述 求数列的和\r[hdu-2009] [3151983511328772] @vjudge\r问题分析 还好吧\n是不是这一题第一次用sqrt啊……\nmath.h 头文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;math.h\u0026gt; int main() { int m,i; double sum,n; while(scanf(\u0026#34;%lf %d\u0026#34;,\u0026amp;n,\u0026amp;m)!=EOF) { double a[m]; a[0]=n; sum=n; for(i=1; i\u0026lt;m; i++) { a[i]=sqrt(a[i-1]); sum=sum+a[i]; } printf(\u0026#34;%.2lf\\n\u0026#34;,sum); } return 0; } ","date":"2015-12-20T12:09:59+08:00","permalink":"https://boiltask.com/oj/hdu/2009/","title":"【杭电】[2009]求数列的和"},{"content":"问题描述 第几天？\r[hdu-2005] [3215573496248721] @vjudge\r问题分析 关于闰年的问题\n当时做的时候对闰年判定脑抽了(⊙﹏⊙)b\n闰年是要求能被4整除\n但如果是**00\n还必须要能被400整除\n当时对这一点脑抽了好久……\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include\u0026lt;stdio.h\u0026gt; int main() { int Y,M,D,i,n; int day[12]= {0,31,28,31,30,31,30,31,31,30,31,30}; while(scanf(\u0026#34;%d/%d/%d\u0026#34;,\u0026amp;Y,\u0026amp;M,\u0026amp;D)!=EOF) { n=0; if(Y%4==0) day[2]=29; if(Y%100==0) if(Y%400!=0) day[2]= 28; for(i=0; i\u0026lt;M; i++) n=n+day[i]; n=n+D; printf(\u0026#34;%d\\n\u0026#34;,n); } return 0; } ","date":"2015-12-20T12:04:48+08:00","permalink":"https://boiltask.com/oj/hdu/2005/","title":"【杭电】[2005]第几天？"},{"content":"问题描述 杨辉三角\r[hdu-2032] [3105071538305260] @vjudge\r问题分析 啊\n杨辉三角\n感觉这一题值得说说\n杨辉三角是我进入ACM协会时上机做的一题\n据当时学长学姐说是当时在所有题里最难的一题\n(所以进协会其实还是挺简单的)\n做了这一题其它题就不用做了……‘\n不过这一种写法是在进协会之前想的一种公式法\n也就是根据\n第n行的m个数可表示为 C(n-1,m-1)\n即为从n-1个不同元素中取m-1个元素的组合数\n根据这个公式用变量和循环来做\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;stdio.h\u0026gt; int main() { int s = 1, n; int i, j; while(scanf(\u0026#34;%d\u0026#34;, \u0026amp;n)!=EOF) { printf(\u0026#34;1\\n\u0026#34;); for (i = 2; i \u0026lt;= n; s = 1, i++) { printf(\u0026#34;1 \u0026#34;); for (j = 1; j \u0026lt;= i - 2; j++) printf(\u0026#34;%d \u0026#34;, (s = (i - j) * s / j)); printf(\u0026#34;1\\n\u0026#34;); } printf(\u0026#34;\\n\u0026#34;); } return 0; } 不过推导过程对入门的来说还是挺费时间的\n所以当时做的时候还是用的传统的二维数组来写的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;stdio.h\u0026gt; int main() { int a[100][100] ; int i,j,n; while(scanf(\u0026#34;%d\u0026#34;,\u0026amp;n)!=EOF) { for(i=1 ; i\u0026lt;=n; i++) { for(j=1; j\u0026lt;=i; j++) { if(j==1) a[i][j]=1; else a[i][j]=a[i-1][j-1]+a[i-1][j]; } } for(i=1; i\u0026lt;=n; i++) { for(j=1; j\u0026lt;=i; j++) { printf(\u0026#34;%d\u0026#34;,a[i][j]); if(j!=i) printf(\u0026#34; \u0026#34;); } printf(\u0026#34;\\n\u0026#34;); } printf(\u0026#34;\\n\u0026#34;); } return 0; } 也是有纪念意义的一题啊~\n","date":"2015-12-20T12:00:49+08:00","permalink":"https://boiltask.com/oj/hdu/2032/","title":"【杭电】[2032]杨辉三角"},{"content":"问题描述 蟠桃记\r[hdu-2013] [3121297035859893] @vjudge\r问题分析 挺有意思的一题\n也是见识到了各种出题人的萌\n题目本身应该没什么说的\n倒推起来还是挺容易的\n1 2 3 4 5 6 7 8 9 10 #include\u0026lt;stdio.h\u0026gt; int main() { int n,i; while(scanf(\u0026#34;%d\u0026#34;,\u0026amp;n)!=EOF) { for(i=1; n!=1; n--) i=(i+1)*2; printf(\u0026#34;%d\\n\u0026#34;,i); } return 0; } ","date":"2015-12-20T11:53:09+08:00","permalink":"https://boiltask.com/oj/hdu/2013/","title":"【杭电】[2013]蟠桃记"},{"content":"问题描述 人见人爱A\u0026#43;B\r[hdu-2033] [3121371330163652] @vjudge\r问题分析 当时感觉挺有意思的一题\n就是说……\n我去……\n怎么又是A+B\nA+B到底能有多少-.-\n这一题就是模拟进位的问题\n当时还不会结构体\n现在写应该会直接定义结构体来做吧\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include\u0026lt;stdio.h\u0026gt; int main() { int i,j,AH,AM,AS,BH,BM,BS,H,M,S; scanf(\u0026#34;%d\u0026#34;,\u0026amp;j); for(i=0; i\u0026lt;j; i++) { H=M=S=0; scanf(\u0026#34;%d %d %d %d %d %d\u0026#34;,\u0026amp;AH,\u0026amp;AM,\u0026amp;AS,\u0026amp;BH,\u0026amp;BM,\u0026amp;BS); S=AS+BS; if(S\u0026gt;=60) { S=S-60; M=M+1; } M=M+AM+BM; if(M\u0026gt;=60) { M=M-60; H=H+1; } H=H+AH+BH; printf(\u0026#34;%d %d %d\\n\u0026#34;,H,M,S); } return 0; } ","date":"2015-12-20T11:46:21+08:00","permalink":"https://boiltask.com/oj/hdu/2033/","title":"【杭电】[2033]人见人爱A+B"},{"content":"问题描述 水仙花数\r[hdu-2010] [3215602906529989] @vjudge\r问题分析 这题有意思的地方在于\n这里用到了我之前用易语言写机器人时\n使用的一种“开关”变量\n不过现在来看好像学长有点代码也用到过这种概念\n对这一题来说也有其它的判定方法\n不过能感受到以前的知识有用\n还是挺高兴的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include\u0026lt;stdio.h\u0026gt; int main() { int i,m,n,x,a,b,c; while(scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;m,\u0026amp;n)!=EOF) { x=0; for(i=m; i\u0026lt;=n; i++) { a=i%10; b=(i%100)/10; c=i/100; if(a*a*a+b*b*b+c*c*c==i) { if(x==1) printf(\u0026#34; \u0026#34;); x=1; printf(\u0026#34;%d\u0026#34;,i); } } if(x!=1) printf(\u0026#34;no\u0026#34;); printf(\u0026#34;\\n\u0026#34;); } return 0; } ","date":"2015-12-20T11:37:38+08:00","permalink":"https://boiltask.com/oj/hdu/2010/","title":"【杭电】[2010]水仙花数"},{"content":"问题描述 平方和与立方和\r[hdu-2007] [3215605280296043] @vjudge\r问题分析 没什么说的……\n现在看这个代码还是有优化空间的\n以后遇见类似的注意些\n话说这一题是不是之前说过了……\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include\u0026lt;stdio.h\u0026gt; int main() { int i,x,y,m,n; while(scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;m,\u0026amp;n)!=EOF) { if(m\u0026gt;n) { i=m; m=n; n=i; } x=y=0; for(i=m; i\u0026lt;=n; i++) { if(i%2==0) { x=x+i*i; } else { y=y+i*i*i; } } printf(\u0026#34;%d %d\\n\u0026#34;,x,y); } return 0; } ","date":"2015-12-20T11:30:37+08:00","permalink":"https://boiltask.com/oj/hdu/2007/","title":"【杭电】[2007]平方和与立方和"},{"content":"问题描述 最小公倍数\r[hdu-1108] [3129340845008668] @vjudge\r问题分析 基础的一种求最小公倍数\n用乘积除以最大公约数\n求最大公约数的方法……\n话说学长说没听说过这种……\n-.-\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include\u0026lt;stdio.h\u0026gt; int main() { int a,b,m; while(scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a,\u0026amp;b)!=EOF) { m=a*b; while(a!=b) { if(a\u0026gt;b) a-=b; if(b\u0026gt;a) b-=a; } printf(\u0026#34;%d\\n\u0026#34;,m/a); } return 0; } 然后交给我一种更快速的递归函数 求最大公约数的\n1 2 3 4 5 6 7 8 int gcd(int a,int b) { if(b==0) { return a; } return gcd(b,a%b); } 所以求最小公倍数的可以写成\n1 2 3 4 int lcm(int a,int b) { return a/gcd(a,b)*b; } ","date":"2015-12-20T11:25:28+08:00","permalink":"https://boiltask.com/oj/hdu/1108/","title":"【杭电】[1108]最小公倍数"},{"content":"问题描述 A hard puzzle\r[hdu-1097] [3158622413313116] @vjudge\r问题分析 找规律的题\n话说上传顺序貌似不对……\n这题是之后写的了\n不过这都不重要啦\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include\u0026lt;stdio.h\u0026gt; int main() { int i,a,b,m; while(scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a,\u0026amp;b)!=EOF) { a=a%10; b=b%4; if(b==0) b=4; for(i=0,m=1; i\u0026lt;b; i++) m=(m*a)%10; printf(\u0026#34;%d\\n\u0026#34;,m); } return 0; } ","date":"2015-12-20T11:19:18+08:00","permalink":"https://boiltask.com/oj/hdu/1097/","title":"【杭电】[1097]A hard puzzle"},{"content":"问题描述 A\u0026#43;B for Input-Output Practice (VIII)\r[hdu-1096] [3166555475623715] @vjudge\r问题分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include\u0026lt;stdio.h\u0026gt; int main() { int i,j,n,k,x,sum; scanf(\u0026#34;%d\u0026#34;,\u0026amp;j); for(i=0; i\u0026lt;j; i++) { sum=0; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(k=0; k\u0026lt;n; k++) { scanf(\u0026#34;%d\u0026#34;,\u0026amp;x); sum=sum+x; } if(i!=0) printf(\u0026#34;\\n\u0026#34;); printf(\u0026#34;%d\\n\u0026#34;,sum); } return 0; } ","date":"2015-12-20T11:09:26+08:00","permalink":"https://boiltask.com/oj/hdu/1096/","title":"【杭电】[1096]A+B for Input-Output Practice (VIII)"},{"content":"问题描述 A\u0026#43;B for Input-Output Practice (VII)\r[hdu-1095] [3166526833034900] @vjudge\r问题分析 1 2 3 4 5 6 7 8 #include\u0026lt;stdio.h\u0026gt; int main() { int a,b; while(scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a,\u0026amp;b)!=EOF) { printf(\u0026#34;%d\\n\\n\u0026#34;,a+b); } return 0; } ","date":"2015-12-20T11:07:47+08:00","permalink":"https://boiltask.com/oj/hdu/1095/","title":"【杭电】[1095]A+B for Input-Output Practice (VII)"},{"content":"问题描述 A\u0026#43;B for Input-Output Practice (VI)\r[hdu-1094] [3166532281559113] @vjudge\r问题分析 1 2 3 4 5 6 7 8 9 10 11 12 13 #include\u0026lt;stdio.h\u0026gt; int main() { int i,j,x,sum; while(scanf(\u0026#34;\\n%d\u0026#34;,\u0026amp;j)!=EOF) { sum=0; for(i=0; i\u0026lt;j; i++) { scanf(\u0026#34;%d\u0026#34;,\u0026amp;x); sum=sum+x; } printf(\u0026#34;%d\\n\u0026#34;,sum); } return 0; } ","date":"2015-12-20T11:05:47+08:00","permalink":"https://boiltask.com/oj/hdu/1094/","title":"【杭电】[1094]A+B for Input-Output Practice (VI)"},{"content":"问题描述 A\u0026#43;B for Input-Output Practice (V)\r[hdu-1093] [3166537394221626] @vjudge\r问题分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include\u0026lt;stdio.h\u0026gt; int main() { int i,j,n,k,x,sum; scanf(\u0026#34;%d\u0026#34;,\u0026amp;j); for(i=0; i\u0026lt;j; i++) { sum=0; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); for(k=0; k\u0026lt;n; k++) { scanf(\u0026#34;%d\u0026#34;,\u0026amp;x); sum=sum+x; } printf(\u0026#34;%d\\n\u0026#34;,sum); } return 0; } ","date":"2015-12-20T11:03:50+08:00","permalink":"https://boiltask.com/oj/hdu/1093/","title":"【杭电】[1093]A+B for Input-Output Practice (V)"},{"content":"问题描述 A\u0026#43;B for Input-Output Practice (IV)\r[hdu-1092] [3166534252746223] @vjudge\r问题分析 1 2 3 4 5 6 7 8 9 10 11 12 13 #include\u0026lt;stdio.h\u0026gt; int main() { int i,j,x,sum; while(scanf(\u0026#34;\\n%d\u0026#34;,\u0026amp;j),j!=0) { sum=0; for(i=0; i\u0026lt;j; i++) { scanf(\u0026#34;%d\u0026#34;,\u0026amp;x); sum=sum+x; } printf(\u0026#34;%d\\n\u0026#34;,sum); } return 0; } ","date":"2015-12-20T11:01:48+08:00","permalink":"https://boiltask.com/oj/hdu/1092/","title":"【杭电】[1092]A+B for Input-Output Practice (IV)"},{"content":"问题描述 A\u0026#43;B for Input-Output Practice (III)\r[hdu-1091] [3166540035964832] @vjudge\r问题分析 1 2 3 4 5 6 7 #include\u0026lt;stdio.h\u0026gt; int main() { int a,b; while (scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a,\u0026amp;b),a!=0||b!=0) printf(\u0026#34;%d\\n\u0026#34;,a+b); return 0; } ","date":"2015-12-20T10:58:59+08:00","permalink":"https://boiltask.com/oj/hdu/1091/","title":"【杭电】[1091]A+B for Input-Output Practice (III)"},{"content":"问题描述 A\u0026#43;B for Input-Output Practice (I)\r[hdu-1089] [3166507714701510] @vjudge\r问题分析 杭电入门输入输出控制训练\n想想还是把这一个系列的几题分开写吧\n害羞(✿◡‿◡)\n毕竟不是同一题嘛\n1 2 3 4 5 6 7 8 #include\u0026lt;stdio.h\u0026gt; int main() { int a,b; while(scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a,\u0026amp;b)!=EOF) { printf(\u0026#34;%d\\n\u0026#34;,a+b); } return 0; } ","date":"2015-12-20T10:53:38+08:00","permalink":"https://boiltask.com/oj/hdu/1089/","title":"【杭电】[1089]A+B for Input-Output Practice (I)"},{"content":"问题描述 A\u0026#43;B for Input-Output Practice (II)\r[hdu-1090] [3166510856241429] @vjudge\r问题分析 话说把这几个传好是不是今天又没几篇能上传了……\n1 2 3 4 5 6 7 8 9 10 #include\u0026lt;stdio.h\u0026gt; int main() { int i,j,a,b; scanf(\u0026#34;%d\u0026#34;,\u0026amp;j); for(i=0; i\u0026lt;j; i++) { scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a,\u0026amp;b); printf(\u0026#34;%d\\n\u0026#34;,a+b); } return 0; } ","date":"2015-12-20T10:53:38+08:00","permalink":"https://boiltask.com/oj/hdu/1090/","title":"【杭电】[1090]A+B for Input-Output Practice (II)"},{"content":"问题描述 字符串统计\r[hdu-2017] [3121320297081359] @vjudge\r问题分析 一天竟然只能发20篇博客……\n这让我怎么填上这个坑嘛……\n话说昨天保存的博客还丢了……\n心塞……\n昨天说的什么来着……\n好像是……\n这个题目看到过n遍了！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include\u0026lt;stdio.h\u0026gt; int main() { int i,j,n; char ch; scanf(\u0026#34;%d\\n\u0026#34;,\u0026amp;j); for(i=0; i\u0026lt;j; i++) { n=0; while((ch=getchar())!=\u0026#39;\\n\u0026#39;) { if(ch\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;ch\u0026lt;=\u0026#39;9\u0026#39;) n++; } printf(\u0026#34;%d\\n\u0026#34;,n); } return 0; } ","date":"2015-12-20T10:45:36+08:00","permalink":"https://boiltask.com/oj/hdu/2017/","title":"【杭电】[2017]字符串统计"},{"content":"问题描述 求奇数的乘积\r[hdu-2006] [3215576369027036] @vjudge\r问题分析 那时候判定奇数还是用的%2 不过……不改了\n留作纪念吧\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include\u0026lt;stdio.h\u0026gt; int main() { int n,i,x,s; while(scanf(\u0026#34;%d\u0026#34;,\u0026amp;n)!=EOF) { s=1; for(i=0; i\u0026lt;n; i++) { scanf(\u0026#34;%d\u0026#34;,\u0026amp;x); if(x%2!=0) s=s*x; } printf(\u0026#34;%d\\n\u0026#34;,s); } return 0; } ","date":"2015-12-19T17:43:33+08:00","permalink":"https://boiltask.com/oj/hdu/2006/","title":"【杭电】[2006]求奇数的乘积"},{"content":"问题描述 Sum Problem\r[hdu-1001] [3166558818424174] @vjudge\r问题分析 前n项和 没什么说的\n杭电的1001总是要说两句的\n1 2 3 4 5 6 7 8 #include\u0026lt;stdio.h\u0026gt; int main() { double n; while(scanf(\u0026#34;%lf\u0026#34;,\u0026amp;n)!=EOF) printf(\u0026#34;%d\\n\\n\u0026#34;,(int)(n*(n+1)/2)); return 0; } ","date":"2015-12-19T17:40:26+08:00","permalink":"https://boiltask.com/oj/hdu/1001/","title":"【杭电】[1001]Sum Problem"},{"content":"问题描述 成绩转换\r[hdu-2004] [3215578877592386] @vjudge\r问题分析 这博客好难用啊……\n还是用这种上传方式吧……\n不过用图片确实好麻烦啊……\n至于这一题……\n没什么说的……\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include\u0026lt;stdio.h\u0026gt; int main() { int n; while(scanf(\u0026#34;%d\u0026#34;,\u0026amp;n)!=EOF) { if(n\u0026lt;=100\u0026amp;\u0026amp;n\u0026gt;=0) { if(n\u0026lt;60) printf(\u0026#34;E\\n\u0026#34;); if(n\u0026gt;=60\u0026amp;\u0026amp;n\u0026lt;70) printf(\u0026#34;D\\n\u0026#34;); if(n\u0026gt;=70\u0026amp;\u0026amp;n\u0026lt;80) printf(\u0026#34;C\\n\u0026#34;); if(n\u0026gt;=80\u0026amp;\u0026amp;n\u0026lt;90) printf(\u0026#34;B\\n\u0026#34;); if(n\u0026gt;=90\u0026amp;\u0026amp;n\u0026lt;=100) printf(\u0026#34;A\\n\u0026#34;); } else { printf(\u0026#34;Score is error!\\n\u0026#34;); } } return 0; } ","date":"2015-12-19T17:36:57+08:00","permalink":"https://boiltask.com/oj/hdu/2004/","title":"【杭电】[2004]成绩转换"},{"content":"问题描述 计算两点间的距离\r[hdu-2001] [3151975822656813] @vjudge\r问题分析 还是用这种吧…\n1 2 3 4 5 6 7 8 9 10 11 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;math.h\u0026gt; int main() { double d,x1,y1,x2,y2; while(scanf(\u0026#34;%lf %lf %lf %lf\u0026#34;,\u0026amp;x1,\u0026amp;y1,\u0026amp;x2,\u0026amp;y2)!=EOF) { printf(\u0026#34;%.2lf\\n\u0026#34;,d=sqrt(pow(x1-x2,2)+pow(y1-y2,2))); } return 0; } ","date":"2015-12-19T17:32:10+08:00","permalink":"https://boiltask.com/oj/hdu/2001/","title":"【杭电】[2001]计算两点间的距离"},{"content":"问题描述 计算球体积\r[hdu-2002] [3151980935638174] @vjudge\r问题分析 不用pow是因为据说调用函数没有直接乘运算快……\n1 2 3 4 5 6 7 8 9 10 11 12 #include\u0026lt;stdio.h\u0026gt; #define PI 3.1415927 int main() { double V,r; while(scanf(\u0026#34;%lf\u0026#34;,\u0026amp;r)!=EOF) { V=(PI*r*r*r*4)/3; printf(\u0026#34;%.3lf\\n\u0026#34;,V); } return 0; } ","date":"2015-12-19T17:13:30+08:00","permalink":"https://boiltask.com/oj/hdu/2002/","title":"【杭电】[2002]计算球体积"},{"content":"问题描述 求绝对值\r[hdu-2003] [3152007540136327] @vjudge\r问题分析 没什么说的……毫无意义\n单纯的计数吧……\n呃……话说用这样的题来凑数会不会被骂凑表脸……\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include\u0026lt;stdio.h\u0026gt; int main() { double n; while(scanf(\u0026#34;%lf\u0026#34;,\u0026amp;n)!=EOF) if(n\u0026gt;0) { printf(\u0026#34;%.2lf\\n\u0026#34;,n); } else { printf(\u0026#34;%.2lf\\n\u0026#34;,n=-n) ; } return 0; } ","date":"2015-12-19T16:56:23+08:00","permalink":"https://boiltask.com/oj/hdu/2003/","title":"【杭电】[2003]求绝对值"},{"content":"终于想明白了博客的意义\n嗯……至少\n帮忙记录下自己AC的总题目数啊~\n算是个计数器吧\n没事还能吐吐槽 回忆回忆\n本分类下的题目时间都比较早\n可能写的描述文字就少点了\n以后尽量写代码和写博客放在一起吧~\n","date":"2015-12-19T08:47:04Z","permalink":"https://boiltask.com/record/blog-significance/","title":"写在正式写博客之前——博客的意义"},{"content":"程序的魅力也体现在解决问题的方式往往有很多\n下面这个手机短号已经做了好多遍了……\n估计以后整理时还要再写一遍……\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include\u0026lt;stdio.h\u0026gt; int main() { int n; int i; char m[12]; scanf(\u0026#34;%d\u0026#34;,\u0026amp;n); while(n--) { scanf(\u0026#34;%s\u0026#34;,m); printf(\u0026#34;6%s\\n\u0026#34;,m+6); } return 0; } 这便是计算机的精彩~不是吗？\n","date":"2015-12-19T08:40:54Z","permalink":"https://boiltask.com/record/acm-first-look/12/","title":"初识ACM——活泼的精灵"},{"content":"最经典的例子\n0\u0026lt;a\u0026lt;100\n便需要写成\n0\u0026lt;a\u0026amp;\u0026amp;a\u0026lt;100\n这便是要求思维的转换与用法的规范\n每一个地方都有它的规则\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include\u0026lt;stdio.h\u0026gt; int main() { int n; while(scanf(\u0026#34;%d\u0026#34;,\u0026amp;n)!=EOF) { if(n\u0026lt;=100\u0026amp;\u0026amp;n\u0026gt;=0) { if(n\u0026lt;60) printf(\u0026#34;E\\n\u0026#34;); if(n\u0026gt;=60\u0026amp;\u0026amp;n\u0026lt;70) printf(\u0026#34;D\\n\u0026#34;); if(n\u0026gt;=70\u0026amp;\u0026amp;n\u0026lt;80) printf(\u0026#34;C\\n\u0026#34;); if(n\u0026gt;=80\u0026amp;\u0026amp;n\u0026lt;90) printf(\u0026#34;B\\n\u0026#34;); if(n\u0026gt;=90\u0026amp;\u0026amp;n\u0026lt;=100) printf(\u0026#34;A\\n\u0026#34;); } else { printf(\u0026#34;Score is error!\\n\u0026#34;); } } return 0; } 话说现在看这样的题……这题也出？-.-\n","date":"2015-12-19T08:37:15Z","permalink":"https://boiltask.com/record/acm-first-look/11/","title":"初识ACM——这是程序的世界"},{"content":"在写代码时被一学长看见在南阳OJ上做题\n于是被夸了两句~当时心情好激动哦\n于是摸到了求绝对值的题秒写代码！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include\u0026lt;stdio.h\u0026gt; int main() { double n; while(scanf(\u0026#34;%lf\u0026#34;,\u0026amp;n)!=EOF) if(n\u0026gt;0) { printf(\u0026#34;%.2lf\\n\u0026#34;,n); } else { printf(\u0026#34;%.2lf\\n\u0026#34;,n=-n) ; } return 0; } 话说我起这个题目就放这个代码合适吗……\n-.-\n","date":"2015-12-19T08:31:12Z","permalink":"https://boiltask.com/record/acm-first-look/10/","title":"初识ACM——崭露头角"},{"content":"渐渐的……\n我也能写出来一些当时看很复杂的代码了……\n这是一个奇偶数分离的程序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include\u0026lt;stdio.h\u0026gt; int main() { int i,k,n; scanf(\u0026#34;%d\u0026#34;,\u0026amp;i); int a[i] ; for(k=0;k\u0026lt;i;k++) { scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[k]); } for(k=0;k\u0026lt;i;k++) { for(n=1;n\u0026lt;=a[k];n++) { if(n%2==1) printf(\u0026#34;%d \u0026#34;,n); } printf(\u0026#34;\\n\u0026#34;); for(n=1;n\u0026lt;=a[k];n++) { if(n%2==0) printf(\u0026#34;%d \u0026#34;,n); } printf(\u0026#34;\\n\\n\u0026#34;); } return 0; } 虽然现在看能改进的地方挺多的\n但是…当时看…已经很不错了好吧 ！\n","date":"2015-12-19T08:28:02Z","permalink":"https://boiltask.com/record/acm-first-look/9/","title":"初识ACM——渐入佳境"},{"content":"当时遇见的5个数求最值的问题\n鉴于当时并不会排序\n发现这个问题可以不用排序而是直接寻找就行了\n真的很庆幸啊！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include\u0026lt;stdio.h\u0026gt; int main() { int n,m[5],min,max; for(n=0;n\u0026lt;5;n++) scanf(\u0026#34;%d\u0026#34;,\u0026amp;m[n]); max=min=m[1]; for(n=0;n\u0026lt;5;n++) { if(m[n]\u0026gt;=max) max=m[n]; if(m[n]\u0026lt;=min) min=m[n]; } printf(\u0026#34;%d %d\u0026#34;,min,max); return 0; } 呃……虽然好像现在来看……你懂得~\n","date":"2015-12-19T08:26:55Z","permalink":"https://boiltask.com/record/acm-first-look/8/","title":"初识ACM——幸好不用排序"},{"content":"为了探究for循环的用法\n需要编写一个求前n项和的程序\n在完成基本的程序之后\n我又写出了下面这个鬼……\n1 2 3 4 5 6 7 8 9 10 11 #include\u0026lt;stdio.h\u0026gt; //求前n项和 int main() {int shouxiang,qianjixiang,he; shouxiang=1; he=0; for (qianjixiang=1;qianjixiang\u0026lt;=3;qianjixiang++) {he=shouxiang+he; shouxiang=shouxiang*2; } printf(\u0026#34;%d\u0026#34;,he); } -.-完全没问题的代码\n虽然这个强的怨念似乎毫无意义啊……\n","date":"2015-12-19T08:23:45Z","permalink":"https://boiltask.com/record/acm-first-look/7/","title":"初识ACM——中文的信仰"},{"content":"当时最大的感觉就是……\n九九乘法表只需要这么少的代码就能打出来？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;stdio.h\u0026gt; int main(){ int i,j,n; for(i=1;i\u0026lt;=9;i++){ // 将下面的for循环注释掉，就输出左下三角形 // for(n=1; n\u0026lt;=9-i; n++) // printf(\u0026#34; \u0026#34;); for(j=1;j\u0026lt;=i;j++) printf(\u0026#34;%d*%d=%2d \u0026#34;,i,j,i*j); printf(\u0026#34;\\n\u0026#34;); } return 0; } 后来据说九九乘法表是刘可学长的入ACM的题\n","date":"2015-12-19T08:19:28Z","permalink":"https://boiltask.com/record/acm-first-look/6/","title":"初识ACM——九九乘法表"},{"content":"学长讲解输出及数据类型\n代码是这样的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;cstdio\u0026gt; int main (){ char c; char d; int a = 1234; float f = 3.141592653589; double x = 0.12345678987654321; c = \u0026#39;\\x41\u0026#39;;//十六进制 d = \u0026#39;\\101\u0026#39;;//八进制 printf(\u0026#34;a = %d\\n\u0026#34;, a); printf(\u0026#34;a = %6d\\n\u0026#34;, a); printf(\u0026#34;a = %2d\\n\u0026#34;, a); printf(\u0026#34;a = %-6d--\\n\u0026#34;, a); printf(\u0026#34;a = %06d\\n\u0026#34;, a); printf(\u0026#34;a = %02d\\n\u0026#34;, a); printf(\u0026#34;f = %f\\n\u0026#34;, f); printf(\u0026#34;f = %6.4f\\n\u0026#34;, f); printf(\u0026#34;x = %lf\\n\u0026#34;, x); printf(\u0026#34;x = %18.16lf\\n\u0026#34;, x); printf(\u0026#34;c = %c\\n\u0026#34;, c); printf(\u0026#34;c = %d\\n\u0026#34;, c); printf(\u0026#34;c = %x\\n\u0026#34;, c); printf(\u0026#34;d = %c\\n\u0026#34;, d); printf(\u0026#34;d = %d\\n\u0026#34;, d); printf(\u0026#34;d = %x\\n\u0026#34;, d); return 0; } 我的内心是崩溃的-.-\n但现在看看其实还好 也是开始向C语言探索迈步\n","date":"2015-12-19T08:17:23Z","permalink":"https://boiltask.com/record/acm-first-look/5/","title":"初识ACM——这都是啥-.-"},{"content":"无聊的时候 根据经验\n让自己感受到趣味是最好的事情\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #define N 100 //这个程序的关键部分是借鉴了学长展示的 I love U 那一段代码 //所以我个人认为还是没什么实际意义的 //主要是上完课了，光AC题也比较枯燥 //所以写下这个打字机效果巩固巩固学到的知识 //需要说明的我会在下面代码中进行注释 HANDLE hConsole; void gotoxy(int x, int y) { COORD coord; coord.X = x; coord.Y = y; SetConsoleCursorPosition(hConsole, coord); } //这个函数是直接复制的 I love U 那一段函数 int main() { int i,j,k; char *title[9]= {\u0026#34;简\u0026#34;,\u0026#34;单\u0026#34;,\u0026#34;的\u0026#34;,\u0026#34;书\u0026#34;,\u0026#34;写\u0026#34;,\u0026#34;文\u0026#34;,\u0026#34;字\u0026#34;,\u0026#34;效\u0026#34;,\u0026#34;果\u0026#34;}; //这一段本来可以直接用多个frintf函数来写 //单因为想巩固一下数组的知识，所以用了数组和一段循环语句来实现 //但必须承认我对C语言中的数据类型还是有太多没理解的 //所以也是百度了许多资料 //这个写法貌似用到了“指针”，我 百度一下还是没太理解 //所以只是这么写出来了，但具体的真正含义还是一知半解的 //而且导致编译时下面出现[Warning],但没看出影响运行 //所以我也没改进 ,待掌握更多时再改吧 hConsole = GetStdHandle(STD_OUTPUT_HANDLE); //这一句应该是句柄相关的,不是很懂,也是直接复制的那一段源码 while(1) //这一个while控制无限循环 { gotoxy(15,2); for(i=0; i\u0026lt;9; i=i+1) { printf(\u0026#34;%s\u0026#34;,title[i]) ; Sleep(150); } //上面那个就是提取一个字一个字的输出了 //不是特别懂,我是基于易语言中提取文本型数组的思路写的 //不知道理解的对不对 Sleep(750); gotoxy(30,3); printf(\u0026#34;——BoilTask \u0026#34;); Sleep(1000); printf(\u0026#34;(欧阳天)\u0026#34;); Sleep(1000); printf(\u0026#34; 计算机1504\u0026#34;); Sleep(1000); j=9; for(k=0; k\u0026lt;3; k++) { for(i = 0; i\u0026lt;9; i ++) { gotoxy(j,7+i); printf(\u0026#34;*\u0026#34;); Sleep(N); } j=j+11; } j=53; for(k=0; k\u0026lt;2; k++) { for(i = 0; i\u0026lt;7; i ++) { gotoxy(j,7+i); printf(\u0026#34;*\u0026#34;); Sleep(N); } j=j+11; } gotoxy(12,18); Sleep(1000) ; printf(\u0026#34;猜猜这将形成什么文字？\u0026#34;); Sleep(2000); for(i=0; i\u0026lt;21; i++) { gotoxy(33-i,18); printf(\u0026#34;\\b \u0026#34;); Sleep(N); } //这里的一个字一个字删除用了\\b+空格来实现 //因为没想到好的思路…… //还是对好多东西不理解 gotoxy(11,11); for(i = 0; i\u0026lt;8; i ++) { printf(\u0026#34;*\u0026#34;); Sleep(N); } gotoxy(33,7); for(i = 0; i\u0026lt;6; i ++) { printf(\u0026#34;*\u0026#34;); Sleep(N); } gotoxy(40,8); printf(\u0026#34;*\u0026#34;); for(i = 0; i\u0026lt;2; i ++) { gotoxy(41,9+i); printf(\u0026#34;*\u0026#34;); Sleep(N); } gotoxy(40,11); printf(\u0026#34;*\u0026#34;); for(i = 0; i\u0026lt;6; i ++) { gotoxy(38-i,12); printf(\u0026#34;*\u0026#34;); Sleep(N); } gotoxy(54,14); printf(\u0026#34;*\u0026#34;); gotoxy(55,15); for(i = 0; i\u0026lt;8; i ++) { printf(\u0026#34;*\u0026#34;); Sleep(N); } gotoxy(63,14); printf(\u0026#34;*\u0026#34;); gotoxy(25,20); Sleep(1000) ; printf(\u0026#34;祝河南理工走向辉煌~\u0026#34;); //没什么亮点的一句结束语 Sleep(8000); system(\u0026#34;cls\u0026#34;); } } //说点题外话 我在学习C语言的过程中 //从小以来计算机是对我来说称之为梦想的东西 //其实想想在很多方面都下过劲 //html flash AE PS Au 等等…… //易语言是其中我研究成果中最靠谱的一个 //因为完成了能拿的出手的一些成品 //现在我仍旧觉得,其实以前学的这些知识并不重要 //关键是学习的方法和学习的态度！ //这也是我想和那些对计算机充满热情的同学们说的 //为了梦想,大家共勉！ 这个貌似是开学之后一段时间写的\n然后正好提到了那个 I❤U 所以一块放上来吧\n注释……嗯……写的还好\n哈哈哈哈\n","date":"2015-12-19T08:12:46Z","permalink":"https://boiltask.com/record/acm-first-look/4/","title":"初识ACM——学习与趣味"},{"content":"还是学长为了展示C语言的趣味\n放了一段C语言写的生成 I❤U 效果的程序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #define N 50 HANDLE hConsole; void gotoxy(int x, int y) { COORD coord; coord.X = x; coord.Y = y; SetConsoleCursorPosition(hConsole, coord); } int main() { int i,j,k; hConsole = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleTextAttribute(hConsole, FOREGROUND_RED|FOREGROUND_BLUE|FOREGROUND_INTENSITY); for(k=0;k\u0026lt;3;k++) { gotoxy(4,6); for(i = 0;i\u0026lt;11;i ++) { printf(\u0026#34;*\u0026#34;); Sleep(N); } for(i = 0;i\u0026lt;12;i++) { gotoxy(9,7+i); printf(\u0026#34;*\u0026#34;); Sleep(N); } gotoxy(4,18); for(i = 0;i\u0026lt;11;i ++) { printf(\u0026#34;*\u0026#34;); Sleep(N); } gotoxy(36,10); printf(\u0026#34;*\u0026#34;); Sleep(N); gotoxy(25,10); printf(\u0026#34;*\u0026#34;); Sleep(N); gotoxy(47,10); printf(\u0026#34;*\u0026#34;); Sleep(N); gotoxy(34,8); printf(\u0026#34;*\u0026#34;); Sleep(N); gotoxy(38,8); printf(\u0026#34;*\u0026#34;); Sleep(N); gotoxy(30,7); printf(\u0026#34;*\u0026#34;); Sleep(N); gotoxy(42,7); printf(\u0026#34;*\u0026#34;); Sleep(N); gotoxy(27,8); printf(\u0026#34;*\u0026#34;); Sleep(N); gotoxy(45,8); printf(\u0026#34;*\u0026#34;); Sleep(N); gotoxy(25,11); printf(\u0026#34;*\u0026#34;); Sleep(N); gotoxy(47,11); printf(\u0026#34;*\u0026#34;); Sleep(N); for(i=1,j=1;i\u0026lt;6,j\u0026lt;6;i++,j++) { gotoxy(25+i,11+j); printf(\u0026#34;*\u0026#34;); Sleep(N); } gotoxy(32,17); printf(\u0026#34;*\u0026#34;); Sleep(N); gotoxy(34,18); printf(\u0026#34;*\u0026#34;); Sleep(N); for(i=1,j=1;i\u0026lt;6,j\u0026lt;6;i++,j++) { gotoxy(47-i,11+j); printf(\u0026#34;*\u0026#34;); Sleep(N); } gotoxy(40,17); printf(\u0026#34;*\u0026#34;); Sleep(N); gotoxy(38,18); printf(\u0026#34;*\u0026#34;); Sleep(N); gotoxy(36,19); printf(\u0026#34;*\u0026#34;); Sleep(N); for(i=0;i\u0026lt;11;i++) { gotoxy(59,6+i); printf(\u0026#34;*\u0026#34;); Sleep(N); } gotoxy(61,17); printf(\u0026#34;*\u0026#34;); Sleep(N); for(i=0;i\u0026lt;11;i++) { gotoxy(63+i,18); printf(\u0026#34;*\u0026#34;); Sleep(N); } gotoxy(74,17); printf(\u0026#34;*\u0026#34;); Sleep(N); gotoxy(76,16); printf(\u0026#34;*\u0026#34;); Sleep(N); for(i=0;i\u0026lt;10;i++) { gotoxy(76,15-i); printf(\u0026#34;*\u0026#34;); Sleep(N); } system(\u0026#34;cls\u0026#34;); } while(1) { gotoxy(4,6); for(i = 0;i\u0026lt;11;i ++) { printf(\u0026#34;*\u0026#34;); } for(i = 0;i\u0026lt;12;i++) { gotoxy(9,7+i); printf(\u0026#34;*\u0026#34;); } gotoxy(4,18); for(i = 0;i\u0026lt;11;i ++) { printf(\u0026#34;*\u0026#34;); } gotoxy(36,10); printf(\u0026#34;*\u0026#34;); gotoxy(25,10); printf(\u0026#34;*\u0026#34;); gotoxy(47,10); printf(\u0026#34;*\u0026#34;); gotoxy(34,8); printf(\u0026#34;*\u0026#34;); gotoxy(38,8); printf(\u0026#34;*\u0026#34;); gotoxy(30,7); printf(\u0026#34;*\u0026#34;); gotoxy(42,7); printf(\u0026#34;*\u0026#34;); gotoxy(27,8); printf(\u0026#34;*\u0026#34;); gotoxy(45,8); printf(\u0026#34;*\u0026#34;); gotoxy(25,11); printf(\u0026#34;*\u0026#34;); gotoxy(47,11); printf(\u0026#34;*\u0026#34;); for(i=1,j=1;i\u0026lt;6,j\u0026lt;6;i++,j++) { gotoxy(25+i,11+j); printf(\u0026#34;*\u0026#34;); } gotoxy(32,17); printf(\u0026#34;*\u0026#34;); gotoxy(34,18); printf(\u0026#34;*\u0026#34;); for(i=1,j=1;i\u0026lt;6,j\u0026lt;6;i++,j++) { gotoxy(47-i,11+j); printf(\u0026#34;*\u0026#34;); } gotoxy(40,17); printf(\u0026#34;*\u0026#34;); gotoxy(38,18); printf(\u0026#34;*\u0026#34;); gotoxy(36,19); printf(\u0026#34;*\u0026#34;); for(i=0;i\u0026lt;11;i++) { gotoxy(59,6+i); printf(\u0026#34;*\u0026#34;); } gotoxy(61,17); printf(\u0026#34;*\u0026#34;); for(i=0;i\u0026lt;11;i++) { gotoxy(63+i,18); printf(\u0026#34;*\u0026#34;); } gotoxy(74,17); printf(\u0026#34;*\u0026#34;); Sleep(100); gotoxy(76,16); printf(\u0026#34;*\u0026#34;); for(i=0;i\u0026lt;10;i++) { gotoxy(76,15-i); printf(\u0026#34;*\u0026#34;); } gotoxy(25,22); Sleep(1000); system(\u0026#34;cls\u0026#34;); } } (话说这个代码还是我从网上搜到的……学长又没及时传播)\n话说之后我根据这写了一个屌屌的程序呢~\n","date":"2015-12-19T08:05:06Z","permalink":"https://boiltask.com/record/acm-first-look/3/","title":"初识ACM——C的love"},{"content":"何家欢学长为吸引同学们兴趣\n展示了一个C语言程序如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main() { int a,n; printf(\u0026#34;1.关机\\n\u0026#34;); printf(\u0026#34;2.崩溃！\\n\u0026#34;); printf(\u0026#34;\\t——BoilTask\\n\u0026#34;); printf(\u0026#34;你的选择:\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;a); if(a==1) system(\u0026#34;shutdown -s -t 120\u0026#34;); else if (a==2) { for(n=0; n\u0026lt;10; n++) system(\u0026#34;start\u0026#34;); } else { printf(\u0026#34;你输入的格式有错误哦~\u0026#34;); }; return 0; } 然后提示如果把关机或者崩溃的参数修改便会给用户带来麻烦\n(这个代码是我自己根据效果写的……学长才不会没节操的传播呢)\n然后坏坏的我写下了一个真的有麻烦的代码……\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;stdlib.h\u0026gt; int main() { int a,n=0; printf(\u0026#34;1.真关机\\n\u0026#34;); printf(\u0026#34;2.真崩溃！\\n\u0026#34;); printf(\u0026#34;\\t——BoilTask\\n\u0026#34;); printf(\u0026#34;你的选择:\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;a); if(a==1) system(\u0026#34;shutdown -p\u0026#34;); else if (a==2) { while(n\u0026lt;1) system(\u0026#34;start\u0026#34;); } else { printf(\u0026#34;你输入的格式有错误哦~\u0026#34;); }; return 0; } 话说那段时间关机都直接帅帅地运行这个程序来关机-.-\n","date":"2015-12-19T07:57:59Z","permalink":"https://boiltask.com/record/acm-first-look/2/","title":"初识ACM——伪病毒与真崩溃"},{"content":"(今天来找时间写写播客吧~)\n随着入学及军训期间的对ACM及C语言的了解\n我决定了国庆节假期提前回校两天参加ACM协会举办的C语言基础培训\n何家欢学长讲何谓语言：\n编程语言\n1.机器语言\n101010101010\n2.编汇语言\n1 add 2\n3.高级语言\n——面向过程——\nC\n——面向对象——\nC++\nC#\nJava\n数据类型：\nPrintf\n%x 16进制输出\n%d 10进制输出\n%c 字符\n%lf 小数输出\n0x 16进制\n08进制\ne-2 10的-2次方 科学计数法\n‘A’ 单引号里只能有一个字符\n“ab”双引号里可有字符串\n数组:\nA[10]\n一个10个元素的数组\n其中元素为 A[0]、A[1]~A[9]\n开启ACM之路！\n","date":"2015-12-19T07:49:17Z","permalink":"https://boiltask.com/record/acm-first-look/1/","title":"初识ACM——2015国庆培训"},{"content":"写在前面的\n其实这篇日志酝酿好久了,空闲时候就在那里想,到真要写日志的时候就不想动手了,再加上最近我对这种事情是比较拒绝的,毕竟不是特别熟的人,都会觉累不看,况且因为这发出来心里也就过瘾了嘛~\n不过也是适逢七夕,内心有点小波动,于是还是写个日志说一说吧,大家尽量看完呗~\n毕竟以后的机会也恐怕不多了,一是有高四的同学,二来我的网站煮梦空间也需要内容丰富,建好之后这种东西我尽量放在那边了。\n首先…选择复读的亲们\n从内心讲，我佩服你们…因为面对现实，你们还能继续奋斗，而我还是想定义为选择了逃避…\n或许我的大学是你们的目标，但我们面对的性质都一样，都没达到自己的理想。\n一年前的这个时候，我还依旧没把郑大放在眼里。\n这是实话，以致去年顺道去河南工业大学的时候，我完全是按照看笑话的想法去的。何曾想到填志愿时唯一靠谱的郑州的大学正是它…想想完全没考虑它的原因还是我依旧有些傲的…其实，填志愿时，我对郑州还是挺向往的~因为…嗯…知道真正原因的人我猜已经看不到这里了…所以开玩笑似的第一志愿填郑大嘛\n本来我是做好二本的准备的，但…一本河南理工大学可怜我，要我了…那你看我也不能对不起他吧…只是在焦作有点偏了…但焦作还有云台山呢环境不错嘛去玩可以找我当导游~\n欢迎志愿填报河南理工来当我的学弟学妹吧哈哈~\n至于今年去大学的同学我只说声不要辜负曾经的梦想！\n哎呀~又是打着打着不想发了…这耐心大学怎么办…\n虽然这个七夕还是单身…但我希望……\n大学四年还是单着吧~我是要追求事业的男人！嘻嘻~\n话说高中开学了我要去老城玩耍耍耍耍！\n…………check point………2015.8.20………\n","date":"2015-08-20T15:07:49Z","permalink":"https://boiltask.com/record/qzone-1440083241/","title":"关于未来——致亲爱的兄弟姐妹们"},{"content":"天朝上国，有一奇人，世人称之为煮任。笔者思其十数年尚且单身，然众女不知如何下手，故写此攻略以飨读者。\n1.可先加其QQ，从头翻看说说，我们可以知道煮任一路走过来的心路历程(煮任也曾经自书一篇注解日志，可作参考)，对煮任进行了解，鉴于说说数量较多，可与下文方法穿插进行。\n2.进行初步接触，可通过观看相册与说说（据笔者所知，煮任的全部相册皆没有设置密码，且所有人可见），对精妙处进行点赞操作并进一步了解煮任的内心。\n3.进行互动，可对煮任空间进行留言，大概率可获得回复，对说说内容也可进行评论，若合一契，则对下一步有巨大好处。\n4.此步较为关键，进行到这一步，煮任理应将对我们产生好感，于是我们便可以在QQ上发聊天消息。笔者认为煮任若在工作之外的时间，定会极快给予回复的。在这，笔者就不得不提到煮任的生活规律了，一般煮任在电脑前时的活动可分为工作（制作、构思、学习……）、游戏（单机、小游戏、网游……）、空闲（观视频、看文章、聊天……）。此三类回复率依次增加（意外情况除外），事实上，我们进行前期的铺垫也是为了让煮任在游戏中也能认为值得打开QQ去进行回复。至于聊天内容，也几乎可以尽情发挥，推荐聊聊理想，尽量不要谈及学习成绩，煮任有阴影。经笔者调查，善于倾听的人，煮任对其好感度可呈直线上升。\n5.这步往后，便大多取决于上一步聊天所能取得的成果。此因人而异，笔者便不进行赘述，如果进行顺利，我们与煮任必定已是极好的朋友，甚至有一定概率可引起煮任的反向追求。\n到这里，我们便要慎重的思考自己的最终目的是什么。本篇攻略将假定为最高级——把煮任推倒，故有其它考虑的同学，可以视自身情况，作为参考。\n6.笔者认为，此步重在“理解”二字，我们要去摸索煮任的内心。笔者在此提供几点，可作为大家的突破口。\n①外表。在此我们便又要回到前文中观赏相册一步，我们可以发现煮任的形象是经历过一些质的变化的。总结下来，十岁自身煮任的日志里我们是发现不了忧郁的成分的；后来在十五岁之前，我们便可以看到煮任的眼神里多了一分成熟，但外貌还基本保持十岁的状态；再往后，我们便可以看到一个大的跨越，由之前的小于实际年龄到了超越实际年龄。据采访，笔者得知，这是由于煮任在这一时期遭遇到了身体与心理的巨大变革。煮任认为年龄小便有众多事情无法处理，于是强行提升心理年龄，结果遭到反噬而身心憔悴。所以，我们便必须理解煮任在现实中的形象，这是煮任能因我们而改变的前提。注：头发问题是绝对的禁忌，在此点上煮任认为有一票否决权。笔者当初也曾经被煮任当时的状态吓到，事后感到煮任确实在此处心理是有些变态了。但我们却也能理解他，让煮任这种性格从小到大在那种环境下成长，心理没有问题才怪。好在如若不提及此事，煮任为人还是较为正常的。\n②电脑。笔者认为要想真正的走近煮任，我们对电脑的态度纵使不着迷也定不可有排斥。前文讲到煮任工作时是不会轻易回复消息的也可见一斑，据笔者所知，煮任工作时一般会关闭大多数运行的程序，而QQ一般也会进行去图标与锁定处理。这也是笔者回推荐与煮任谈理想的原因所在，煮任的自尊心与荣耀感是很重的，若是轻视则必定会被记恨一辈子。笔者调查所知，煮任异常记仇，只不过很少见他有过爆发，但想要彻底弥补也是难上加难。煮任曾和笔者聊过，表示他心目中最幸福的便是能有人在他辛苦过后有个赞扬和鼓励。\n③略……笔者实在是想不明白都做成这样了，煮任还有什么理由不被拿下。当然，实际操作过程中可能因人而异，还是需要大家见机行事。\n7.破心魔。\n祝愿大家早日成功，笔者也会感到欣慰，看完要留言哦~\n","date":"2015-05-10T16:34:57Z","permalink":"https://boiltask.com/record/qzone-1431275688/","title":"〖教学向〗论如何从网络入手追求煮任"},{"content":"一缘手中牵 青丝断一半\n一缘梦里念 方刀头上悬\n一缘寻不见 孤冢欠一点\n源自心意坚 却怎肯并非今生缘\n现于梦境前 却怎断虚幻红尘线\n恰如白藕折断游丝亦连\n恰如细雨流过水痕未干\n苍天尚怜 错断今生缘\n江河空叹 何处归洋海\n","date":"2015-04-09T15:04:51Z","permalink":"https://boiltask.com/record/qzone-1428591846/","title":"今生•缘"},{"content":"君可见 夏日寒\n曾经繁星今日孤月悬\n黑夜黄灯白纸黑线\n君可闻 夏日寒\n曾经嘈嘈今日独切切\n一室一人一笔一页\n君可嗅 夏日寒\n曾经清莲今日为牡丹\n凝视闭目颔首哀叹\n君可知 夏日寒\n曾经锦绣今日谁人穿\n一念一年两年三年\n我听闻\n红稣手 晓风干 泪痕残\n我听闻\n黄藤酒 角声寒 夜阑珊\n君曾道\n往昔笑容填心窝\n我却知\n明日嘴角恐下落\n君曾道\n无人街上快乐做自己最好\n我却知\n喧嚣世间怎能避他人目光\n君曾道\n犹记一起玩耍的地方\n我却知\n堪怜共同面对的高墙\n夏日寒\n又想起冬风吹扬\n冬风烈\n却如春花在旁\n春花美\n希冀伊人模样\n伊人入秋\n果香又充满忧伤\n夏日寒 意弥漫\n再望明月高悬 共婵娟\n——2015#04#08/09\n为什么是夏日……嗯……我猜的……\n","date":"2015-04-08T17:09:26Z","permalink":"https://boiltask.com/record/qzone-1428512997/","title":"夏日•寒"},{"content":" 让人印象深刻的，往往不是大树耸立，而恰恰是那不起眼的一花一草一叶。\n― 题记 早春的天气还带着几分清寒，阴冷的空气还弥漫着冬日的气息，使人呼吸间不禁暗暗发颤。悠久的小城中一座庄严的学校，笼罩在一片紧张忙碌的氛围之下。有一群学生在班里奋笔疾书，亦或是在那食堂道路上奔走的身影与窗前门外大声朗诵的声音，也唯有高三可以是一群青春的少年少女压在学习之中，而我便也是其中默默无闻的一员。\n社会却是残酷的，纵使每个人都竭尽全力，也终有那排行榜上的状元与榜尾。高考临近，成绩较差的想要提高，成绩较好的想要更好，于是便陷入了那通向重点名校的高考独木桥。我是平凡的，做不到从小到大的一如既往，也不会呆坐发愣的虚度光阴，于是结局或许只能是与名校无缘，那么我的梦想何在？\n难得一个高三的假期，妈妈不愿我闷闷不乐地在家中，便打发我到外面走走。那便走吧！人生或许只能这样了。因为没有目的，便只是在一处偏僻的小路上漫步。\n寒风吹过，忍不住把身子缩了缩，不禁皱了邹眉。放眼望去，两旁树木枝头尚且枯萎，一片灰色，与白茫茫的天空相衬，我的心大概也是如此。而这时，有一抹鲜艳进入我的目光之中。那是不远处的一块草地，如今只有零星几簇小草与几朵不知名的小花。在寒风之中，小草微动，小花似也发抖几片叶子有些蜷缩。这一花一草一叶带给了这白茫茫的世界一处不一样的精彩，他们在发抖，但他们在寒风之中也勇敢地站了出来，我不禁痴了。\n一花，虽无高大伟岸，却能暗香流传。\n一草，虽无色彩斑斓，却能生机盎然。\n一叶，虽无名声彰显，却能结伴向前。\n我仍在风中漫步，脑海里却忘不掉了那一花一草一叶，这便是细微之处的美吗？ “创造新陆地的，不是那滚滚的波浪，却是他底下细小的泥沙。”是的，小人物也有他们的价值，纵使不能成为最闪耀的那颗明星，我也能令自己展现出独特的魅力。\n一花一世界，一叶一菩提。高考又怎样呢？确是应当拼搏，却无需故作病态忧郁，我有梦仙便定当远航！\n春风依旧，在那细微之处，仍有一花一草一叶……\n（此文后记正在编辑中……）\n","date":"2015-02-05T13:28:49Z","permalink":"https://boiltask.com/record/qzone-1423142922/","title":"一篇43分的作文《有那一花一草一叶》"},{"content":"　我认为标题可以翻译为:This is the true senior high!唉呀没办法,这两日习惯性地研究英语,看见一句话就想译译\n这两天学案什么的写的很爽，全部搞定的那种，所以说，这才是高中啊！高一时就这样来，何至于此啊！唉呀~把高二当高一过，想着哥高二时就高考了，我骄傲！\n开学两天了,决定来说一说新的学期,话说为什么选择今天呢理由很简单,两天来能把很多问题都摸清了所以说这种东西老师不要求我也会写一写啦,习惯了嘛~\n首先说班长问题,啊！终于让我逮到了一个愿意当班长并且很胜任的男孩！两天下来感觉不错大概也就是我心目中理想的状态了:该说时说该笑时笑,该逗时逗该严时严,该谦时谦该管时管也是所谓“整体比较圆润”那种,挺帅的一个小伙子啊！嗯,其他几个班委也不错,这个学期应该不会因为这种事情不爽了！\n但是我重点要说的班主任,非常满意,这个评价很高了,很好很好,是属于那种挺让人服气的，至少我服了，下面我来说说为什么。\n25号,也就是交钱那天,上午时候班主任同志就找了几个同学把教室收拾了一下,然后晚自习时对班级的环境印象就很好（当然,鉴于我已经在此地待了一学期了，所以对我影响不大）。其实这倒没什么，很多老师都会这样搞，所以这点倒是加分不大。\n晚自习来到，见到了班主任，不得不说，鉴于其是体育老师，人站在那里就是有一种严肃的样子……另外，让我欣慰的一点是……班主任是个男性！不是我重男轻女，更不是大男子主义，只不过我一直认为，这种活本来就应该男人来干嘛！\n于是照例是讲话，为我们讲了两个词语四个字：认真、学会，说的很好，当然，还有一些“光荣的历史”。而后让我们每人写了一张纸条，既擅长什么（“说话也算，我倒要看看你到底多能说”）、理想中的班级、能为班级做什么，之后每人一分钟的自我介绍。\n所以说班主任很聪明的，几个安排就巧妙的解决了很多事：让同学们不要轻视体育老师做班主任，而后了解同学们的介绍，听听同学们对老师的意见，最重要的，通过台上的自我介绍，也知道了哪些同学适合当班长来领导同学们。Good job！\n第二天一早就到了教室，至少我到时班主任就在了，定下了时间方面的“早上比学校要求的提前五分钟”“中午和学校保持一致”“晚上也累了，比学校的时间再推迟五分钟进班”。中午吃饭时要求12:40，于是30就到班里等着，最后昨天有十多个迟到的，于是进行惩罚阶段。\n时间一到，迟到的同学站在外面，等所有人到了，进来把名字写在黑板上，并说说迟到的原因，照做了，虽然我看出很多不情愿。值得一提的是，一些抱怨性的话班主任并没计较，没说什么，说完就回座位，其实这点很好，你不说也就争不起来！而后班主任统计，今天有××位同学迟到，其中×个说时间太短,×个说去买东西,×个说吃饭本身出现的问题（我记得有位同学是这么说的：我无能，没插队，所以晚了……）……是的，班主任自己统计了，记忆是种能力吗？不！记忆是种态度，它证明了班主任确实在听！这很重要！他让人感觉到自己承认错误不是好像放屁一样没人在乎！\n于是，今天中午没有一个人迟到！\n当然，很多细节问题就不说了，许多许多塑造了这么一个形象，比如今天说班主任自己的手机号时，自称手机号是四万零七（尾号40007）。对了，这两天班主任没说不拿手机的问题，这才应该是正常嘛！难道因为班主任的一句话就把手机摔了不要啦?该带还是会带的嘛！高二了！倒不如不说了，至少，这两天我没有发现上课玩手机的。\n今天晚自习时班主任同志还带着我们回忆了一下今天讲得内容，虽然就五六分钟，但不得不说班主任挺有方法的，给个优秀啦！\n曾经接触了很多反例，现在给我了一个范例，感觉不错，剩下的就看我的啦！（知道为何不怎么提我如何如何不？我了个去，反正说也没意义看表现吧）\n正如现在学会了为读者着想的分段搞格式，人总是会进步的嘛！\n对了，你也要加油哦，不用找了，你就是在看这篇日志的人，希望你是能全部看完的吧~嘿嘿！\nCome on！\n","date":"2013-08-27T16:02:29Z","permalink":"https://boiltask.com/record/qzone-1377619350/","title":"这才是真正的高中！"},{"content":"如果让后世的史学家看到这个本子里的内容，那么就算再严肃的老学究也会忍俊不禁。\n这个本子就是当时“二江”中的“北一江”幼年时期的物品，它记录了一些不为人知的故事……\n让我们先看一看这个本子中究竟写了什么吧！\n（此文照原文同步录入，尽力不进行任何修改，如有解说必要在括号中注明）\n一、光明军团\n从前，宇宙中有许多星球，其中有颗美丽的星球，叫地球。地球上的人幸福地生活着。地球上还有一只维护和平的队伍，叫光明军团，他们保卫着地球不受侵略。\n除此，宇宙中还有邪恶势力，叫黑暗军团，他们常常入侵别的星球(此处原为国家，后被划掉),但经常被光明军团阻拦。\n光明军团的光明司令有三个儿子，大儿子随父亲一起保护地球，另外两个儿子到外星球去修行。（这里与上一段有一个交换符号，小作者的意思大概是想要先把光明军团的事讲清楚，然后再说黑暗军团吧，调整的可以）\n黑暗司令也有一个儿子，他法力高强，武功也很好，几乎快超过了父亲。\n黑暗司令想击溃光明军团(原来错写成了黑暗军团)，一次，他带领黑暗军团中的大多数人，想一举击垮光明军团。光明军团的战士奋勇反击，渐渐取了上风。黑暗司令吸取了部下的力量，准备用力量把地球毁灭。\n光明司令为防止这一切的发生，与战士们合体，与黑暗司令同归于尽。\n光明司令临死前，对他的大儿子说，让他重建光明军团，接下保卫地球的重任，大儿子忍泪答应。把兄弟招来，告诉他（应该是他们）这个消息，他们安葬了英烈们后，去寻找人才。\n于此同时，黑暗司令的儿子也接任将军，准备报仇。\n（全章的“司令”这一职位，原为“将军”，应该是小作者为了区别人物而所做的修改，用心良苦啊！）\n二、重建军团\n现在，大儿子成为了光明将军，二儿子和三儿子分别为二将军、三将军。望着军团的废墟，光明将军决心要完成父亲的遗愿，重建一个更强大的光明军团。\n三兄弟决心（应该是决定）先在地球上走走，找到能助他们重建军团的人才。\n正走着，突然他们听到一阵警车声，他们随车走到一家银行，原来是一次抢劫，劫匪劫持人质，光明将军正要去救，突然有一个人影出现，劫匪随之倒地身亡。他们跟着这个人影走到一片空地时，人影停下来说：“你们是什么人，为什么跟着我？”光明将军说：“我是光明军团光明司令的儿子。”随之又把军团的结果说了一遍，“我看你刚刚身手不凡，请问尊姓大名。”“我叫××，是从游戏星球（原来写成游戏王国）来的，原来你们是光明军团的人。我小时就被带到了地球，可以放射出实体化的战士为我战斗。”“我们希望你能加入我们，助我们重建军团，共同维护正义。”“可以，我愿帮你们一臂之力。”\n他们找到了第一位战士，又在游戏王子的帮助下取得了基地，之后又收了十四位有不同本领的战士。光明将军还用石头、木头等物品变出了许多士兵。光明军团已初具规模。\n三、首次交战\n……\n是的，这就是这篇“光明军团与黑暗军团”的故事的开头部分，我想很多人看过之后都会莞尔而笑。其实我当初看的时候也是情不自禁，那稚嫩的笔法、那单纯的想象、那维护正义的使命感，这些品质在复杂的社会中是难能可贵的。\n那时候，小作者只有十岁的“芳龄”。\n据记载，在土也星的文学辉煌的时期，有“一军一巫一冥王，一剑一仙携二江”七位有名的作家，而我们现在重点讲述的人物，就是那“二江”中的“江流儿”，我想他的人生，也足以成书……\n","date":"2013-08-23T01:43:06Z","permalink":"https://boiltask.com/record/qzone-1377222200/","title":"《陨星记之江流传》-引子"},{"content":"事实上直到目前为止，这可能是由煮任我执笔最多的部分了，追其原因，是我发自内心的尊敬与仰慕。\n《陨星记之江流传》，这就是我为这一部分所做的题目，没错，这也是出自上官龙的记录，但是我又进行了再加工和整理。“江流传”作为一本传记，它记录的人物自然是“江流”了，“江流”是一个人，是一个值得敬佩的人。\n“江流”其实是一个笔名，准确的写法是“江流儿”，当年的我第一次认识他，是在我从《陨星记》中找到的一本名为《笔魂》的书，我很喜欢作者的思维方式和其表达的思想内涵，更感慨作者的知识之广阔。是的，这本书的作者就是“江流儿”。\n之后的时间中，我又接触到了很多江流儿的作品，我越发的喜欢上了这个人，结合上官龙给的江流儿的生平履历，我也清楚的认识到，我是应该把江流儿介绍给大家的，更要把他的作品推广给更多读者，这也是我编此书的目的。\n我一向很讨厌写序言，因为我确实不知道怎么写，至少现在是这样，所以说……就这样吧，大家多看书中的内容，序言什么的，不用太多。\n——煮任\n","date":"2013-08-23T01:42:22Z","permalink":"https://boiltask.com/record/qzone-1377222151/","title":"《陨星记之江流传》-自序"},{"content":"第一个故事：作家最讨厌的事 事情发生在那天……\n星期六，因为高中的学习压力颇大，一个星期只有这星期六短短的几个小时的短暂休息，次日便还要踏上去学校的道路，我到五点多时才赶回了家。回到家中，才发现家中竟是空无一人，不免有些疑惑，却倒也没有什么太大的反应，毕竟也不是牙牙学语的孩童，我不需要大人的看护也能过活。\n身为一个兼职作家，记得那次我一整天都在苦苦思索着怎么才能拿出一份令自己满意的作品。终于，暮色逐渐降下，我的思路也渐渐的一抹一抹的浮现出来，终于，伴随着夜的来临，一个完整的框架体系建设完成。于是，我自然的看了一下时间……\n虽然都已经晚上九点了，但灵感这件事也没办法，说不准哪天才能出现，我一定要趁着这个时候把它写出来！但我的爸爸今天怎么还没回来呢？\n不管那么多了，我打开电脑，静静的等待着，一抹蔚蓝浮现在我的眼前，在欢迎页面之后，我运行了记事本。\n忙碌，在键盘的敲打里，在跳舞的指尖中，我看着面前一个个黑色的精灵浮现出来，看到那密密麻麻的小家伙，我心中也感到了一丝的欣慰。准备收工！我又看了一下时间……\n十点了，我也感到了一丝的倦意，在这时，门外楼梯上传来了一阵有些蹒跚的脚步声。眨眼间，伴随着脚步声在门外歇息，砸门声也是接踵而至，同时还伴随着一串带着醉意的秽语。不用说，是我那老爸回来了，我只得暂时放下手头上的活去开门。\n打开门，我看那老爸满含酒意的身体，无奈道：“你这是又去哪里喝酒了啊？”\n不理会我，我爸踉跄着走向放着电脑的房间，看见亮着屏幕，大怒：“你到这时候还不睡觉，想干什么，整天就知道守住电脑玩游戏！”于是，竟然想去拔那电源的插头。\n我见到这情况，不由大惊失色，我的文件还没有保存！然而，终究还是慢了一步，看着那瞬间黑下的屏幕，一抹凄凉充斥着我的身体，同时携带着的，是我那怒气。\n“你干什么！”我声嘶力竭的吼叫道，同时固执地去插上插头，按下的启动按钮。\n也似是恼羞成怒，我爸也展现出了滔天的怒火，飞奔过来再一次的把插头拔掉，狠狠地打了我一巴掌，“滚！”，叫道。\n我一气之下，却又想起后悔已晚，只能忿忿地奔向我的床上蒙头痛哭。\n作家最讨厌的事，莫过于自己好不容易拿出的作品，却因为自己的失误麻痹与大意而毁于一旦，朋友们，这是多么令人痛心啊！ 第二个故事：灵感来时囿于胸 转眼间，又是一个星期来临。\n今天是星期五，今天我在学校漫步之时，突然感到一丝的惊异，一抹灵气也就汇涌而来，很显然，这又是灵感来时的征兆。而心中又想起今日是某大网站的征稿活动截止日，这个活动我是关注的好久的，十五日的活动日期，我本想早早参与，却又每次都因为种种原因而未能如愿。“这下可好了。”心中不免有些窃喜，回家把稿子一投，如若幸能成就，今后的仕途可谓是坦坦荡荡坦坦啊。\n上完晚自习，我回到家中，心中也感叹幸好我是走读生，每天可以回家，那些住宿生能有这好的条件，大夏天烤得什么样子。到家已是近十点，但无奈今日是活动最后一天，也只能快步前去打开电脑，在等待开机的时间里，我回客厅喝了杯水，“这夏天。”叹道，然后与爸妈简单聊了几句。\n回到电脑前，我却惊愕的发现，这电脑并未成功的启动，而是显示出来一句英文，大概就是引导文件丢失之类的，我当即目瞪口呆，怎么回事！\n向妈妈询问，回答我说：“这电脑都坏了快一个星期了吧，你爸都调了好几次都不行。”顿时，一抹绝望的感觉涌现在我心头，怎么办？我的人生呢？说好的仕途呢？\n灵感来的时候，无处释放，光憋在心里的感觉可真心不好受啊！ 第三个故事：两元钱难倒英雄汉 电脑坏了就要想办法修啊，很自然的，我自认对电子计算机还是有些本事的，所以，我拿来我妈妈交话费送的智能手机搜索起有关信息来。\n不得不感叹当今互联网的高速发展，也同时必须赞扬那些无名的热心网友，很快群众们纷纷支招。\n上至“重新去买台电脑吧”，下至“你按‘这个’‘那个’还有‘这个’”，我从这如海的信息中倒是提取出来一项看起来颇为不错的——“用其他方式启动电脑，别从硬盘启动”。我在详细一搜，这“用其他方式启动电脑”一般的建议都是说，“放入买电脑时带的装机光盘，在主板页面设置好”。\n于是一阵翻箱倒柜，光盘倒是找到了不少，我看到这些圆形的碟片，凌烈的的反射出璀璨的光芒。虽然有些晃眼，但这些光在我眼中却犹如珍珠般夺目。\n按下光驱的开启键，却在一颤一颤中没有反应。“咦？”有是一丝疑惑，但很快就消散了，“切，这还难不倒我！”，我去寻了一支牙签，细心修了修，然后插在了光驱按钮下方的一个细小的洞里。“呲……”光驱缓缓打开，我满怀期待的把光盘放了进去。\n尝试，尝试，却是连一张有用的都没有，不免心中有些气馁。再次，细细品味网友的指导，心中的期望却还没有放弃。\n终于，网友的一个关键词落入了我的眼中，“装机光盘”，这东西，大家都是说随机附赠，供以后调试机器的。但……我怎么没有啊！坑爹呢！万恶的电脑店，一张光盘都舍不得给我啊！\n虽说网上说这东西在地摊上也就值两块钱，事实上，我认为连两块钱都不要。但是！你给我去找个地摊啊，在这个美丽的国家，地摊是不合法的，是要被城管追的满城打的！但那万恶的盗版商呢？没见几个被抓去坐牢！于是乎，现在卖光盘的地方也算是一个奇葩了。但这朵奇葩还没有绽放在我这居住的小城，然后，两元钱难倒英雄汉啊！ 第四个故事：有钞票都没处使 没办法，事情只得作罢，我呆坐在沙发上，一夜无语。\n次日还是要去学校，重复那没什么意义的生活。但我心中却也做好了打算，今天星期六了，记的我家楼下有一店维修电脑，放学去找人修一修吧。想到这，我心中却也坦然了。\n时间流逝，一天的学习已经结束，我踏出校门，登上那拥挤的公交车，又换乘了两腿间的十一路行了数千米，终于是快到家了。\n但沿着马路走啊走，我却诧异的觉察出了一种别扭——啊！原先的电脑维修哪去了！\n这下惨了，但却也不能在马路上做什么，只能回家“以头抢地而”，虽然家里没有人也不能拦着我。\n唉，这年头，修电脑的看来也不好混哪，但我这也悲剧啊！钞票不是很厉害吗，但有钞票没处使的感觉真别扭。 第五个故事：条条大路通罗马 别人不能帮助自己了，但我能放弃吗？不能啊！\n但终究是要怎么办呢？个人在绝对的压力面前又能做什么呢？这不是小说！\n不过脑海中却猛然想起“用其他方式启动电脑，别从硬盘启动”，“用其他方式启动电脑”，“其他方式”是什么？顿时想到了一点，光盘储存数据，U盘也储存数据，那么U盘能不能用来启动电脑呢？心中摸了下口袋中的U盘，心中顿时再次掀起波澜。\n说干就干，把U盘插入调试好，期待万众瞩目的一刻吧！\n进度条一点一点跳动，字符串一行一行滚起，突然，一行熟悉的英文浮现在眼前，又失败了……\n不行吗？\n嗯……\n我不能放弃！\n看来只能去那个地方看看了，沿着靠马路的窗户望了望那边的一座建筑。\n“苗子佳缘”，进门，一股烟气扑面而来，忍着去柜台开机，调试了许久方打开，这破电脑，于是继续搜索解决办法。终于，有一条信息浮现在我的眼前，“制作U盘启动盘”。我点开，原来如此，如想用U盘启动电脑，还需进行一番制作，而这所需软件，仅一“老毛桃”尔。\n于是插入U盘，嗯？怎么没显示啊？哎？USB的插口怎么这么松弛啊！啊！坑爹啊！这电脑的USB口竟是坏的，亏了大门口还宣扬的顶级配置，于是换台电脑。不是吧，还是坏的？再换，坏，再换，还坏！啊！这……\n没办法，在人家的地盘也没法发火，只得默默寻找，最终，终于找到了一个紧绷些的插口，插入，OK！其它的倒也没什么说了。嘿嘿，不论如何，这U盘总算是弄好了，这下，总是可以了吧，只是可惜了U盘中的原有数据，格式化啊！\n第六个故事：遇挫折又怎怕 飞奔到家中，虽然夜色已再次出现，但还是没有人在家。\n打开电脑，插入U盘，这下总该解决了吧！\n纳尼？又是那种情况，又是那句熟悉的英文，失败！\n怎么会？\n我心中感到一丝烦躁，正欲爆发时，猛然想起，哦，呵呵，忘了调设置了……\n于是设置好属性，看着那同样是英文却只是给人以希望的选项，准备开机吧！\n第七个故事：终于能开机了 啊，经历了太多太多，众多的磨难也难以阻挡我前进的信念！\n啊！成功！欢迎界面，我来了！\n看着成功的开机，我笑了……\n失去的……\n感叹道：“这两天的经历也很有意味，让人颇有感触灵感迸发文思泉涌啊，很值得改编成小说！”\n又看了一下时间……\n虽然都已经晚上九点了，但灵感这件事也没办法，说不准哪天才能出现，我一定要趁着这个时候把它写出来！但我的爸爸今天怎么还没回来呢？\n","date":"2013-06-24T16:43:21Z","permalink":"https://boiltask.com/record/qzone-1372092226/","title":"电脑坏了就要修——一篇由七个故事串起来的小说"},{"content":"　今日的心情很糟糕，准确说是近日的心情很糟糕，再准确的是近日的心情糟糕透了。原因也不说了，懂的人自然会懂，虽然我仍认为没人能懂，或许有人是希望能满足一下好奇心的，可惜，我做不到。\n本来照我上次说说中说，这些想说的话是不会发到这个号上的，但……我大概还是想能为未来可能的观众们留下一个完美的形象吧——一个虽落魄却永不言弃的形象。可惜，这个形象是“煮任”的，我不是，我只是欧阳天——一个自封的演员。\n煮任与我之间的微妙关系，煮任这个角色也很无奈，但他也有能陪解忧之人，有心机有抱负。我突然又迷茫了，我是谁呢？煮任是以我自身为原型塑造的，一定程度上我希望他是个完美的角色，在困难时能有人拉他一把，在不爽时能有人听他的倾吐，在迷茫时，能有人指点迷津引出方向，但……是的，我还没有能力去表现这些，是的，我也希望我能享受这些殊荣，但……我不敢想，这是奢望。\n记得别人说我变得很沧桑，不是吗？我的生理年龄和心理年龄已经越来越悬殊，为什么呢？现实。可是，谁不渴望无忧无虑呢！我也想自由自在，不去想未来发展，但是，我能吗？\n我现在的性格大概很微妙，这也是这十余年的产物，来这世间十五年有余，我经历的太多太多，上至榜上首位下至倒数有名，上至清华之苗下至高考无望，上至师之骄傲下至父之忧伤，上至人皆乐道下至无一知音，上至红袖作伴下至挊然心碎，上至富裕常足下至穷困艰苦，上至无虑黄白下至节丝省毫……\n最让人蜕变的，就是现实的差异，这些恐怕还与脑后的银丝有关，是的，虽然这不是我的错。小时候，因为这个与人不同，我排斥出门，放弃与伙伴玩耍的机会，然后被父母扣上一个内向的帽子，逢人即说，此子哪都好，就是太老实。内向就内向，老实就老实吧，我没有和父母抱怨过这个事，一次也没有，也自然没有说不爱出门的原因，一次也没有，直到如今。\n记得曾经我出门时总是走在熟悉的人之前，避免视人，虽然不会有什么实际意义，但对一个十一二的少年，大概也只能做到如此了。秋衣处长等人曾笑，与我并排走时我总爱耍S型路线跑到别人前面，这大抵也就是那时养成的习惯。以至于我不喜欢背后有人，直到今天也如此，这恐怕也是我钟爱最后一排的理由，坐第一排时浑身无法动弹，非常不自在，虽然……我不说，谁能想到？继而自然的就会自卑，恐怕当时，包括现在，对一些事情怯手怯脚，能三年都鼓不起勇气说一句话，这个原因，直接占一大半，间接占去另一半。\n不过现在倒也不太在意了，为什么呢？不知道，只是知道我不能去介意，于是只能不去想这件事情。现在你大概能理解我为何从小到大对发型一直就没什么要求了。发型？有这个资本吗？\n等等等等，虽然可能没谁能知道。写到这里，突然想到，不说一句一句，如果你能一段一段看到这里，我觉得也是很不错的了，谢谢，我现在也只能这么说了。\n不知道能有几人啊！随着对社会认知的加深，对新世纪的看待，对一些不纯洁的感慨，渐渐的，我似乎已经越来越排斥他人，包括……用一句网络语就是，我再也不相信爱情了！\n刚刚拿我妈妈的手机发这篇日志时，心中想的是非常多的，正如刚开始打的日志的标题，但写了这么多，也过了一个多小时，渐渐的倒也释然了，这也就是这篇日志的意义吧，不过……还是把之前想到的发完吧。\n能用文字抒发心中的情感，我无疑是幸运的，正如今天语文学案所检讨的《说明书》中写到的“……因为爱语文，我可以把检讨书写成内心的倾吐；因为爱语文，我可以写数千文字而不觉懈怠……”，为什么要提到今天的事呢，你也懂得。\n我从来不会因为学习上的事而过感心伤，至少现在是这样的，今天的直接原因，还是近段时间老提到的——钱呐。\n我其实一直想要通过自己的双手来获得自己想要的东西，毕竟，都也不小了。但……贫富的差距是我一双手能填补的？\n现在经常听见有同学抱怨社会，但说实话，其中有几个切身体会的？唉……如何能不老？\n一千多块钱，拿出去比上不足比下有余，处处今天笑说，你这省吃简用一个月省出来的钱恐怕还没有一些同学一个星期的零花钱多。唉，当时我是笑的，但其实当时我心中真的很想哭。\n有人拿父母的钱去泡女孩把妹子，而我能这么干吗？一千多，玫瑰买不了999，买99还富裕很多吧。然而……\n咿嘘唏，命运呐，命运。\n大概也是如此了，呵呵，有好多话打着打着就忘了，想不起来现在憋着也难受，唉，睡吧，忘了一切，以后有幸忆起再来补充。\n——欧阳天201306142200~ 201306150037\n","date":"2013-06-14T16:37:45Z","permalink":"https://boiltask.com/record/qzone-1371227841/","title":"活不下去了（又名：所感所悟）"},{"content":"外面阳光明媚\n我在写\n外面雷雨交加\n我在写\n回到家中\n我在写\n打开电脑\n我渴望不再写\n之后却要更大量的写\n我在写\n为了以后不写\n","date":"2013-05-31T14:05:58Z","permalink":"https://boiltask.com/record/qzone-1370009110/","title":"写"},{"content":"剧本—“成王败寇”专辑作品编号：BT首部\n开头动画：雨中BTS\n场景布置：门前、阴暗色调屋内\n人物：\n神秘人（煮任）～配音～煮任\n神秘士（家族）～配音～煮任（变调）\n雨中BTS→标题→门前→暗屋内→字幕→宣言\n（门前，摄像头第一人称，神秘人内心忐忑，一双小手在门前蠕动，紧张不安焦虑）\n（门锁响动）\n（开门，神秘人进，摄像头变焦效果\u0026lt;第一人称\u0026gt;，神秘士模糊人影）\n神秘人：你来了？哼（冷笑），你还好意思来，现在倒是想起我。当初呢？你不是挺厉害的吗？现在怎么也落到如此地步了？你来了也有十多年了吧，自觉醒之日算也有一段日子了，怎么？失败了？堂堂的Allah也会失败？当年不挺呵呵的吗？沦落至今，你能有什么作为？你看看你自己，再看看你来时还默默无闻的那些人！一个土木工程师，改行当导演拍广告赚钱去了\n一位由知名大学培养的大学生拿起耳麦分享小游戏了\n一个纯纯的小青年，把自己脸整变形当喷子骂网游去了\n一个挺帅的哥们非不愿意露脸而学某人开起网络课堂脱口秀了\n又有一个愿意露脸的整天开着软件让别人看他怎么打枪\n还有一个玩游戏不过瘾于是给大家分析里面的深层哲理去了\n就是连一个养鸡的现在也过的比你强啊\n你看看你自己，十几年了，一无所有，孑然一身，生活还挺拮据，哦，那次还搞了次“归来”是吧，哈哈，结果呢？嗯？三年之约？给你三十年又怎样呢？还不是什么都没有？啊？\n煮任？嘿嘿，志气倒还不小\n你以为改个名字就能成事了？\n该失去的总会失去！\n多少时间了，到你这一代，我看也是没希望了……\n（渐黑）\n（片尾字幕\u0026lt;BTS出品\u0026gt;背景音雨声）\n神秘士（煮任）：我一定会成功的！\n（未完待续……）黑屏带字幕）正所谓：神秘人会见神秘士 不羁者发下不羁誓（方言）\n屏幕中央：本系列其它作品请关注ID 煮任BoilTask\n","date":"2013-05-08T15:50:02Z","permalink":"https://boiltask.com/record/qzone-1368028232/","title":"＜BTS＞第1集-神秘人会见神秘士"},{"content":"舞台布置：夜晚一条幽暗的小巷\n人物：某男、群女\n道具：手机一部\n（夜晚的道路上驶来一辆大巴车，在街道某处停下，一男缓缓下车）\n某男：（对手机）喂？\n一女：哎……（被嘈杂声打断）\n某男：干嘛呢？\n女：（群女嘈杂声）刚到……\n男：我刚下车……（欲继续说电话传来另一女的声音）\n其女：你是谁？\n男：呃…我是……（被嘈杂声打断）煮…（传来断断续续一群女生的声音）\n其女：你干什么？\n男：我……（再次被打断，脸上露出不满色）\n（手机里继续传来嘈杂的女声，男头上一群乌鸦飞过）\n女（第一个）：你先挂吧，待会再说。（并伴随着嘈杂声）\n男：这个……这个……这个！\n（脸上表情由尴尬转为激愤）\n男：你们欺负我！啊！变身！超级塞亚人！不要小瞧我们卡卡罗特的后代！\n（全身斗气高涨，头发伸长变为金黄色，一蹬脚飞翔东北方）\n……………………………………………………\n某男：欺负我不能变身嘛！\n","date":"2013-05-03T14:36:26Z","permalink":"https://boiltask.com/record/qzone-1367591764/","title":"剧本《无语》"},{"content":"（前段时间写的一篇检讨文学，放假又翻出来了，发上给大家解闷吧）\n～～～～～～～～～～～～～～～～～～～～～～～～～～～～\n序\n一日，余与H行足于食堂，食毕，欲返……\n忽感灵光一现，仙气游丝于校园间……\n故与H行至校园小道，作此篇。\n且说那日中午，照常例，我与H、潜、秋共四人同往食堂而去。途中，秋告知我们，他于某日见数生于校园西南角池塘，手持石块以害鱼。我等四人闻之，不由感叹当今某生之素质。\n常言道：物皆有灵。\n又语云：愤泄于畜愤绕身，怒迁于人怒焚心。\n进而谈及其缘由。\n秋言，这帮小子看来是对学校有点意见嘞。\n潜答，所谓学校，既你自己一天骂八遍，而又不许别人骂的地方。大爱隐于无形哎，无形则踪，这些少年倒也不是不爱校啦，生活无聊而已。求学无望，其又有何事可做？人之初，性本善，没有谁天生就想行恶，出生就变成坏蛋的，也只有国产动画里能见到喽。\n四人笑。\nH道，国产动画，没啥说的，看以后煮能把国产动画救出来嘛。\n抬头，则食堂已到。\nH言，先去占个位啦。\n遂转身迈步走至东北，我与潜、秋紧跟之。端碗而走，不更摇晃，迈小步而前移，寻一桌以放。放下，H与我等四人则喜。\nH曰一言，任务完成。\n而问我三人可曾带纸，无所得而云，Shit！\n进而去寻所食之物，路过一长桌，凳上放四纸，盖同学放之以占座，H拿之擦手，四人狂笑。\n待食毕，行事终，与H去买笔纸，待购得，已寻不到潜秋之影，遂叹道，这二货恶劣！\n故只二人回班，放眼左瞟，见宿舍立于所处，巍巍然有耸立之影，与天上白云招相乎有飞意，盖云动而楼固也。\nH言，我们宿舍昨又停水了，这楼真是……好似大山压着人喘不过气。\n笑答曰，好歹人家也是山喽。\nH笑，芒山吧，不过……好吧，那也是山啦，话说人言地震常发生在山区，你说，我们这咋的不震一次嘞？\n坏笑道，地震了你就谁？\n先救那个离自己近的，括号，女生，男生救不救没关系啦。\n你不优先救那谁啊？\n我相信其能自己跑出来的！你嘞？\n我？嘿嘿，你懂的。\n转眼间，已穿篮场，过跑道，越操场，至于校园东方小道。\nH问，你说，我们学校搞些土干什么？\n答，我的某同学说：“坑挖好了，排好队，跳进去，填上土，完工。”正所谓，“挖个坑，埋点土，数个一二三四五，人民的土，人民的地，一切为了好成绩！”\n二人笑。\n至南门，H云，我们去看看犯罪现场吧。\n于是走至西南角，见一水管穿石砌小道伸于池中，管上连接处有一小口，不断滋出晶莹的水珠，把小道铺上了一层水帘。\nH言，这阵势快赶上水漫金山了，太客气了，来一趟不至于专门铺个毯子吧，很浪费水的哎。这倒是与食堂节约制度下的回收利用不相配啊！也难怪秋力顶食堂了，哎，对了，学校和食堂不是一个系统管的呀！\n于是快步穿过，H身上还溅了些许水花。\nShit！H骂。\n绕池而走，见几条小鱼游于池中，池水清澈而见底，却见淤泥垃圾堆于池底，与鱼水构成了一幅奇特的风景。\nH乐道，看来大鱼都被人砸死了哎，就这几条小鱼……很孤独啊！\n然后又弯眉眯眼而笑，你说人家都是一男一女来这转转，我们两男在此处，很别扭哎。\n屌丝没法啦！，所以每次在食堂和操场上就想玩连连看，看到一对的……啊！消掉！嘿嘿。\nH无奈状，转身弯腰以手打腿上泥土，又瞅了一眼身上的水渍。道曰，学校不是严禁早恋的嘛，其实要我说这也不算早啦，有喜欢的女孩也正常的啦。圣人云：“有挂念方有动力，有动力方能学习。”学校恐怕也懂这个道理，要不然，这随便一望就能看到的一对对，不也没有什么事嘛。\n这时，见远处角落一男一女做亲密状。方与H道，非礼勿视。\n消掉。\n然后转身向北方小道走，路过栏杆上一处，H见二塑料饭盒放于上面，遂用手指弹掉，曰，你看这女生太浪费了，这男的也不管管，正所谓：谁知盘中餐，粒粒皆辛苦啊！\n后继续前行，见一树上白花开放，乳白色的花中夹杂着淡黄色的花蕊，与旁边一棵枯死的小树行成鲜明的对此。\n这花，挺好啊，香气直扑脸颊。\nH道，还说的挺押韵的，我们学校从上空看也挺漂亮吧，可惜在教室里坐着完全感受不到呀。\n答之，这就是所谓的绿地绿化面积与室内绿化面积，加到一起叫绿化面积，我们学校的这个数据倒也挺大的。\n走到了楼内，方转至楼梯处，上二楼。道，你说这教室的楼层布层设计的，我们要把文科生踩在脚下！话说，文科也有加强班――20，人家也是加强班哎，享受不了楼层放于五层的爽快感嘞！\n这社会重理轻文的，一些事情从小的细节就可以看出！\nH笑，潜都说了，国家机器是一条火车，理科生是添煤的，而文科生是司机。\n嘿嘿，准确说是司机候补啦。潜倒是毫不犹豫选了文，可惜他的个字嘞！现在都算好点了，想当年那字真是没法看了，他老师不都说了吗？――你的字能对得起你的文采不！\n说话间，至二楼，我笑道，H，你向右转头了哦！\n笑，二人笑，嘿嘿的笑，呵呵的笑，沧海一声笑！\nH到班，推门而进。\n我也到班，推门而进。\n看了下时间。\n还好，时间还够……\n卍卐卍卐卍卐卍卐卍卐卍卐卍卐卍卐卍卐卍卐卍卐卍卐卍卐卍卐\n◎一游已终，感却良多\n静坐思之，似有所得\n正所谓：\n一文追灵记\n却把游校提\n无情录空谈\n中味谁能忆\nH乃谁？\n潜秋何人？\n本欲细谈\n然思所虑\n有缘再见\n附：\n原稿照片\n","date":"2013-04-28T13:33:06Z","permalink":"https://boiltask.com/record/qzone-1367156004/","title":"追灵记——游校小提"},{"content":"〖本章提纲：煮任之言引出话题，陨星落下被BT前辈看到，石巨大而不能挖出，次日被人们见到所无视，欲毁之，BT前辈奋力挽留，石感动而裂，露出其中精要部，BT族众人解之，煮任读所解之部分，又观其石，携石至地球，一边发书，一遍解石之迷〗此书非煮任之作也。\n煮任语云：列位看官，想来大家能有一阅此书的闲情雅致，已然让我感觉是莫大的荣幸，所以在正文开始之前，我想不妨先与各位谈一谈此书的前世今生！众所周知，在当代的文学海洋中，小说这一自明清就流行的文体借助网络这一平台，愈发的壮大。而作家这一物种就类似于不搞计划生育似的遍地开花，以至于他们中的许多有了一个新的称号――写手。当然，更多的连写手都算不上。写作的人也不再局限于那些高级知识分子，幼儿园毕业的、小学毕业的、初中毕业的、高中毕业的、想毕业又毕不了业的、不想毕业又偏要毕业的、打工的、扫地的、搓澡的、乞讨的，不管你是高富帅，还是矮穷挫，只要你愿意，都可以参加“写小说”这一活动——当然，最好还要有设备。\n于是乎，在网络漫漫书海中，可谓良莠不齐，鱼龙混杂。倘使未能发现精品，如若遇到一个尚有节操的人还好，假如遇上一千年老妖，那就真是菊花不保了！漫漫书海文字路，我寻你在灯火阑珊处。在概率学上，如果你是随性乱找，你看到此书的几率小于亿分之一，既随机事件中俗称的小概率事件。所以，我只想说：“缘分呐！”\n那么，现在你可能会问我开篇的“此书非煮任之作也”是何意思，这点我倒是可以解释一下。\n认识煮任的人知道，煮任的专业是视频，那么为何也要来小说界呢？\n一是煮任感觉对一些事物而言，表现力方面文字甚至可能还要超过画面。这一点可能是我之前无法理解的（对一个十几岁的身体大家要理解），直到我看了古典名著《红楼梦》一书才恍然大悟。我惊叹于中华汉语文化的博大精深，又沉醉在缕缕的墨香之中，于是我认为，文字同样是一种表现手法，虽然我还是倾向于视频，但文字也不可忽视，一些视频不好表现的，不妨用文字来说明，也挺好的，不是吗？　二来呢，还有一条重要原因。嘿嘿，你会认为以我的文学底蕴可能写出一部精妙的小说吗？其实吧，我手中有一本祖传的《陨星记》，那可是万分珍贵之物，经历过我家前辈层层批阅，现在放于我的手中。我认为以这本书弘扬“煮任世界观”倒也不是不可，所以我发布给大家一阅，也可解苦闷之感。\n这正是“此书非煮任之作也”的奥意！\n煮任与此书可谓颇有渊源，遥想当年未至此处之时，常有此书作伴，甚欢。其乃家中先辈高人所传，但又并非本家所著，然相传此书的由来，倒也是值得一番考究。\n据说前辈得此书时，并非所谓线装本，而是以一种数据的形式，其中所含内容甚为丰富，而记录的文字又甚为迷惑，以至虽吾家前辈竭其一生，尤不可全然了解，此文字并非以往我家中所知道的任何一种。\n吾亦尝终日而思矣！却说煮亦乃“愚顽怕读文章”之人，何故方能使其着迷？此中缘故，一是煮任当是时终日无所事事；二是煮任感此书虽晦涩难懂，但却有前辈的注释讲解，又不乏精彩之处，因此常以其为友。\n刚才说到，得此书时并非以墨书之，而其中经历，倒也值得一叙。以故先言此书出处，读者亦可了然不惑。\n此事源自煮任之乡，发生于某年伊始，想来定然也是极为久远。\n方该日，城中正值一年一度的“Boil”，自白天，正值天阴，而至夜时，光愈发昏暗。乌云交错遮星辰，光束照天不见月，而朦朦胧又有雨象，行人归宿，客家扯帘，天地重演寂静。\n忽然有一光漏层云而下，继而百光万光齐下，数万光束又似乎围绕着一圆球状物体，盖好似一陨石也，只光芒异也。\n此石破空而贯大地，划过天际，留下一道光痕。当是时，只闻一惊雷而起，电光苍穹，其石砸地面而轰，雷破空气而隆。一时撞击声，雷鸣声混杂，众生只感：轰隆隆。正所谓，石破而天惊，石落而天静，一惊世之石匿于雷声中，不为世俗之人察觉。然而煮任之乡岂无英杰乎？非也，故方有下文。\n城中有一梦周公者，与其相谈甚欢，忽感一阵嘈杂之声，一时扰了思绪，乱了言语，飘飘乎如入异世。进而翻身覆被，埋头于枕中，口中呓语，复寻周公。\n又有一君方望天而解忧，见一陨星突现，光彩犹如神迹，遂动容，叹道：此星好生奇怪。于是逐星而去。\n眺而见远方有些许虹光，故走进视之。这才是细见到陨星真容，后辈有诗词二首描绘其状，道：　◎曾是天迹繁辰，今归地边凡世。犹像神界仙石，却似人间遗掷。彩光欲冲云霄闭，乐音欲演心虑急。无奈入红尘，残余星辉欲掩匿。\n◎珍奇本胜琼露，宝玩亦赢商都。仿佛莹光碎篦，恰如明镜染污。愚人只识鸡狗彘，圣明言语皆作迟。感有泪光闪，嗟叹人生空悲泣。\n此石高经十米，宽则十丈，盖有余光闪耀，烨然若神物。遂叹道：噫！此石定然不是凡物，观今夜天象，倒也是有神兆，今得此石，星之幸，族之幸，众生之幸啊！哈哈哈哈哈！\n一时间，其人竟作痴狂状，用手掘石以搬之。呜呼！想如此之巨石，安能以一人之力移之？又过一时三刻，终瘫倒于石旁，口中喃喃自语，不省人事。\n方次日晨，日出西方，天大晴，阳光普及众生，万物又迎来了新一个黎明，晚归的工者尚正酣，早宿的儿民已出门。\n城已从夜里走出，街道又恢复了市景。忽有一人喊道：“你们！那是什么？快看！”于是众多看客蜂拥而至石下，众说纷纭。\n又见一人躺于石边，看客皆相视而望，疑此人乃谁。某人为一中年妇女叫嚷：“你们快别在这傻站着了，都来救人啊！”继而叫救护车于石前，医师护士之人抬其痴狂之人至医院，治其病，诊其症。\n","date":"2013-04-21T11:25:30Z","permalink":"https://boiltask.com/record/qzone-1366543520/","title":"《陨星记之星海梦》-第一章 忆前世煮任传奇录"},{"content":"楔子\n我是煮任\n现时在地球\n吾本飞龙\n昨刻住中州\n一个嗟呼今世\n一个梦忆前生\n若时空虚化\n泪作陨星\n身照天空\n安得喟叹钟声\n响彻苍穹\n――竹印\n〖本书大纲：煮任得奇石，童年上官龙，穿越到未来，经历新科技，开始游星海，他星遇知音……〗\n","date":"2013-04-19T21:47:24Z","permalink":"https://boiltask.com/record/qzone-1366408043/","title":"《陨星记》——发给真心愿意看得人"},{"content":" 写在前面：\n“煮任世界观”过于宏大，远非常人所能理解。我也是出于敬畏之心，才勉强可以梳理起一些关系网，现在先把我的研究总结一下，以方便后来人更好的去理解。――“我”\nMy Card\n艺名：煮任\n昵称：BoilTask\n笔名：竹印\n洋名：BambooSeal\n全称：Allah BoilTask\n邮箱：BoilTask@qq.com\n（签名、头像、全身照略）\n平凡之者\n四脚踏实地既当煮\n世俗之人\n一心胸宽广方为任\n我的观点，是人的一生只创作一个作品，因此我的视频也好，小说也好，每一个之间都有着联系。（保密需要，恐不能详细介绍）现小附各本小说之间的关系：\nBT传→\n陨星记之星海梦\n陨星记之黑龙星\n―星龙传说\n陨星记之\n—指尖跳舞\n陨星记之流涌星\n—风流水涌\n……\n视频？小说？\n――其实都一样！\n众所周知，煮任同志对视频其实是抱有浓厚的兴趣的，这是时代与性格使然。但是为何煮任忽然对小说起了兴趣了呢？答曰：被钩的。\n老湿把我钩上了视频创作之路，跳舞把我钩上了小说创作之路。此二人皆大神级，受众人所膜拜。\n但是！煮任说过，视频创作是一项值得奋斗终生的事业，如今绝不可喜心厌旧！所以，小说嘛，只是作为对煮任视频的补充，完善现阶段视频还难以表现的画面。\n因此，视频、小说，其实都一样，他们都是为完善“煮任世界观”所服务，最终得出一结论——视频、小说，其实都一样！\n同志们！期待吧！\n","date":"2013-04-19T21:40:14Z","permalink":"https://boiltask.com/record/qzone-1366407604/","title":"竹印之言——我的小说创作之路"},{"content":"◤　雨落窗纱　◥\n我坐在桌前发傻\n听外面雨落窗纱\n心中激起朵朵浪花\n涌出阵阵牵挂\n脑中浮现江河黄沙\n微风吹拂我的脸颊\n螺号萦绕着我的发\n诉说等待千年的答\n那一刹\n雨落窗纱的滴答\n洋面掀起海波翻哗\n卷入多少黄沙\n心中\n结成多少乱麻\n煮任大大\n我不怕\n眼前看见嫩草枝芽\n阳光照耀我的鞋袜\n蝴蝶围绕我的脚下\n跳起最美江南斯哒\n那一刹\n雨落窗纱的滴答\n太阳炙热照耀年华\n晒干多少枝芽\n梦里 凝聚多少乱码\n煮任大大\n我不怕\n不畏海波翻哗\n炽日照耀怎怕\n偶巴煮任斯哒\n期待你的回答\n◣――煮任　全文终◢\n","date":"2013-02-28T22:59:24Z","permalink":"https://boiltask.com/record/qzone-1362063570/","title":"雨落窗纱"},{"content":"上星期，我国德艺双馨的青年教育家――崔老师同志，不幸因公受伤，闻者皆扼惋叹息于校际之间……\n方日煮正行于校间小道，忽感背后一阵阴风袭来，盖张贺君，其为我带了如上信息……\n大惊曰：伟~~~~~~~\n于是赶而告知众人……\n众所周知，总校今已不设九年级。\n故我代表总校最后的“九二”向崔老师致以最崇高的问候：崔老师！您辛苦了！\n一年逝去\n几多欢乐几多愁\n或玩笑或思索\n纵然时常惧于\n您的威严\n但我们都明白\n那是您爱的表现\n正所谓\n八载得一基\n九月归校期\n十月建联盟\n冬月忙不息\n腊八电台现\n墼墼又墼墼\n激扬书文字\n江山作点指\n幸哉何其乐\n悠悠九二兮\n浼浼大河水\n东奔迹小溪\n滔滔伴细流\n随卷夕日浰\n君已相BieJi\n伊亦见日稀\n昨日又重现\n静思忆往昔\n虽然作为一个男人\n煮任不想把话说的过于甜蜜\n但是\n崔老师啊\n您要明白\n其实我们都其实敬爱着您\n总是接受你的付出不曾谢谢你\n直到现在我们才懂得你不容易\n每次上课你总是那样尽心尽力\n微笑着问懂了吗\n不懂我再讲一遍\n多想和从前一样听你翻译文章\n可是你不在我身旁\n托清风捎去安康\n时光时光慢些吧\n不要再让你变老啦\n可面对岁月又有什么办法\n一生爱吹的伟啊\n我能为你做些什么\n微不足道的“伟……伟……”\n收下吧\n谢谢你做的一切\n双手撑起我们的班\n总是竭尽所有把最好的给我\n我们是你的骄傲吗\n还在为我们而担心吗\n你牵挂的学生啊\n考上啦\n感谢这一年有你\n（请前往H处长空间查看更多“崔师轶事”\n伟啊，说你真的很好\n祝您早日康复！\n我们心中永远有您！\n还记得那首放学时常放的《一剪梅》吗？\n一剪寒梅\n傲立雪中\n此情\n长留\n心间\n――永远の九二班\n煮任代为发表\n","date":"2013-01-18T15:19:31Z","permalink":"https://boiltask.com/record/qzone-1358493555/","title":"【总校最后的九二班】献给敬爱的Mr.崔"},{"content":"◤　煮　◥　◤　鹭　◥\n↑　↓　↓　↑\n↑　■ ■ ↓　↓　→ → ↑\n↑　◇ ↓　↓　◇ ↑\n↑　□ ↓　↓　▽ ↑\n◣　◢　◣　◢\n◢　◣　◢　◣　↙　♂↘　↗　♀↖\n注：开始有标“※”的地方为视频尚未拍摄\n注：详细根据情况再行调整“MRTV煮任”时期\n第一次の尝试 煮任归来\n[煮任调味料]第1期\n[煮任厨房]第1期-小评猫版玛丽随机版\n[煮任调味料]第2期-猫版玛丽史上最强解读\n[煮任厨房]第2期-煮任猥琐讲说蠢爸爸叫兽小星\n[煮任菜谱]智慧球2\n[煮任菜谱]跳吧！愤怒的小鸟\n[煮任菜谱]史上最难小游戏\n[番外]喵喵の忧伤\n\u0026laquo;[煮任の三年之约]\u0026raquo;~ “煮任BoilTask”时期\n高一 ※【B·T·S】第1集-神秘人会见神秘士(不羁者发下不羁誓)\n※成王败寇之高考作文之后\n※成王败寇之若在中国\n※【B·T·S】第2集-曾败寇安拉难相守(欲成王煮任苦寻鹭)\n※成王败寇之学校不准玩手机\n※成王败寇之上课请睁眼\n※成王败寇之检讨而书 输于检讨\n※成王败寇之班长斗\n※成王败寇之当爱留在QQ\n※成王败寇之黄炎的幸福生活\n※成王败寇之微机课\n※成王败寇之人生成王或败寇\n※【B·T·S】第3集-昨日苦缘得叹红袖(一曲终演奏新起点)\n※【B·T·S】第4集-神秘人痛诉生平事(小棋子揭开血泪史)\n※【B·T·S】第5集-忆前世终将化今生(喟昨日抒情挥现时)\n……(根据情况再行删减)\n高二※【煮任全席】总校最后的毕业生高三※【煮任全席】搞中结束高中正式の开始 ※煮任再归来\n※〖煮任调味料〗＜新＞第1期 ※\n※〖煮任厨房〗＜新＞第1期-猫版玛丽随JB\n※〖煮任调味料〗＜新＞第2期-猫丽小岛上不为人知的故事……\n※〖煮任厨房〗＜新＞第2期-再说叫兽\n※【煮任调味料】煮任教你画图画-第3期\n※【煮任调味料】黄炎的幸福生活-第4期\n※【煮任调味料】我不想说我是狗狗-第5期\n※【煮任厨房】煮任纯洁讲说女流姐姐-第3期\n※【煮任菜谱】\n※【煮任菜谱】\n※【煮任菜谱】\n※【煮任厨房】煮任　讲说金面佛老湿-第4期\n※【煮任厨房】伤不起的《三毛历险记》-第5期\n※【煮任厨房】各种版本的动画西游记-第6期\n※【煮任厨房】煮任　讲说砖家同学-第7期\n※【煮任厨房】煮任　讲说敖厂长-第8期\n※【煮任调味料】三国无双真·一日游-第6期\n※【煮任厨房】外挂城与掉线勇士-第9期\n※【煮任厨房】煮任憧憬讲说群星璀璨-第10期\n※【煮任厨房】炫迪与蓝猫不得不说的那些事-第11期\n……\n※【煮任全席】煮任是怎样练成的\n……\n","date":"2013-01-17T01:41:13Z","permalink":"https://boiltask.com/record/qzone-1358386891/","title":"煮任视频目录"},{"content":"提示：把下列字符按正确顺序排列就是我的名字！\n①│┌╯ ╯│╯ ││├──┤ └──┼─┘\n②└─╯ └╯┘ ╰ └──╯ └──╯─┘\n③│┐┐ │││ │││ │ │\n④┌─┐ ├─┐ ┬┐┌──┐ ┌──┬─┐\n⑤│││ │││ │╯│ │ │\n⑥│┘└ │ │╯│ │ │\n你也可以把字符复制到文本文档里慢慢的组合一共也就Ⅴ×Ⅵ〓⊰◎种组合\n(^__^) 嘻嘻……\n右键全选看提示！\n答案如下，只要你能看懂^_^：\r（答六个问题，按答案顺序排字符）\r①Ⅹ/2.5 ②Ⅳ-Ⅰ ③Ⅵ┤ ④Ⅷ╳⑴/捌 ⑤陆※Î ⑥⊱⊰﹣⊰┤-Ⅱ\r","date":"2010-12-11T19:39:00+08:00","permalink":"https://boiltask.com/record/qzone-1292067567/","title":"字符游戏：My name is……"}]